from __future__ import annotations
import argparse, re
from pathlib import Path
from typing import Optional, List, Dict
from dataclasses import dataclass

import pandas as pd
from openpyxl import load_workbook

# ---------- Config ----------
COVER_CELLS = {"entity": "F6", "year": "F7", "quarter": "F8"}
FALLBACK_CELLS = {"entity": "C6", "year": "C7", "quarter": "C8"}
MONTH_COLS = ["C", "D", "E"]   # M1..M3
TOTAL_COL  = "F"               # optional quarter total
MONTHS_BY_Q = {
    "Quarter 1": ["Jan","Feb","Mar"],
    "Quarter 2": ["Apr","May","Jun"],
    "Quarter 3": ["Jul","Aug","Sep"],
    "Quarter 4": ["Oct","Nov","Dec"],
}
FILENAME_ET_RE  = re.compile(r"(^|\b)LMS_([A-Z]{2,3})_", re.IGNORECASE)
FILENAME_FIID_RE= re.compile(r"(^|_)LMS_[A-Z]{2,3}_(\d{2,4})", re.IGNORECASE)

def norm_sheet(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "")).strip()

def read_cell(ws, addr: str):
    try:
        return ws[addr].value
    except Exception:
        return None

def to_int_safe(x):
    try:
        return int(str(x).strip())
    except Exception:
        return None

def to_float_zero(x) -> float:
    if x is None: return 0.0
    if isinstance(x, str) and x.strip()=="":
        return 0.0
    try:
        return float(x)
    except Exception:
        try:
            return float(str(x).replace(",",""))
        except Exception:
            return 0.0

def parse_filename_tokens(path: Path):
    et = None; fiid = None
    m = FILENAME_ET_RE.search(path.name)
    if m: et = m.group(2).upper()
    n = FILENAME_FIID_RE.search(path.name)
    if n: fiid = n.group(2)
    return et, fiid

@dataclass
class Meta:
    entity: Optional[str]
    year:   Optional[int]
    quarter_label: Optional[str]

def read_cover_meta(wb) -> Meta:
    ent = yr = qlbl = None
    if "Cover" in wb.sheetnames:
        ws = wb["Cover"]
        ent = read_cell(ws, COVER_CELLS["entity"])
        yr  = read_cell(ws, COVER_CELLS["year"])
        qlbl= read_cell(ws, COVER_CELLS["quarter"])
    if ent in (None,"") or yr in (None,"") or qlbl in (None,""):
        # fallback: look at first non-cover sheet
        for sn in wb.sheetnames:
            if sn.lower().strip() == "cover": continue
            ws = wb[sn]
            ent = ent or read_cell(ws, FALLBACK_CELLS["entity"])
            yr  = yr  or read_cell(ws, FALLBACK_CELLS["year"])
            qlbl= qlbl or read_cell(ws, FALLBACK_CELLS["quarter"])
            if ent and yr and qlbl: break
    yr = to_int_safe(yr)
    qlbl = str(qlbl).strip() if qlbl else None
    ent = str(ent).strip() if ent else None
    return Meta(ent, yr, qlbl)

def harvest_sheet(ws, meta: Meta, file: Path, sheet_name: str, fi_type: Optional[str], fi_id: Optional[str]) -> List[Dict]:
    rows: List[Dict] = []
    # Figure month names for this file's quarter (optional; fall back to M1..M3)
    mnames = MONTHS_BY_Q.get(meta.quarter_label or "", None)
    # Iterate all rows; take Column A as "row_label"
    max_r = ws.max_row
    for r in range(1, max_r+1):
        row_label = ws.cell(row=r, column=1).value  # Column A
        if row_label is None or str(row_label).strip()=="":
            continue  # skip fully blank row labels; keeps output compact
        # Capture Month 1..3 and optional Quarter Total
        for i, col in enumerate(MONTH_COLS, start=1):
            val = to_float_zero(read_cell(ws, f"{col}{r}"))
            rows.append({
                "file_name": file.name,
                "sheet":     norm_sheet(sheet_name),
                "row_label": str(row_label).strip(),
                "month_index": i,                 # 1,2,3
                "month_name": mnames[i-1] if mnames else f"M{i}",  # Jan/Feb/Mar or M1..
                "value":     val,
                "quarter_total": None,            # filled below
                "entity_name": meta.entity,
                "year":       meta.year,
                "quarter":    meta.quarter_label,
                "fi_type_token": fi_type,
                "fi_id":      fi_id,
            })
        # Quarter total in F (optional)
        qtot = to_float_zero(read_cell(ws, f"{TOTAL_COL}{r}"))
        # record it as a separate helper row (month_index=0)
        rows.append({
            "file_name": file.name,
            "sheet":     norm_sheet(sheet_name),
            "row_label": str(row_label).strip(),
            "month_index": 0,
            "month_name": "Q_total",
            "value":     qtot,
            "quarter_total": qtot,
            "entity_name": meta.entity,
            "year":       meta.year,
            "quarter":    meta.quarter_label,
            "fi_type_token": fi_type,
            "fi_id":      fi_id,
        })
    return rows

def extract_file(path: Path, verbose=False) -> List[Dict]:
    try:
        wb = load_workbook(str(path), data_only=True, read_only=True)
    except Exception as e:
        if verbose: print(f"[ERROR] open {path.name}: {e}")
        return []
    meta = read_cover_meta(wb)
    if verbose:
        print(f"  · {path.name} → entity={meta.entity}, year={meta.year}, quarter={meta.quarter_label}")
    fi_type, fi_id = parse_filename_tokens(path)
    out: List[Dict] = []
    for sn in wb.sheetnames:
        if sn.lower().strip() == "cover":
            continue
        try:
            ws = wb[sn]
        except KeyError:
            continue
        out.extend(harvest_sheet(ws, meta, path, sn, fi_type, fi_id))
    return out

def main():
    ap = argparse.ArgumentParser(description="RLMS raw extractor (fast harvester)")
    ap.add_argument("--inputs", required=True, help="Folder to scan (e.g., OneDrive/RLMS/Submission)")
    ap.add_argument("--out-csv", default=None, help="Output CSV path (long table)")
    ap.add_argument("--out-parquet", default=None, help="Optional Parquet path")
    ap.add_argument("--limit", type=int, default=None, help="Limit number of files for a quick test")
    ap.add_argument("--verbose", action="store_true")
    args = ap.parse_args()

    root = Path(args.inputs)
    if not root.exists():
        print(f"[ERROR] Inputs folder not found: {root}")
        return 2

    files: List[Path] = []
    for ext in ("*.xlsm","*.xlsx"):
        files.extend([p for p in root.rglob(ext) if not p.name.startswith("~$")])
    files.sort()
    if args.limit: files = files[:args.limit]
    if args.verbose: print(f"Found {len(files)} files")

    all_rows: List[Dict] = []
    for p in files:
        if args.verbose: print(f"- {p.name}")
        all_rows.extend(extract_file(p, verbose=args.verbose))

    if not all_rows:
        print("[WARN] No rows harvested.")
        return 1

    df = pd.DataFrame(all_rows)
    # Ensure types
    num_cols = ["value","quarter_total","year","month_index"]
    for c in num_cols:
        if c in df.columns: df[c] = pd.to_numeric(df[c], errors="coerce").fillna(0)

    # Default outputs
    ts = pd.Timestamp.now().strftime("%Y%m%d_%H%M%S")
    out_csv = Path(args.out_csv) if args.out_csv else root / f"RLMS_raw_harvest_{ts}.csv"
    out_csv.parent.mkdir(parents=True, exist_ok=True)
    df.to_csv(out_csv, index=False)
    print(f"[OK] CSV written: {out_csv}")

    if args.out_parquet:
        out_pq = Path(args.out_parquet)
        out_pq.parent.mkdir(parents=True, exist_ok=True)
        df.to_parquet(out_pq, index=False)
        print(f"[OK] Parquet written: {out_pq}")

    return 0

if __name__ == "__main__":
    raise SystemExit(main())
