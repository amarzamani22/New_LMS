# duplicate_by_cover.py
from __future__ import annotations
import argparse, re
from pathlib import Path
from typing import List, Optional
import openpyxl
from openpyxl.workbook.workbook import Workbook
from openpyxl.utils import column_index_from_string

# Cells to write on Cover
ENTITY_CELL = "F6"
YEAR_CELL   = "F7"
PERIOD_CELL = "F8"

Q_MAP = {
    "Q1":"Quarter 1","Q2":"Quarter 2","Q3":"Quarter 3","Q4":"Quarter 4",
    "1":"Quarter 1","2":"Quarter 2","3":"Quarter 3","4":"Quarter 4"
}

def _safe_name(s: str) -> str:
    return "".join(ch if ch.isalnum() or ch in "-_." else "_" for ch in str(s))

def _read_range_values(wb: Workbook, ref: str) -> List[str]:
    """
    Read values from a sheet range like:  'Sheet Name'!$A$20:$A$200
    """
    m = re.match(r"^'?(?P<sheet>[^'!]+)'?!\$(?P<c1>[A-Z]+)\$(?P<r1>\d+):\$(?P<c2>[A-Z]+)\$(?P<r2>\d+)$", ref)
    if not m:
        raise ValueError(f"Unsupported range ref: {ref}")
    gd = m.groupdict()
    sheet = gd["sheet"]
    if sheet not in wb.sheetnames:
        raise ValueError(f"Sheet not found: {sheet}")
    ws = wb[sheet]
    c1 = column_index_from_string(gd["c1"])
    c2 = column_index_from_string(gd["c2"])
    r1 = int(gd["r1"])
    r2 = int(gd["r2"])
    vals: List[str] = []
    for row in ws.iter_rows(min_row=r1, max_row=r2, min_col=c1, max_col=c2):
        for cell in row:
            if cell.value not in (None, ""):
                vals.append(str(cell.value).strip())
    return vals

def _read_named_range_values(wb: Workbook, name: str) -> List[str]:
    """
    Read values from a named range (global).
    """
    try:
        dn = wb.defined_names[name]
    except KeyError:
        raise ValueError(f"Named range not found: {name}")
    vals: List[str] = []
    for title, coord in dn.destinations:
        if title not in wb.sheetnames:
            continue
        ws = wb[title]
        for row in ws[coord]:
            for c in row:
                if c.value not in (None, ""):
                    vals.append(str(c.value).strip())
    if not vals:
        raise ValueError(f"Named range '{name}' is empty.")
    return vals

def _split_comma_list(s: str) -> List[str]:
    # strip leading/trailing quotes and split by comma
    s = s.strip()
    if s.startswith('"') and s.endswith('"'):
        s = s[1:-1]
    parts = [p.strip() for p in s.split(",")]
    return [p for p in parts if p]

def _resolve_formula_entities(wb: Workbook, formula: str) -> List[str]:
    """
    Accepts formula string WITHOUT leading '='.
    Handles:
      - Named range:            EntityList
      - Sheet range:            'Cover'!$A$20:$A$200
      - INDIRECT("EntityList") or INDIRECT("'Cover'!$A$20:$A$200")
      - Comma list:             "A,B,C"
    """
    f = formula.strip()

    # Comma-separated list in quotes
    if (f.startswith('"') and f.endswith('"')) and ("," in f):
        return _split_comma_list(f)

    # INDIRECT("...") patterns
    m_ind = re.match(r'^INDIRECT\(\s*"(.+?)"\s*\)$', f, flags=re.IGNORECASE)
    if m_ind:
        inner = m_ind.group(1)
        # inner can be a named range OR a sheet range
        try:
            return _read_named_range_values(wb, inner)
        except Exception:
            # try sheet range
            return _read_range_values(wb, inner)

    # Plain named range?
    if re.match(r"^[A-Za-z_][A-Za-z0-9_]*$", f):
        return _read_named_range_values(wb, f)

    # Plain sheet range?
    if re.match(r"^'?.+?'?!\$\w+\$\d+:\$\w+\$\d+$", f):
        return _read_range_values(wb, f)

    # If we reach here, it's something we don't evaluate (e.g., OFFSET, complex expr)
    raise ValueError(f"Unsupported validation formula: {formula}")

def _get_entities_from_dropdown(wb: Workbook, manual_range: Optional[str]) -> List[str]:
    """
    Try several strategies to get the entity list:
      1) If manual_range is provided, use that.
      2) Read validation formula on Cover!F6 and resolve.
      3) Fallback: find a named range containing 'Entity' and use it.
    """
    if manual_range:
        # allow either named range OR explicit sheet range in this arg
        try:
            if re.match(r"^[A-Za-z_][A-Za-z0-9_]*$", manual_range):
                return _read_named_range_values(wb, manual_range)
            return _read_range_values(wb, manual_range)
        except Exception as e:
            raise SystemExit(f"[ERROR] --entities-range failed: {e}")

    if "Cover" not in wb.sheetnames:
        raise SystemExit("No 'Cover' sheet found in template.")
    ws = wb["Cover"]

    dv_formula = None
    if ws.data_validations:
        for dv in ws.data_validations.dataValidation:
            # Check if F6 is inside the validation sqref
            sq = str(dv.sqref or "")
            # Quick containment test (covers 'F6' or a big range including F6)
            if "F6" in sq:
                dv_formula = dv.formula1  # includes leading '=' sometimes
                break

    if dv_formula:
        # Strip '=' if present
        if dv_formula.startswith("="):
            dv_formula = dv_formula[1:]
        try:
            vals = _resolve_formula_entities(wb, dv_formula)
            if vals:
                return vals
        except Exception as e:
            # fall through to named-range heuristic
            print(f"[WARN] Could not resolve F6 validation formula ({e}). Trying fallbackâ€¦")

    # Fallback: search for a named range with 'entity' in its name
    for nm in wb.defined_names.definedName:
        if "entity" in nm.name.lower():
            try:
                vals = _read_named_range_values(wb, nm.name)
                if vals:
                    print(f"[INFO] Using named range '{nm.name}' (fallback).")
                    return vals
            except Exception:
                continue

    raise SystemExit(
        "Could not discover entity list.\n"
        "Tip: pass --entities-range \"'SheetName'!A2:A200\" OR a named range (e.g., --entities-range EntityList)."
    )

def duplicate(template: Path, outdir: Path, years: List[int], quarters: List[str], entities_range: Optional[str]) -> None:
    keep_vba = template.suffix.lower() == ".xlsm"
    # Load once to read dropdown list (or manual range)
    wb_head = openpyxl.load_workbook(str(template), data_only=True, keep_vba=keep_vba)
    entities = _get_entities_from_dropdown(wb_head, entities_range)
    wb_head.close()

    print(f"[INFO] Found {len(entities)} entities.")
    total = 0
    for y in years:
        for q in quarters:
            q_norm = Q_MAP.get(str(q).upper(), str(q))
            if q_norm not in {"Quarter 1","Quarter 2","Quarter 3","Quarter 4"}:
                raise SystemExit(f"Invalid quarter '{q}'. Use Q1..Q4 or 1..4.")
            out_q_dir = outdir / str(y) / ("Q" + q_norm.split()[-1])  # Q1..Q4
            out_q_dir.mkdir(parents=True, exist_ok=True)

            for ent in entities:
                # Open fresh copy each time, write only three cells, save
                wb = openpyxl.load_workbook(str(template), data_only=False, keep_vba=keep_vba)
                if "Cover" not in wb.sheetnames:
                    wb.create_sheet("Cover", 0)
                ws = wb["Cover"]
                ws[ENTITY_CELL] = ent
                ws[YEAR_CELL]   = int(y)
                ws[PERIOD_CELL] = q_norm

                fname = f"{_safe_name(ent)}_{y}_{q_norm.replace(' ', '')}{template.suffix}"
                dest = out_q_dir / fname
                wb.save(str(dest))
                wb.close()
                total += 1
                print(f"[OK] {dest}")

    print(f"[DONE] Generated {total} files under {outdir}")

def parse_years(spec: str) -> List[int]:
    spec = spec.strip()
    if "-" in spec:
        a, b = spec.split("-", 1)
        return list(range(int(a), int(b)+1))
    return [int(x) for x in spec.split(",") if x.strip()]

def parse_quarters(spec: str) -> List[str]:
    spec = spec.strip().upper()
    if spec == "ALL":
        return ["Q1","Q2","Q3","Q4"]
    return [x.strip() for x in spec.split(",") if x.strip()]

def main():
    ap = argparse.ArgumentParser(description="Duplicate RLMS submission by just changing Cover!F6/F7/F8.")
    ap.add_argument("--template", required=True, help="Path to a template submission (.xlsx/.xlsm)")
    ap.add_argument("--outdir",   required=True, help="Output root folder")
    ap.add_argument("--years",    required=True, help="e.g. 2025-2027 or 2025,2026")
    ap.add_argument("--quarters", default="ALL", help="ALL or comma list like Q1,Q2 or 1,2")
    ap.add_argument("--entities-range", default=None,
                    help="Optional override for the entity list. "
                         "Pass a named range (e.g., EntityList) or a sheet range like 'Lookups'!A2:A200")
    args = ap.parse_args()

    template = Path(args.template)
    outdir   = Path(args.outdir)
    years    = parse_years(args.years)
    quarters = parse_quarters(args.quarters)

    duplicate(template, outdir, years, quarters, args.entities_range)

if __name__ == "__main__":
    main()
