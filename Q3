# extract_q3.py
from __future__ import annotations
import argparse, time
from pathlib import Path
from typing import List, Dict, Tuple, Optional

import pandas as pd
from openpyxl import load_workbook

# ---- Config ----
LIKELY_DATA_SHEETS = [
    "Banking & DFI", "Banking & DFI ", "Banking & DFI  ",
    "Insurance/Takaful", "Insurance & Takaful", "Data"
]
COVER = {"entity": "F6", "year": "F7", "quarter": "F8"}

# Quarter → month labels used in the staging
MONTHS_BY_Q: Dict[str, List[str]] = {
    "Quarter 1": ["Jan", "Feb", "Mar"],
    "Quarter 2": ["Apr", "May", "Jun"],
    "Quarter 3": ["Jul", "Aug", "Sep"],
    "Quarter 4": ["Oct", "Nov", "Dec"],
    "Q1": ["Jan", "Feb", "Mar"],
    "Q2": ["Apr", "May", "Jun"],
    "Q3": ["Jul", "Aug", "Sep"],
    "Q4": ["Oct", "Nov", "Dec"],
}

# Fixed cell map for Q3
WC_ROWS = [169, 170, 171, 172, 173, 174, 175]   # A169..A175
VAL_COLS = ["C", "D", "E"]                      # months within the quarter


# ---- Helpers ----
def read_cover_meta(wb) -> Tuple[Optional[str], Optional[int], Optional[str]]:
    ent = yr = q = None
    if "Cover" in wb.sheetnames:
        ws = wb["Cover"]
        ent = ws[COVER["entity"]].value if COVER["entity"] in ws else None
        yr  = ws[COVER["year"]].value if COVER["year"] in ws else None
        q   = ws[COVER["quarter"]].value if COVER["quarter"] in ws else None
    try:
        yr = int(str(yr).strip()) if yr is not None else None
    except Exception:
        yr = None
    ent = str(ent).strip() if ent else None
    q   = str(q).strip() if q else None
    return ent, yr, q

def pick_data_sheet(wb) -> str:
    names_norm = {s.strip().lower(): s for s in wb.sheetnames}
    for want in LIKELY_DATA_SHEETS:
        key = want.strip().lower()
        if key in names_norm:
            return names_norm[key]
    for s in wb.sheetnames:
        if s != "Cover":
            return s
    return wb.sheetnames[0]

def read_num(ws, addr: str) -> float:
    v = ws[addr].value
    if v in (None, "", "-"):
        return 0.0
    try:
        return float(v)
    except Exception:
        try:
            return float(str(v).replace(",", ""))
        except Exception:
            return 0.0


# ---- Core extraction ----
def extract_q3_from_file(path: Path) -> pd.DataFrame:
    try:
        wb = load_workbook(str(path), data_only=True, read_only=True)
    except Exception:
        return pd.DataFrame()

    ent, yr, qlabel = read_cover_meta(wb)
    if not ent or not yr or not qlabel:
        try: wb.close()
        except Exception: pass
        return pd.DataFrame()

    months = MONTHS_BY_Q.get(qlabel, [])
    if len(months) != 3:
        try: wb.close()
        except Exception: pass
        return pd.DataFrame()

    ws = wb[pick_data_sheet(wb)]
    records: List[Dict] = []

    for r in WC_ROWS:
        wc = str(ws[f"A{r}"].value).strip() if ws[f"A{r}"].value is not None else ""
        if not wc:  # skip fully blank label rows
            continue
        vals = [read_num(ws, f"{c}{r}") for c in VAL_COLS]
        records.append({
            "entity_name": ent,
            "year": yr,
            "quarter": qlabel,
            "question": "Q3",
            "worker_category": wc,
            months[0]: vals[0],
            months[1]: vals[1],
            months[2]: vals[2],
        })

    try: wb.close()
    except Exception: pass
    return pd.DataFrame(records)


# ---- CLI ----
def main() -> int:
    ap = argparse.ArgumentParser(description="Extract RLMS Question 3 into a staging workbook (fixed cells, fast).")
    ap.add_argument("--input", required=True, help="Folder containing submissions (.xlsx/.xlsm)")
    ap.add_argument("--out",   required=True, help="Output staging workbook (.xlsx)")
    ap.add_argument("--limit", type=int, default=None, help="Limit number of files (debug)")
    args = ap.parse_args()

    root = Path(args.input)
    if not root.exists():
        print(f"[ERROR] Folder not found: {root}")
        return 2

    files: List[Path] = []
    for ext in ("*.xlsx", "*.xlsm"):
        files.extend(p for p in root.rglob(ext) if not p.name.startswith("~$"))
    files.sort()
    if args.limit:
        files = files[:args.limit]
    print(f"[INFO] Files to scan: {len(files)}")

    t0 = time.perf_counter()
    rows: List[pd.DataFrame] = []
    for i, p in enumerate(files, 1):
        df = extract_q3_from_file(p)
        if not df.empty:
            rows.append(df)
    out = pd.concat(rows, ignore_index=True) if rows else pd.DataFrame()

    # Sort for readability
    if not out.empty:
        month_cols = [c for c in ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"] if c in out.columns]
        out = out.sort_values(["entity_name","year","quarter","worker_category"] + month_cols, kind="mergesort").reset_index(drop=True)

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with pd.ExcelWriter(out_path, engine="openpyxl") as xw:
        if not out.empty:
            out.to_excel(xw, index=False, sheet_name="Q3")
        else:
            # keep a minimal sheet to avoid "at least one sheet must be visible" error
            pd.DataFrame(columns=["entity_name","year","quarter","question","worker_category","M1","M2","M3"]).to_excel(
                xw, index=False, sheet_name="Q3"
            )
    print(f"[DONE] Wrote staging → {out_path}  ({time.perf_counter()-t0:0.2f}s)")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
