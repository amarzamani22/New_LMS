# qc_build_all.py
from __future__ import annotations
import argparse
from pathlib import Path
from typing import Dict, List, Tuple, Iterable
import numpy as np
import pandas as pd

MONTHS_BY_Q = {
    "Quarter 1": ["Jan","Feb","Mar"],
    "Quarter 2": ["Apr","May","Jun"],
    "Quarter 3": ["Jul","Aug","Sep"],
    "Quarter 4": ["Oct","Nov","Dec"],
    "Q1": ["Jan","Feb","Mar"],
    "Q2": ["Apr","May","Jun"],
    "Q3": ["Jul","Aug","Sep"],
    "Q4": ["Oct","Nov","Dec"],
}

# Core helpers ---------------------------------------------------------------

def _num(s: pd.Series) -> pd.Series:
    # Robust numeric coercion
    return pd.to_numeric(s, errors="coerce").fillna(0.0)

def _month_cols_present(df: pd.DataFrame) -> List[str]:
    return [c for c in ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","M"] if c in df.columns]

def _mcols_for_row(q: str) -> Tuple[str,str,str]:
    ms = MONTHS_BY_Q.get(str(q), [])
    return (ms[0], ms[1], ms[2]) if len(ms) == 3 else (None, None, None)

def _add_Q_total(df: pd.DataFrame, mon_cols: Iterable[str]) -> pd.DataFrame:
    cols = [c for c in mon_cols if c in df.columns]
    if cols:
        df = df.copy()
        df["Q_total"] = _num(df[cols[0]])
        for c in cols[1:]:
            df["Q_total"] = df["Q_total"] + _num(df[c])
    return df

def _finalize(ex_list: List[Dict]) -> pd.DataFrame:
    if not ex_list:
        return pd.DataFrame(columns=["entity_name","year","quarter","where","key","check","expected","actual","severity"])
    out = pd.DataFrame(ex_list)
    # Make sorting stable/readable
    sort_cols = [c for c in ["entity_name","year","quarter","where","key","check","severity"] if c in out.columns]
    return out.sort_values(sort_cols, kind="mergesort").reset_index(drop=True)

# QC builders ----------------------------------------------------------------

def qc_q1a_main(stg: pd.DataFrame) -> pd.DataFrame:
    if stg.empty:
        return _finalize([])
    df = stg.copy()
    # Month set is by quarter; we already have months labelled by name in staging.
    # Compute Q_total per row using the correct 3 months for each row’s quarter.
    # Fast path: precompute per quarter
    ex: List[Dict] = []

    # 1) Totals rows vs sum of categories, per subquestion & month
    # Identify total labels
    total_labels = {
        "Employment = A + B(i) + B(ii)": "TOTAL Employment",
        "A. Malaysian": "TOTAL Malaysian",
        "B (i) Non-Malaysian: Permanent Resident": "TOTAL Non-Malaysian: Permanent Resident",
        "B (ii) Non-Malaysian: Non-Permanent Resident": "TOTAL Non-Malaysian: Non-Permanent Resident",
    }
    # Six base categories (same across Q1)
    cats = [
        "Managers","Professional","Technicians & Associate Professionals",
        "Clerical Occupations","Operative Workers","Elementary Occupations"
    ]
    month_cols_all = _month_cols_present(df)

    for (ent, yr, q, subq), g in df.groupby(["entity_name","year","quarter","subquestion"]):
        m1, m2, m3 = _mcols_for_row(q)
        if not m1:  # quarter label unknown
            continue
        # Sum of categories
        cat_sum = pd.Series({
            m1: _num(g.loc[g["worker_category"].isin(cats), m1]).sum(),
            m2: _num(g.loc[g["worker_category"].isin(cats), m2]).sum(),
            m3: _num(g.loc[g["worker_category"].isin(cats), m3]).sum(),
        })
        # Find total row expected label
        tlabel = total_labels.get(subq)
        if not tlabel:
            continue
        trow = g[g["worker_category"]==tlabel]
        if trow.empty:
            ex.append({
                "entity_name": ent, "year": yr, "quarter": q, "where": "Q1A_Main",
                "key": f"{subq}", "check": "Missing total row",
                "expected": tlabel, "actual": "—", "severity": "FAIL"
            })
            continue
        # Compare each month
        for col in [m1,m2,m3]:
            tv = _num(trow[col]).sum()
            ev = float(cat_sum[col])
            if abs(tv - ev) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q1A_Main",
                    "key": f"{subq} | {col}",
                    "check": "Total row equals sum of categories",
                    "expected": ev, "actual": tv, "severity": "FAIL"
                })
    return _finalize(ex)

def qc_q1a_jobfunc_q4(stg_jf: pd.DataFrame, stg_main: pd.DataFrame) -> pd.DataFrame:
    if stg_jf.empty or stg_main.empty:
        return _finalize([])
    ex: List[Dict] = []
    # Dec = M3 for Q4
    main_q4 = stg_main[stg_main["quarter"].astype(str).str.upper().isin(["Q4","QUARTER 4"])].copy()
    if "Dec" not in main_q4.columns:
        return _finalize([])

    # Sum job functions by entity/year/quarter/subsection/worker_category
    jf_sum = (stg_jf[stg_jf["quarter"].astype(str).str.upper().isin(["Q4","QUARTER 4"])]
                .groupby(["entity_name","year","quarter","subsection","worker_category"], as_index=False)["value"].sum()
             ).rename(columns={"value":"jf_total"})

    # Map to main Dec value for the same keys (use subsection name to align)
    key = ["entity_name","year","quarter","subsection","worker_category"]
    merged = jf_sum.merge(
        main_q4[key+["Dec"]].rename(columns={"Dec":"dec_main"}),
        on=key, how="left"
    )
    merged["dec_main"] = _num(merged["dec_main"])
    merged["jf_total"] = _num(merged["jf_total"])

    bad = merged[np.abs(merged["jf_total"] - merged["dec_main"]) > 0.5]
    for _, r in bad.iterrows():
        ex.append({
            "entity_name": r["entity_name"], "year": r["year"], "quarter": r["quarter"], "where": "Q1A_JobFunc_Q4",
            "key": f'{r["subsection"]} | {r["worker_category"]}',
            "check": "Sum(job_function) equals Dec in Q1A Main",
            "expected": float(r["dec_main"]), "actual": float(r["jf_total"]), "severity": "FAIL"
        })
    return _finalize(ex)

def qc_q1b(stg: pd.DataFrame) -> pd.DataFrame:
    if stg.empty:
        return _finalize([])
    df = stg.copy()
    ex: List[Dict] = []

    cats = [
        "Managers","Professional","Technicians & Associate Professionals",
        "Clerical Occupations","Operative Workers","Elementary Occupations"
    ]
    totals = {
        "Employment = A + B(i) + B(ii)": "TOTAL Employment",
        "A. Malaysian": "TOTAL Malaysian",
        "B (i) Non-Malaysian: Permanent Resident": "TOTAL Non-Malaysian: Permanent Resident",
        "B (ii) Non-Malaysian: Non-Permanent Resident": "TOTAL Non-Malaysian: Non-Permanent Resident",
    }

    for (ent, yr, q, subq), g in df.groupby(["entity_name","year","quarter","subquestion"]):
        m1, m2, m3 = _mcols_for_row(q)
        if not m1:
            continue
        tlabel = totals.get(subq)
        if not tlabel:
            continue
        trow = g[g["worker_category"]==tlabel]
        if trow.empty:
            ex.append({
                "entity_name": ent, "year": yr, "quarter": q, "where": "Q1B",
                "key": subq, "check": "Missing total row",
                "expected": tlabel, "actual": "—", "severity": "FAIL"
            })
            continue
        for col in [m1,m2,m3]:
            s = _num(g.loc[g["worker_category"].isin(cats), col]).sum()
            t = _num(trow[col]).sum()
            if abs(t - s) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q1B",
                    "key": f"{subq} | {col}",
                    "check": "Total row equals sum of categories",
                    "expected": s, "actual": t, "severity": "FAIL"
                })
    return _finalize(ex)

def qc_q2a_main(stg: pd.DataFrame) -> pd.DataFrame:
    if stg.empty:
        return _finalize([])
    df = stg.copy()
    ex: List[Dict] = []

    # Identity: Salary & Wages = sum(A..E) by worker_category & month
    sw_label = "Salary & Wages = A+B+C+D+E"
    parts = [
        "A. Basic Salary & Wages",
        "B. Arrears to Basic Salary & Wages",
        "C. Bonus",
        "D. Others (overtime, COLA, allowance, etc.)",
        "E. Commissions Paid At Least Once a Month (RM)"
    ]

    for (ent, yr, q, wc), g_wc in df.groupby(["entity_name","year","quarter","worker_category"]):
        m1, m2, m3 = _mcols_for_row(q)
        if not m1:
            continue

        lhs = g_wc[g_wc["subsection"]==sw_label]
        if lhs.empty:
            continue
        lhs_m = [_num(lhs[m1]).sum(), _num(lhs[m2]).sum(), _num(lhs[m3]).sum()]

        rhs = g_wc[g_wc["subsection"].isin(parts)]
        rhs_m = [_num(rhs[m1]).sum(), _num(rhs[m2]).sum(), _num(rhs[m3]).sum()]

        for col, l, r in zip([m1,m2,m3], lhs_m, rhs_m):
            if abs(l - r) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q2A_Main",
                    "key": f"{wc} | {col}",
                    "check": "Salary & Wages = A+B+C+D+E (by month)",
                    "expected": r, "actual": l, "severity": "FAIL"
                })

    # Subsection totals vs sum of their categories (Managers..Elementary)
    cats = [
        "Managers","Professional","Technicians & Associate Professionals",
        "Clerical Occupations","Operative Workers","Elementary Occupations"
    ]
    total_row_name = {
        "A. Basic Salary & Wages": "TOTAL Basic Salary & Wages",
        "B. Arrears to Basic Salary & Wages": "TOTAL Arrears to Basic Salary & Wages",
        "C. Bonus": "TOTAL Bonus",
        "D. Others (overtime, COLA, allowance, etc.)": "TOTAL Others (overtime, COLA, allowance, etc.)",
        "E. Commissions Paid At Least Once a Month (RM)": "TOTAL Commissions Paid At Least Once a Month (RM)",
        sw_label: "TOTAL Salary & Wages",
    }
    for (ent, yr, q, sub), g in df.groupby(["entity_name","year","quarter","subsection"]):
        m1,m2,m3 = _mcols_for_row(q)
        if not m1:
            continue
        tlabel = total_row_name.get(sub)
        if not tlabel: 
            continue
        trow = g[g["worker_category"]==tlabel]
        if trow.empty:
            continue
        for col in [m1,m2,m3]:
            s = _num(g.loc[g["worker_category"].isin(cats), col]).sum()
            t = _num(trow[col]).sum()
            if abs(t - s) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q2A_Main",
                    "key": f"{sub} | {col}",
                    "check": "TOTAL row equals sum of 6 categories",
                    "expected": s, "actual": t, "severity": "FAIL"
                })
    return _finalize(ex)

def qc_q2a_jobfunc_q4(stg_jf: pd.DataFrame, stg_main: pd.DataFrame) -> pd.DataFrame:
    if stg_jf.empty or stg_main.empty:
        return _finalize([])
    ex: List[Dict] = []
    main_q4 = stg_main[stg_main["quarter"].astype(str).str.upper().isin(["Q4","QUARTER 4"])].copy()
    if "Dec" not in main_q4.columns:
        return _finalize([])

    jf_q4 = stg_jf[stg_jf["quarter"].astype(str).str.upper().isin(["Q4","QUARTER 4"])].copy()
    jf_sum = (jf_q4
        .groupby(["entity_name","year","quarter","subsection","worker_category"], as_index=False)["value"]
        .sum()
        .rename(columns={"value":"jf_total"})
    )
    key = ["entity_name","year","quarter","subsection","worker_category"]
    merged = jf_sum.merge(
        main_q4[key+["Dec"]].rename(columns={"Dec":"dec_main"}),
        on=key, how="left"
    )
    merged["jf_total"] = _num(merged["jf_total"])
    merged["dec_main"] = _num(merged["dec_main"])
    bad = merged[np.abs(merged["jf_total"] - merged["dec_main"]) > 0.5]
    for _, r in bad.iterrows():
        ex.append({
            "entity_name": r["entity_name"], "year": r["year"], "quarter": r["quarter"], "where": "Q2A_JobFunc_Q4",
            "key": f'{r["subsection"]} | {r["worker_category"]}',
            "check": "Sum(job_function) equals Dec in Q2A Main",
            "expected": float(r["dec_main"]), "actual": float(r["jf_total"]), "severity": "FAIL"
        })
    return _finalize(ex)

def qc_q2b(stg: pd.DataFrame) -> pd.DataFrame:
    if stg.empty:
        return _finalize([])
    df = stg.copy()
    ex: List[Dict] = []

    subs = {
        "A. Salary & Wages": "TOTAL Salary & Wages",
        "B. Commissions Paid At Least Once a Month (RM)": "TOTAL Commissions Paid At Least Once a Month (RM)"
    }
    # Single month column is either Jun or Dec depending on quarter; just use the only month present.
    mcols = _month_cols_present(df)
    if not mcols:
        return _finalize([])
    m = mcols[0]

    cats = [
        "Managers","Professional","Technicians & Associate Professionals",
        "Clerical Occupations","Operative Workers","Elementary Occupations"
    ]
    for (ent, yr, q, sub), g in df.groupby(["entity_name","year","quarter","subsection"]):
        tlabel = subs.get(sub)
        if not tlabel: 
            continue
        trow = g[g["worker_category"]==tlabel]
        if trow.empty:
            continue
        s = _num(g.loc[g["worker_category"].isin(cats), m]).sum()
        t = _num(trow[m]).sum()
        if abs(t - s) > 0.5:
            ex.append({
                "entity_name": ent, "year": yr, "quarter": q, "where": "Q2B",
                "key": sub, "check": f"TOTAL equals sum of 6 categories ({m})",
                "expected": s, "actual": t, "severity": "FAIL"
            })
    return _finalize(ex)

def qc_q3(stg: pd.DataFrame) -> pd.DataFrame:
    if stg.empty:
        return _finalize([])
    df = stg.copy()
    ex: List[Dict] = []
    cats = [
        "Managers","Professional","Technicians & Associate Professionals",
        "Clerical Occupations","Operative Workers","Elementary Occupations"
    ]
    # Month columns depend on quarter
    for (ent, yr, q), g in df.groupby(["entity_name","year","quarter"]):
        m1,m2,m3 = _mcols_for_row(q)
        if not m1: 
            continue
        total_row = g[g["worker_category"]=="TOTAL Hours Worked During the Month, Including Overtime"]
        if total_row.empty:
            continue
        for col in [m1,m2,m3]:
            s = _num(g.loc[g["worker_category"].isin(cats), col]).sum()
            t = _num(total_row[col]).sum()
            if abs(t - s) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q3",
                    "key": col, "check": "TOTAL equals sum of 5 categories",
                    "expected": s, "actual": t, "severity": "FAIL"
                })
    return _finalize(ex)

def qc_q4(stg: pd.DataFrame) -> pd.DataFrame:
    if stg.empty:
        return _finalize([])
    df = stg.copy()
    ex: List[Dict] = []
    cats = [
        "Managers","Professional","Technicians & Associate Professionals",
        "Clerical Occupations","Operative Workers","Elementary Occupations"
    ]
    total_map = {
        "A. Number of Job Vacancies as at End of the Month": "TOTAL Number of Job Vacancies as at end of the month",
        "B. Minimum Basic Starting Salaries of Job Vacancies during the month (RM)": "TOTAL Minimum Basic Salaries",
        "C(i). Number of Job Vacancies Due to New Jobs Created During the Month": "TOTAL Job Vacancies Due to New Jobs Created",
        "C(ii). Number Job Vacancies Due to Retirements, Resignations and All Reasons, other than New Jobs Created during the Month": "TOTAL Job Vacancies Due to Retirements, Resignations and All Reasons, other than Jobs Created",
    }
    for (ent, yr, q, sub), g in df.groupby(["entity_name","year","quarter","subquestion"]):
        m1,m2,m3 = _mcols_for_row(q)
        if not m1:
            continue
        tlabel = total_map.get(sub)
        if not tlabel:
            continue
        trow = g[g["worker_category"]==tlabel]
        if trow.empty:
            continue
        for col in [m1,m2,m3]:
            s = _num(g.loc[g["worker_category"].isin(cats), col]).sum()
            t = _num(trow[col]).sum()
            if abs(t - s) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q4",
                    "key": f"{sub} | {col}",
                    "check": "TOTAL equals sum of 6 categories",
                    "expected": s, "actual": t, "severity": "FAIL"
                })
    return _finalize(ex)

def qc_q5(stg: pd.DataFrame) -> pd.DataFrame:
    if stg.empty:
        return _finalize([])
    df = stg.copy()
    ex: List[Dict] = []

    # Blocks & totals (names as in staging)
    blocks = {
        "New Hires and Recalls": "TOTAL New Hires and Recalls",
        "Separations = A + B + C": "TOTAL Separations",
        "A. Quits and Resignations (except retirements)": "TOTAL Quits and Resignations (except retirements)",
        "B. Total Layoffs and Discharges": "TOTAL Layoffs and Discharges",
        "B. (i) Layoffs and Discharges: of which; VSS/ MSS": "TOTAL Layoffs and Discharges, of which; VSS/ MSS",
        "C. Other Separations": "TOTAL Other Separations",
    }
    cats = [
        "Managers","Professional","Technicians & Associate Professionals",
        "Clerical Occupations","Operative Workers","Elementary Occupations"
    ]

    # 1) Totals equal sum of categories within each block
    for (ent, yr, q, sub), g in df.groupby(["entity_name","year","quarter","subquestion"]):
        m1,m2,m3 = _mcols_for_row(q)
        if not m1:
            continue
        tlabel = blocks.get(sub)
        if not tlabel:
            continue
        trow = g[g["worker_category"]==tlabel]
        if trow.empty:
            continue
        for col in [m1,m2,m3]:
            s = _num(g.loc[g["worker_category"].isin(cats), col]).sum()
            t = _num(trow[col]).sum()
            if abs(t - s) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q5",
                    "key": f"{sub} | {col}",
                    "check": "TOTAL equals sum of 6 categories",
                    "expected": s, "actual": t, "severity": "FAIL"
                })

    # 2) Separations identity: Separations = A + B + C (month-wise) per worker category
    # Build a pivot for fast lookups
    piv = (df.pivot_table(
        index=["entity_name","year","quarter","worker_category"],
        columns="subquestion",
        values=_month_cols_present(df),
        aggfunc="sum",
        fill_value=0.0,
    ))
    # Flatten columns: (month, subquestion) → separate frames by month
    months_all = set(c for c in _month_cols_present(df) if c != "M")
    for ent, yr, q, wc in piv.index:
        m1,m2,m3 = _mcols_for_row(q)
        for col in [m1,m2,m3]:
            if col is None: 
                continue
            try:
                sep = piv.loc[(ent,yr,q,wc)][col]["Separations = A + B + C"]
                a   = piv.loc[(ent,yr,q,wc)][col]["A. Quits and Resignations (except retirements)"]
                b   = piv.loc[(ent,yr,q,wc)][col]["B. Total Layoffs and Discharges"]
                c   = piv.loc[(ent,yr,q,wc)][col]["C. Other Separations"]
            except KeyError:
                continue
            if abs(sep - (a+b+c)) > 0.5:
                ex.append({
                    "entity_name": ent, "year": yr, "quarter": q, "where": "Q5",
                    "key": f"{wc} | {col}",
                    "check": "Separations = A + B + C",
                    "expected": float(a+b+c), "actual": float(sep), "severity": "FAIL"
                })
    return _finalize(ex)

# Main -----------------------------------------------------------------------

def main() -> int:
    ap = argparse.ArgumentParser(description="Build QC template (exceptions) for Q1–Q5 from staging_all.xlsx")
    ap.add_argument("--stage", required=True, help="Path to staging_all.xlsx")
    ap.add_argument("--out", required=True, help="Output QC workbook (.xlsx)")
    args = ap.parse_args()

    stage_path = Path(args.stage)
    if not stage_path.exists():
        print(f"[ERROR] staging file not found: {stage_path}")
        return 2

    with pd.ExcelFile(stage_path) as xf:
        def rd(name: str) -> pd.DataFrame:
            return xf.parse(name) if name in xf.sheet_names else pd.DataFrame()

        q1a_main  = rd("Q1A_Main")
        q1a_jf_q4 = rd("Q1A_JobFunc_Q4")
        q1b       = rd("Q1B")

        q2a_main  = rd("Q2A_Main")
        q2a_jf_q4 = rd("Q2A_JobFunc_Q4")
        q2b       = rd("Q2B")

        q3        = rd("Q3")
        q4        = rd("Q4")
        q5        = rd("Q5")

    # Build QC sheets
    qc_tabs: Dict[str, pd.DataFrame] = {
        "Q1A_Main_QC":       qc_q1a_main(q1a_main),
        "Q1A_JobFunc_Q4_QC": qc_q1a_jobfunc_q4(q1a_jf_q4, q1a_main),
        "Q1B_QC":            qc_q1b(q1b),

        "Q2A_Main_QC":       qc_q2a_main(q2a_main),
        "Q2A_JobFunc_Q4_QC": qc_q2a_jobfunc_q4(q2a_jf_q4, q2a_main),
        "Q2B_QC":            qc_q2b(q2b),

        "Q3_QC":             qc_q3(q3),
        "Q4_QC":             qc_q4(q4),
        "Q5_QC":             qc_q5(q5),
    }

    # Summary sheet (all exceptions stacked)
    all_ex = []
    for name, df in qc_tabs.items():
        if not df.empty:
            tmp = df.copy()
            tmp.insert(0, "sheet", name)
            all_ex.append(tmp)
    summary = (pd.concat(all_ex, ignore_index=True)
               if all_ex else pd.DataFrame(columns=["sheet","entity_name","year","quarter","where","key","check","expected","actual","severity"]))

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with pd.ExcelWriter(out_path, engine="openpyxl") as xw:
        summary.to_excel(xw, index=False, sheet_name="Summary")
        for name, df in qc_tabs.items():
            df.to_excel(xw, index=False, sheet_name=name)

    print(f"[DONE] QC workbook → {out_path}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
