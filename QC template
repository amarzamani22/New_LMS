from __future__ import annotations
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import pandas as pd

# ----------------- CONSTANTS -----------------
MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
QMAP   = {"Q1":["Jan","Feb","Mar"], "Q2":["Apr","May","Jun"], "Q3":["Jul","Aug","Sep"], "Q4":["Oct","Nov","Dec"]}

# Your rollup mapping & order (exactly as provided)
ROLLUPS: Dict[str, List[str]] = {
    "All Financial Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks", "DFI",
        "Insurers", "Takaful Operators", "Foreign Banks",
        "International Islamic Banks", "Digital Banks"
    ],
    "Banking Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks",
        "Digital Banks", "International Islamic Banks", "Foreign Banks"
    ],
    "Commercial Banks": ["Commercial Banks", "Foreign Banks"],
    "Investment Banks": ["Investment Banks"],
    "Islamic Banks": ["Islamic Banks"],
    "Digital Banks": ["Digital Banks"],
    "International Islamic Banks": ["International Islamic Banks"],
    "Foreign Banks": ["Foreign Banks"],
    "DFI": ["DFI"],
    "Insurers": ["Insurers"],
    "Takaful Operators": ["Takaful Operators"],
}

ROLLUP_ORDER = [
    "All Financial Institutions",
    "Banking Institutions",
    "Commercial Banks",
    "Investment Banks",
    "Islamic Banks",
    "Foreign Banks",
    "Digital Banks",
    "International Islamic Banks",
    "DFI",
    "Insurers",
    "Takaful Operators",
]

# ----------------- UTILITIES -----------------
def load_xlsx(path: Path) -> Dict[str, pd.DataFrame]:
    xl = pd.ExcelFile(path, engine="openpyxl")
    out: Dict[str, pd.DataFrame] = {}
    for nm in xl.sheet_names:
        try:
            out[nm] = xl.parse(nm)
        except Exception:
            pass
    return out

def normalize_quarter_col(df: pd.DataFrame) -> pd.DataFrame:
    if "quarter" not in df.columns: return df
    mapping = {
        "1":"Q1","2":"Q2","3":"Q3","4":"Q4",
        "Quarter 1":"Q1","Quarter 2":"Q2","Quarter 3":"Q3","Quarter 4":"Q4",
        "Q1":"Q1","Q2":"Q2","Q3":"Q3","Q4":"Q4"
    }
    c = df["quarter"].astype(str).map(mapping).fillna(df["quarter"])
    df = df.copy()
    df["quarter"] = c
    return df

def detect_current_quarter(sheets: Dict[str, pd.DataFrame]) -> str:
    order = {"Q1":1,"Q2":2,"Q3":3,"Q4":4}
    best = "Q1"; bestv = 1
    for nm in ["Q5","Q4","Q3","Q2A_Main","Q1A_Main","Q2B","Q1B"]:
        if nm in sheets and not sheets[nm].empty and "quarter" in sheets[nm].columns:
            q = normalize_quarter_col(sheets[nm])["quarter"].astype(str)
            qv = q.map(order).max(skipna=True)
            if pd.notna(qv) and int(qv) > bestv:
                bestv = int(qv)
                best   = [k for k,v in order.items() if v==bestv][0]
    return best

def months_up_to(q: str) -> List[str]:
    out: List[str] = []
    for oq in ["Q1","Q2","Q3","Q4"]:
        out += QMAP[oq]
        if oq == q: break
    return out

def ensure_months(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()
    for m in MONTHS:
        if m not in out.columns:
            out[m] = 0
    return out

def quarter_sums(df: pd.DataFrame) -> pd.DataFrame:
    out = ensure_months(df.copy())
    out["Q1"] = out[QMAP["Q1"]].sum(axis=1)
    out["Q2"] = out[QMAP["Q2"]].sum(axis=1)
    out["Q3"] = out[QMAP["Q3"]].sum(axis=1)
    out["Q4"] = out[QMAP["Q4"]].sum(axis=1)
    return out

def add_mom(df: pd.DataFrame, months: List[str]) -> pd.DataFrame:
    out = df.copy()
    for i, m in enumerate(months):
        if i == 0: continue
        p = months[i-1]
        out[f"Diff_{m}"] = out[m] - out[p]
        denom = out[p].replace(0, pd.NA)
        out[f"MoM_{m}"] = (out[m] - out[p]) / denom
    return out

def add_qoq(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()
    qs = ["Q1","Q2","Q3","Q4"]
    for i, q in enumerate(qs):
        if i == 0: continue
        pq = qs[i-1]
        out[f"Diff_{q}"]    = out[q] - out[pq]
        out[f"PctDiff_{q}"] = (out[q] - out[pq]) / out[pq].replace(0, pd.NA)
    return out

def add_yoy_quarters(curr_q: pd.DataFrame, prev_q: Optional[pd.DataFrame], join_dims: List[str]) -> pd.DataFrame:
    if prev_q is None or prev_q.empty:
        return curr_q
    # Join on non-time dims
    join_keys = [c for c in join_dims if c in curr_q.columns]
    left  = curr_q.copy()
    right = prev_q.copy()
    cols_keep = ["Q1","Q2","Q3","Q4"]
    right = right[join_keys + cols_keep].copy()
    right = right.rename(columns={q:f"Prior_{q}" for q in cols_keep})
    merged = left.merge(right, on=join_keys, how="left")
    for q in ["Q1","Q2","Q3","Q4"]:
        pr = f"Prior_{q}"
        denom = merged[pr].replace(0, pd.NA)
        merged[f"YoY_{q}"] = (merged[q] - merged[pr]) / denom
    return merged

def read_entity_map(path: Path) -> pd.DataFrame:
    df = pd.read_csv(path)
    need = {"entity_name","fi_type"}
    missing = need - set(df.columns)
    if missing:
        raise ValueError(f"entity map missing columns: {missing}")
    return df[["entity_name","fi_type"]].copy()

def attach_fi_type(df: pd.DataFrame, emap: pd.DataFrame) -> pd.DataFrame:
    if "entity_name" not in df.columns:
        raise ValueError("staging sheet missing 'entity_name'")
    return df.merge(emap, on="entity_name", how="left")

def base_group_sum(df: pd.DataFrame, value_cols: List[str], dims: List[str]) -> pd.DataFrame:
    agg = {c:"sum" for c in value_cols}
    g = df.groupby(dims, dropna=False).agg(agg).reset_index()
    return g

def build_rollup_blocks(df_with_type: pd.DataFrame, value_cols: List[str], facet_dims: List[str]) -> pd.DataFrame:
    """
    Create stacked rows:
      - All defined rollups in ROLLUP_ORDER
      - Institution rows (entity level)
    Columns produced: fi_type, entity_group, institution, [facets], year, quarter, [values...]
    """
    base_dims = ["year","quarter"]
    dims_inst = ["fi_type","entity_group","institution"] + facet_dims + base_dims

    # ensure required cols exist
    for c in ["fi_type","entity_name","year","quarter"]:
        if c not in df_with_type.columns:
            df_with_type[c] = ""

    # Institution rows (entity_group = fi_type, institution = entity_name)
    inst = df_with_type.copy()
    inst["entity_group"] = inst["fi_type"]
    inst["institution"]  = inst["entity_name"]
    inst_block = base_group_sum(inst, value_cols, dims_inst)

    # Rollup rows (entity_group = rollup name, institution = "")
    roll_frames = []
    for rname in ROLLUP_ORDER:
        members = ROLLUPS.get(rname, [])
        if not members:  # e.g., the simple leaf rollups already covered as entity_group=fi_type in inst
            continue
        sub = df_with_type[df_with_type["fi_type"].isin(members)].copy()
        if sub.empty:
            continue
        sub["entity_group"] = rname
        sub["institution"]  = ""
        dims_roll = ["entity_group","institution"] + facet_dims + base_dims
        roll_frames.append(base_group_sum(sub, value_cols, ["fi_type"] + dims_roll).drop(columns=["fi_type"]))

    all_rolls = pd.concat(roll_frames, ignore_index=True) if roll_frames else pd.DataFrame(columns=dims_inst+value_cols)
    out = pd.concat([all_rolls, inst_block], ignore_index=True)

    # Order columns
    lead = ["fi_type","entity_group","institution"] + facet_dims + base_dims
    cols = lead + value_cols
    return out[cols]

def sort_rows(df: pd.DataFrame) -> pd.DataFrame:
    # entity_group ordered by ROLLUP_ORDER, then institution, then others
    order = pd.CategoricalDtype(categories=ROLLUP_ORDER + sorted([x for x in df.get("fi_type", pd.Series([])).unique() if pd.notna(x)]), ordered=True)
    dfo = df.copy()
    if "entity_group" in dfo.columns:
        dfo["entity_group"] = dfo["entity_group"].astype(order)
    return dfo.sort_values(by=["entity_group","institution"] + [c for c in ["subquestion","worker_category","job_function"] if c in dfo.columns], kind="stable")

def make_monthly_sheet(stage_df: pd.DataFrame, emap: pd.DataFrame, current_q: str, prior_df: Optional[pd.DataFrame]) -> pd.DataFrame:
    # Attach fi_type, normalize quarter
    d0 = attach_fi_type(normalize_quarter_col(stage_df), emap)
    # Value columns present
    vcols = [c for c in MONTHS if c in d0.columns]
    d0 = ensure_months(d0)
    vcols = MONTHS  # after ensure

    # Facets
    facet_dims = [c for c in ["question","subquestion","worker_category","job_function"] if c in d0.columns]

    # Build rollups + institution stack
    stacked = build_rollup_blocks(d0, vcols, facet_dims)
    stacked = quarter_sums(stacked)

    # In-scope months
    months = months_up_to(current_q)
    keep_metrics = months + ["Q1","Q2","Q3","Q4"]
    out = stacked[["fi_type","entity_group","institution", *facet_dims, "year","quarter", *keep_metrics]].copy()

    # Add MoM & QoQ (values only)
    out = add_mom(out, months)
    out = add_qoq(out)

    # YoY (if prior provided)
    if prior_df is not None and not prior_df.empty:
        p0 = attach_fi_type(normalize_quarter_col(prior_df), emap)
        p0 = ensure_months(p0)
        pstack = build_rollup_blocks(p0, MONTHS, facet_dims)
        pstack = quarter_sums(pstack)
        join_dims = ["fi_type","entity_group","institution", *facet_dims]
        out = add_yoy_quarters(out, pstack, join_dims)

    # Sort
    out = sort_rows(out)
    return out

def make_single_month_sheet(stage_df: pd.DataFrame, emap: pd.DataFrame, months_avail: List[str], prior_df: Optional[pd.DataFrame]) -> pd.DataFrame:
    d0 = attach_fi_type(normalize_quarter_col(stage_df), emap)
    facet_dims = [c for c in ["question","subquestion","worker_category"] if c in d0.columns]
    vcols = [m for m in months_avail if m in d0.columns]
    # Build blocks
    stacked = build_rollup_blocks(d0, vcols, facet_dims)
    out = stacked[["fi_type","entity_group","institution", *facet_dims, "year","quarter", *vcols]].copy()

    # YoY for those months if prior provided (compare same month)
    if prior_df is not None and not prior_df.empty:
        p0 = attach_fi_type(normalize_quarter_col(prior_df), emap)
        pstack = build_rollup_blocks(p0, vcols, facet_dims)
        join_dims = ["fi_type","entity_group","institution", *facet_dims]
        left  = out.copy()
        right = pstack[join_dims + vcols].copy().rename(columns={m:f"Prior_{m}" for m in vcols})
        out   = left.merge(right, on=join_dims, how="left")
        for m in vcols:
            denom = out[f"Prior_{m}"].replace(0, pd.NA)
            out[f"YoY_{m}"] = (out[m] - out[f"Prior_{m}"]) / denom

    out = sort_rows(out)
    return out

def make_jobfunc_q4_sheet(stage_df: pd.DataFrame, emap: pd.DataFrame, prior_df: Optional[pd.DataFrame]) -> pd.DataFrame:
    d0 = attach_fi_type(normalize_quarter_col(stage_df), emap).copy()
    # Treat 'value' as Dec (Q4 context)
    if "value" not in d0.columns:
        d0["value"] = 0
    d0["Dec"] = d0["value"]
    for m in [m for m in MONTHS if m != "Dec"]:
        if m not in d0.columns: d0[m] = 0
    d0 = d0.drop(columns=[c for c in d0.columns if c not in ["entity_name","fi_type","year","quarter","subquestion","worker_category","job_function", *MONTHS]])

    facet_dims = [c for c in ["subquestion","worker_category","job_function"] if c in d0.columns]
    stacked = build_rollup_blocks(d0, MONTHS, facet_dims)
    stacked = quarter_sums(stacked)
    out = stacked[["fi_type","entity_group","institution", *facet_dims, "year","quarter", *MONTHS, "Q1","Q2","Q3","Q4"]].copy()

    # QoQ/YoY if prior provided
    out = add_qoq(out)
    if prior_df is not None and not prior_df.empty:
        p0 = attach_fi_type(normalize_quarter_col(prior_df), emap).copy()
        if "value" not in p0.columns: p0["value"] = 0
        p0["Dec"] = p0["value"]
        for m in [m for m in MONTHS if m != "Dec"]:
            if m not in p0.columns: p0[m] = 0
        p0 = p0.drop(columns=[c for c in p0.columns if c not in ["entity_name","fi_type","year","quarter","subquestion","worker_category","job_function", *MONTHS]])
        pstack = build_rollup_blocks(p0, MONTHS, facet_dims)
        pstack = quarter_sums(pstack)
        join_dims = ["fi_type","entity_group","institution", *facet_dims]
        out = add_yoy_quarters(out, pstack, join_dims)

    return sort_rows(out)

# ----------------- MAIN -----------------
def main() -> int:
    ap = argparse.ArgumentParser(description="Fast, values-only QC workbook for Q1–Q5 with rollups.")
    ap.add_argument("--stage", required=True, help="Path to current staging_all.xlsx")
    ap.add_argument("--entity-map", required=True, help="CSV with columns: entity_name,fi_type")
    ap.add_argument("--out", required=True, help="Output workbook .xlsx")
    ap.add_argument("--prior-stage", help="Optional prior-year staging_all.xlsx for YoY")
    args = ap.parse_args()

    stage_path = Path(args.stage)
    if not stage_path.exists():
        raise SystemExit(f"[ERROR] Stage not found: {stage_path}")

    sheets = load_xlsx(stage_path)
    if not sheets:
        raise SystemExit("[ERROR] Stage file has no readable sheets.")

    emap = read_entity_map(Path(args.entity_map))

    prior_sheets: Dict[str,pd.DataFrame] = {}
    if args.prior_stage:
        ppath = Path(args.prior_stage)
        if not ppath.exists():
            print(f"[WARN] Prior stage not found: {ppath} (YoY will be skipped)")
        else:
            prior_sheets = load_xlsx(ppath)

    current_q = detect_current_quarter(sheets)
    months_scope = months_up_to(current_q)

    # Build each tab if present
    outputs: List[Tuple[str,pd.DataFrame]] = []

    # Q1A main
    if "Q1A_Main" in sheets and not sheets["Q1A_Main"].empty:
        prev = prior_sheets.get("Q1A_Main")
        outputs.append(("QC_Q1A", make_monthly_sheet(sheets["Q1A_Main"], emap, current_q, prev)))

    # Q1B (Jun/Dec may exist one or both)
    if "Q1B" in sheets and not sheets["Q1B"].empty:
        months_avail = [m for m in ["Jun","Dec"] if m in sheets["Q1B"].columns]
        if months_avail:
            prev = prior_sheets.get("Q1B")
            outputs.append(("QC_Q1B", make_single_month_sheet(sheets["Q1B"], emap, months_avail, prev)))

    # Q1A Job Function (Q4 only tab)
    if "Q1A_JobFunc_Q4" in sheets and not sheets["Q1A_JobFunc_Q4"].empty:
        prev = prior_sheets.get("Q1A_JobFunc_Q4")
        outputs.append(("QC_Q1A_JF_Q4", make_jobfunc_q4_sheet(sheets["Q1A_JobFunc_Q4"], emap, prev)))

    # Q2A main
    if "Q2A_Main" in sheets and not sheets["Q2A_Main"].empty:
        # normalize subsection -> subquestion if exists
        df = sheets["Q2A_Main"].rename(columns={"subsection":"subquestion"})
        prev = prior_sheets.get("Q2A_Main")
        outputs.append(("QC_Q2A", make_monthly_sheet(df, emap, current_q, prev)))

    # Q2B
    if "Q2B" in sheets and not sheets["Q2B"].empty:
        df = sheets["Q2B"].rename(columns={"subsection":"subquestion"})
        months_avail = [m for m in ["Jun","Dec"] if m in df.columns]
        if months_avail:
            prev = prior_sheets.get("Q2B")
            outputs.append(("QC_Q2B", make_single_month_sheet(df, emap, months_avail, prev)))

    # Q2A Job Function (Q4 only)
    if "Q2A_JobFunc_Q4" in sheets and not sheets["Q2A_JobFunc_Q4"].empty:
        df = sheets["Q2A_JobFunc_Q4"].rename(columns={"subsection":"subquestion"})
        prev = prior_sheets.get("Q2A_JobFunc_Q4")
        outputs.append(("QC_Q2A_JF_Q4", make_jobfunc_q4_sheet(df, emap, prev)))

    # Q3
    if "Q3" in sheets and not sheets["Q3"].empty:
        prev = prior_sheets.get("Q3")
        outputs.append(("QC_Q3", make_monthly_sheet(sheets["Q3"], emap, current_q, prev)))

    # Q4
    if "Q4" in sheets and not sheets["Q4"].empty:
        prev = prior_sheets.get("Q4")
        outputs.append(("QC_Q4", make_monthly_sheet(sheets["Q4"], emap, current_q, prev)))

    # Q5
    if "Q5" in sheets and not sheets["Q5"].empty:
        prev = prior_sheets.get("Q5")
        outputs.append(("QC_Q5", make_monthly_sheet(sheets["Q5"], emap, current_q, prev)))

    if not outputs:
        raise SystemExit("[ERROR] No usable sheets in stage file.")

    # Write workbook (values only). Freeze panes & autofilter kept minimal.
    with pd.ExcelWriter(args.out, engine="openpyxl") as w:
        for name, df in outputs:
            df.to_excel(w, index=False, sheet_name=name)

        # Light post-processing: freeze header + autofilter
        wb = w.book
        for name in [n for n,_ in outputs]:
            ws = wb[name]
            ws.freeze_panes = "A2"  # freeze header row
            max_col = ws.max_column
            max_row = ws.max_row
            ws.auto_filter.ref = f"A1:{ws.cell(row=max_row, column=max_col).coordinate}"

    print(f"[DONE] Wrote QC workbook → {args.out}  (Quarter in scope: {current_q})")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
