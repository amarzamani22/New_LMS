# qc_fast_embedded.py
from __future__ import annotations
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import pandas as pd

# ----------------- CONSTANTS -----------------
MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
QMAP   = {"Q1":["Jan","Feb","Mar"], "Q2":["Apr","May","Jun"], "Q3":["Jul","Aug","Sep"], "Q4":["Oct","Nov","Dec"]}

# ----------------- ROLLUPS (as provided) -----------------
ROLLUPS: Dict[str, List[str]] = {
    "All Financial Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks", "DFI",
        "Insurers", "Takaful Operators", "Foreign Banks",
        "International Islamic Banks", "Digital Banks"
    ],
    "Banking Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks",
        "Digital Banks", "International Islamic Banks", "Foreign Banks"
    ],
    "Commercial Banks": ["Commercial Banks", "Foreign Banks"],
    "Investment Banks": ["Investment Banks"],
    "Islamic Banks": ["Islamic Banks"],
    "Digital Banks": ["Digital Banks"],
    "International Islamic Banks": ["International Islamic Banks"],
    "Foreign Banks": ["Foreign Banks"],
    "DFI": ["DFI"],
    "Insurers": ["Insurers"],
    "Takaful Operators": ["Takaful Operators"],
}

ROLLUP_ORDER = [
    "All Financial Institutions",
    "Banking Institutions",
    "Commercial Banks",
    "Investment Banks",
    "Islamic Banks",
    "Foreign Banks",
    "Digital Banks",
    "International Islamic Banks",
    "DFI",
    "Insurers",
    "Takaful Operators",
]

# ----------------- FULL EMBEDDED MAPPING -----------------
ENTITY_TO_TYPE: Dict[str, str] = {
    # Banks / DFIs / Digital / Foreign / IIB
    "AFFIN BANK BERHAD": "Commercial Banks",
    "AFFIN HWANG INVESTMENT BANK BERHAD": "Investment Banks",
    "AFFIN ISLAMIC BANK BERHAD": "Islamic Banks",
    "AGROBANK (BANK PERTANIAN MALAYSIA BERHAD)": "DFI",
    "AL RAJHI BANKING & INVESTMENT CORPORATION (MALAYSIA) BHD": "Islamic Banks",
    "ALKHAIR INTERNATIONAL ISLAMIC BANK BHD": "International Islamic Banks",
    "ALLIANCE BANK MALAYSIA BERHAD": "Commercial Banks",
    "ALLIANCE INVESTMENT BANK BERHAD": "Investment Banks",
    "ALLIANCE ISLAMIC BANK BERHAD": "Islamic Banks",
    "AMBANK (M) BERHAD": "Commercial Banks",
    "AMBANK ISLAMIC BERHAD": "Islamic Banks",
    "AMINVESTMENT BANK BERHAD": "Investment Banks",
    "MBSB BANK BERHAD": "Islamic Banks",
    "BANGKOK BANK BERHAD": "Foreign Banks",
    "BANK ISLAM MALAYSIA BERHAD": "Islamic Banks",
    "BANK KERJASAMA RAKYAT MALAYSIA BERHAD": "Islamic Banks",
    "BANK MUAMALAT MALAYSIA BERHAD": "Islamic Banks",
    "BANK OF AMERICA MALAYSIA BERHAD": "Foreign Banks",
    "BANK OF CHINA (MALAYSIA) BERHAD": "Foreign Banks",
    "BANK OF TOKYO-MITSUBISHI UFJ (MALAYSIA) BERHAD": "Foreign Banks",
    "BANK PEMBANGUNAN MALAYSIA BERHAD": "DFI",
    "BANK SIMPANAN NASIONAL": "DFI",
    "BNP PARIBAS MALAYSIA BERHAD": "Foreign Banks",
    "CHINA CONSTRUCTION BANK MALAYSIA BERHAD": "Foreign Banks",
    "CIMB BANK BERHAD": "Commercial Banks",
    "CIMB INVESTMENT BANK BERHAD": "Investment Banks",
    "CIMB ISLAMIC BANK BERHAD": "Islamic Banks",
    "CITIBANK BERHAD": "Foreign Banks",
    "DEUTSCHE BANK (MALAYSIA) BERHAD": "Foreign Banks",
    "DEUTSCHE BANK AG, INTERNATIONAL ISLAMIC BANKING, MALAYSIA BRANCH": "International Islamic Banks",
    "EXPORT-IMPORT BANK OF MALAYSIA BERHAD": "DFI",
    "HONG LEONG BANK BERHAD": "Commercial Banks",
    "HONG LEONG INVESTMENT BANK BERHAD": "Investment Banks",
    "HONG LEONG ISLAMIC BANK BERHAD": "Islamic Banks",
    "HSBC AMANAH MALAYSIA BERHAD": "Islamic Banks",
    "HSBC BANK MALAYSIA BERHAD": "Commercial Banks",
    "IBDAR BANK BSC": "International Islamic Banks",
    "INDIA INTERNATIONAL BANK (MALAYSIA) BERHAD": "Foreign Banks",
    "INDUSTRIAL AND COMMERCIAL BANK OF CHINA (MALAYSIA) BERHAD": "Foreign Banks",
    "J.P MORGAN CHASE BANK BERHAD": "Foreign Banks",
    "KAF INVESTMENT BANK BERHAD": "Investment Banks",
    "KENANGA INVESTMENT BANK BERHAD": "Investment Banks",
    "KUWAIT FINANCE HOUSE (MALAYSIA) BERHAD": "Islamic Banks",
    "MALAYAN BANKING BERHAD": "Commercial Banks",
    "MAYBANK INVESTMENT BANK BERHAD": "Investment Banks",
    "MAYBANK ISLAMIC BERHAD": "Islamic Banks",
    "MIDF AMANAH INVESTMENT BANK BERHAD": "Investment Banks",
    "MIZUHO CORPORATE BANK (MALAYSIA) BERHAD": "Foreign Banks",
    "NATIONAL BANK OF ABU DHABI MALAYSIA BERHAD": "Foreign Banks",
    "OCBC AL-AMIN BANK BERHAD": "Islamic Banks",
    "OCBC BANK (MALAYSIA) BERHAD": "Commercial Banks",
    "PT. BANK SYARIAH MUALAMAT INDONESIA, TBK": "International Islamic Banks",
    "PUBLIC BANK BERHAD": "Commercial Banks",
    "PUBLIC INVESTMENT BANK BERHAD": "Investment Banks",
    "PUBLIC ISLAMIC BANK BERHAD": "Islamic Banks",
    "RHB BANK BERHAD": "Commercial Banks",
    "RHB INVESTMENT BANK BERHAD": "Investment Banks",
    "RHB ISLAMIC BANK BERHAD": "Islamic Banks",
    "SMALL MEDIUM ENTERPRISE DEVELOPMENT BANK MALAYSIA BERHAD": "DFI",
    "STANDARD CHARTERED BANK MALAYSIA BERHAD": "Commercial Banks",
    "STANDARD CHARTERED SAADIQ BERHAD": "Islamic Banks",
    "SUMITOMO MITSUI BANKING CORPORATION MALAYSIA BERHAD": "Foreign Banks",
    "THE BANK OF NOVA SCOTIA BERHAD": "Foreign Banks",
    "THE ROYAL BANK OF SCOTLAND BERHAD": "Foreign Banks",
    "UNITED OVERSEAS BANK (MALAYSIA) BHD.": "Commercial Banks",
    "BOOST BANK BERHAD": "Digital Banks",
    "AEON BANK (M) BERHAD": "Digital Banks",
    "KAF DIGITAL BERHAD": "Digital Banks",
    "YTL DIGITAL BANK BERHAD": "Digital Banks",
    "GX BANK BERHAD": "Digital Banks",

    # Insurance & Takaful (inc. reinsurers)
    "ACR RETAKAFUL BERHAD": "Takaful Operators",
    "AIA BHD.": "Insurers",
    "AIA GENERAL BERHAD": "Insurers",
    "AIA PUBLIC TAKAFUL BHD.": "Takaful Operators",
    "AIG MALAYSIA INSURANCE BERHAD": "Insurers",
    "ALLIANZ GENERAL INSURANCE COMPANY (MALAYSIA) BERHAD": "Insurers",
    "ALLIANZ LIFE INSURANCE MALAYSIA BERHAD": "Insurers",
    "AMBRA VERSICHERUNG AG": "Insurers",
    "AMMETLIFE INSURANCE BERHAD": "Insurers",
    "AMMETLIFE TAKAFUL BERHAD": "Takaful Operators",
    "ASIA CAPITAL REINSURANCE MALAYSIA SDN. BHD.": "Insurers",
    "BERJAYA SOMPO INSURANCE BERHAD": "Insurers",
    "CHUBB INSURANCE MALAYSIA BERHAD": "Insurers",
    "DANAJAMIN NASIONAL BERHAD": "DFI",
    "ETIQA GENERAL INSURANCE BERHAD": "Insurers",
    "ETIQA LIFE INSURANCE BERHAD": "Insurers",
    "ETIQA FAMILY TAKAFUL BERHAD": "Takaful Operators",
    "ETIQA GENERAL TAKAFUL BERHAD": "Takaful Operators",
    "FWD INSURANCE BERHAD": "Insurers",
    "FWD TAKAFUL BERHAD": "Takaful Operators",
    "GENERALI INSURANCE MALAYSIA BERHAD": "Insurers",
    "GENERALI LIFE INSURANCE MALAYSIA BERHAD": "Insurers",
    "GREAT EASTERN GENERAL INSURANCE (MALAYSIA) BERHAD": "Insurers",
    "GREAT EASTERN LIFE ASSURANCE (MALAYSIA) BERHAD": "Insurers",
    "GREAT EASTERN TAKAFUL BERHAD": "Takaful Operators",
    "HANNOVER RUECKVERSICHERUNG AG, MALAYSIAN BRANCH": "Insurers",
    "HONG LEONG ASSURANCE BERHAD": "Insurers",
    "HONG LEONG MSIG TAKAFUL BERHAD": "Takaful Operators",
    "LIBERTY GENERAL INSURANCE BERHAD": "Insurers",
    "LONPAC INSURANCE BHD.": "Insurers",
    "MALAYSIAN LIFE REINSURANCE GROUP BERHAD": "Insurers",
    "MALAYSIAN REINSURANCE BERHAD": "Insurers",
    "MANULIFE INSURANCE BERHAD": "Insurers",
    "MCIS INSURANCE BERHAD": "Insurers",
    "MSIG INSURANCE (MALAYSIA) BHD": "Insurers",
    "MUNCHENER RUCKVERSICHERUNGS-GESELLSCHAFT (Munich Re Retakaful)": "Takaful Operators",
    "PACIFIC & ORIENT INSURANCE CO. BERHAD": "Insurers",
    "PROGRESSIVE INSURANCE BHD.": "Insurers",
    "PRUDENTIAL ASSURANCE MALAYSIA BERHAD": "Insurers",
    "PRUDENTIAL BSN TAKAFUL BERHAD": "Takaful Operators",
    "QBE INSURANCE (MALAYSIA) BERHAD": "Insurers",
    "RHB INSURANCE BERHAD": "Insurers",
    "SUN LIFE MALAYSIA ASSURANCE BERHAD": "Insurers",
    "SUN LIFE MALAYSIA TAKAFUL BERHAD": "Takaful Operators",
    "SWISS RE ASIA PTE LTD": "Insurers",
    "SWISS REINSURANCE COMPANY LTD (SWISS RE RETAKAFUL)": "Takaful Operators",
    "SYARIKAT TAKAFUL MALAYSIA AM BERHAD": "Takaful Operators",
    "SYARIKAT TAKAFUL MALAYSIA KELUARGA BERHAD": "Takaful Operators",
    "TAKAFUL IKHLAS FAMILY BERHAD": "Takaful Operators",
    "TAKAFUL IKHLAS GENERAL BERHAD": "Takaful Operators",
    "THE PACIFIC INSURANCE BERHAD": "Insurers",
    "THE TOA REINSURANCE COMPANY LTD.": "Insurers",
    "TOKIO MARINE INSURANS (MALAYSIA) BERHAD": "Insurers",
    "TOKIO MARINE LIFE INSURANCE MALAYSIA BHD": "Insurers",
    "TUNE INSURANCE MALAYSIA BERHAD": "Insurers",
    "ZURICH GENERAL INSURANCE MALAYSIA BERHAD": "Insurers",
    "ZURICH LIFE INSURANCE MALAYSIA BERHAD": "Insurers",
    "ZURICH GENERAL TAKAFUL MALAYSIA BERHAD": "Takaful Operators",
    "ZURICH TAKAFUL MALAYSIA BERHAD": "Takaful Operators",
}

# ----------------- HELPERS -----------------
def load_xlsx(path: Path) -> Dict[str, pd.DataFrame]:
    xl = pd.ExcelFile(path, engine="openpyxl")
    out: Dict[str, pd.DataFrame] = {}
    for nm in xl.sheet_names:
        try:
            out[nm] = xl.parse(nm)
        except Exception:
            pass
    return out

def normalize_quarter_col(df: pd.DataFrame) -> pd.DataFrame:
    if "quarter" not in df.columns: return df
    mapping = {
        "1":"Q1","2":"Q2","3":"Q3","4":"Q4",
        "Quarter 1":"Q1","Quarter 2":"Q2","Quarter 3":"Q3","Quarter 4":"Q4",
        "Q1":"Q1","Q2":"Q2","Q3":"Q3","Q4":"Q4"
    }
    c = df["quarter"].astype(str).map(mapping).fillna(df["quarter"])
    df = df.copy()
    df["quarter"] = c
    return df

def detect_current_quarter(sheets: Dict[str, pd.DataFrame]) -> str:
    order = {"Q1":1,"Q2":2,"Q3":3,"Q4":4}
    best = "Q1"; bestv = 1
    for nm in ["Q5","Q4","Q3","Q2A_Main","Q1A_Main","Q2B","Q1B"]:
        if nm in sheets and not sheets[nm].empty and "quarter" in sheets[nm].columns:
            q = normalize_quarter_col(sheets[nm])["quarter"].astype(str)
            qv = q.map(order).max(skipna=True)
            if pd.notna(qv) and int(qv) > bestv:
                bestv = int(qv)
                best   = [k for k,v in order.items() if v==bestv][0]
    return best

def months_up_to(q: str) -> List[str]:
    out: List[str] = []
    for oq in ["Q1","Q2","Q3","Q4"]:
        out += QMAP[oq]
        if oq == q: break
    return out

def ensure_months(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()
    for m in MONTHS:
        if m not in out.columns:
            out[m] = 0
    return out

def quarter_sums(df: pd.DataFrame) -> pd.DataFrame:
    out = ensure_months(df.copy())
    out["Q1"] = out[QMAP["Q1"]].sum(axis=1)
    out["Q2"] = out[QMAP["Q2"]].sum(axis=1)
    out["Q3"] = out[QMAP["Q3"]].sum(axis=1)
    out["Q4"] = out[QMAP["Q4"]].sum(axis=1)
    return out

def add_mom(df: pd.DataFrame, months: List[str]) -> pd.DataFrame:
    out = df.copy()
    for i, m in enumerate(months):
        if i == 0: continue
        p = months[i-1]
        out[f"Diff_{m}"] = out[m] - out[p]
        denom = out[p].replace(0, pd.NA)
        out[f"MoM_{m}"] = (out[m] - out[p]) / denom
    return out

def add_qoq(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()
    qs = ["Q1","Q2","Q3","Q4"]
    for i, q in enumerate(qs):
        if i == 0: continue
        pq = qs[i-1]
        out[f"Diff_{q}"]    = out[q] - out[pq]
        out[f"PctDiff_{q}"] = (out[q] - out[pq]) / out[pq].replace(0, pd.NA)
    return out

def add_yoy_quarters(curr_q: pd.DataFrame, prev_q: Optional[pd.DataFrame], join_dims: List[str]) -> pd.DataFrame:
    if prev_q is None or prev_q.empty:
        return curr_q
    join_keys = [c for c in join_dims if c in curr_q.columns]
    left  = curr_q.copy()
    right = prev_q.copy()
    cols_keep = ["Q1","Q2","Q3","Q4"]
    right = right[join_keys + cols_keep].copy()
    right = right.rename(columns={q:f"Prior_{q}" for q in cols_keep})
    merged = left.merge(right, on=join_keys, how="left")
    for q in ["Q1","Q2","Q3","Q4"]:
        pr = f"Prior_{q}"
        denom = merged[pr].replace(0, pd.NA)
        merged[f"YoY_{q}"] = (merged[q] - merged[pr]) / denom
    return merged

def attach_fi_type(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    if "entity_name" not in df.columns:
        raise ValueError("staging sheet missing 'entity_name'")
    df["fi_type"] = df["entity_name"].map(ENTITY_TO_TYPE)
    return df

def base_group_sum(df: pd.DataFrame, value_cols: List[str], dims: List[str]) -> pd.DataFrame:
    agg = {c:"sum" for c in value_cols}
    g = df.groupby(dims, dropna=False).agg(agg).reset_index()
    return g

def build_rollup_blocks(df_with_type: pd.DataFrame, value_cols: List[str], facet_dims: List[str]) -> pd.DataFrame:
    """
    Create stacked rows:
      - All defined rollups in ROLLUP_ORDER
      - Institution rows (entity level)
    Columns produced: fi_type, entity_group, institution, [facets], year, quarter, [values...]
    """
    base_dims = ["year","quarter"]
    dims_inst = ["fi_type","entity_group","institution"] + facet_dims + base_dims

    # Ensure expected cols
    for c in ["fi_type","entity_name","year","quarter"]:
        if c not in df_with_type.columns:
            df_with_type[c] = ""

    # Institution rows (entity_group = fi_type, institution = entity_name)
    inst = df_with_type.copy()
    inst["entity_group"] = inst["fi_type"]
    inst["institution"]  = inst["entity_name"]
    inst_block = base_group_sum(inst, value_cols, dims_inst)

    # Rollup rows (entity_group = rollup name, institution = "")
    roll_frames = []
    for rname in ROLLUP_ORDER:
        members = ROLLUPS.get(rname, [])
        if not members:
            continue
        sub = df_with_type[df_with_type["fi_type"].isin(members)].copy()
        if sub.empty:
            continue
        sub["entity_group"] = rname
        sub["institution"]  = ""
        dims_roll = ["entity_group","institution"] + facet_dims + base_dims
        roll_frames.append(base_group_sum(sub, value_cols, ["fi_type"] + dims_roll).drop(columns=["fi_type"]))

    all_rolls = pd.concat(roll_frames, ignore_index=True) if roll_frames else pd.DataFrame(columns=dims_inst+value_cols)
    out = pd.concat([all_rolls, inst_block], ignore_index=True)

    # Order columns
    lead = ["fi_type","entity_group","institution"] + facet_dims + base_dims
    cols = lead + value_cols
    return out[cols]

def sort_rows(df: pd.DataFrame) -> pd.DataFrame:
    order = pd.CategoricalDtype(categories=ROLLUP_ORDER + sorted([x for x in df.get("fi_type", pd.Series([])).dropna().unique()]), ordered=True)
    dfo = df.copy()
    if "entity_group" in dfo.columns:
        dfo["entity_group"] = dfo["entity_group"].astype(order)
    return dfo.sort_values(by=["entity_group","institution"] + [c for c in ["subquestion","worker_category","job_function"] if c in dfo.columns], kind="stable")

# ----------------- SHEET BUILDERS -----------------
def make_monthly_sheet(stage_df: pd.DataFrame, current_q: str, prior_df: Optional[pd.DataFrame]) -> pd.DataFrame:
    d0 = attach_fi_type(normalize_quarter_col(stage_df))
    vcols = [c for c in MONTHS if c in d0.columns]
    d0 = ensure_months(d0); vcols = MONTHS
    facet_dims = [c for c in ["question","subquestion","worker_category","job_function"] if c in d0.columns]

    stacked = build_rollup_blocks(d0, vcols, facet_dims)
    stacked = quarter_sums(stacked)

    months = months_up_to(current_q)
    keep_metrics = months + ["Q1","Q2","Q3","Q4"]
    out = stacked[["fi_type","entity_group","institution", *facet_dims, "year","quarter", *keep_metrics]].copy()

    out = add_mom(out, months)
    out = add_qoq(out)

    if prior_df is not None and not prior_df.empty:
        p0 = attach_fi_type(normalize_quarter_col(prior_df))
        p0 = ensure_months(p0)
        pstack = build_rollup_blocks(p0, MONTHS, facet_dims)
        pstack = quarter_sums(pstack)
        join_dims = ["fi_type","entity_group","institution", *facet_dims]
        out = add_yoy_quarters(out, pstack, join_dims)

    return sort_rows(out)

def make_single_month_sheet(stage_df: pd.DataFrame, months_avail: List[str], prior_df: Optional[pd.DataFrame]) -> pd.DataFrame:
    d0 = attach_fi_type(normalize_quarter_col(stage_df))
    facet_dims = [c for c in ["question","subquestion","worker_category"] if c in d0.columns]
    vcols = [m for m in months_avail if m in d0.columns]
    stacked = build_rollup_blocks(d0, vcols, facet_dims)
    out = stacked[["fi_type","entity_group","institution", *facet_dims, "year","quarter", *vcols]].copy()

    if prior_df is not None and not prior_df.empty:
        p0 = attach_fi_type(normalize_quarter_col(prior_df))
        pstack = build_rollup_blocks(p0, vcols, facet_dims)
        join_dims = ["fi_type","entity_group","institution", *facet_dims]
        left  = out.copy()
        right = pstack[join_dims + vcols].copy().rename(columns={m:f"Prior_{m}" for m in vcols})
        out   = left.merge(right, on=join_dims, how="left")
        for m in vcols:
            denom = out[f"Prior_{m}"].replace(0, pd.NA)
            out[f"YoY_{m}"] = (out[m] - out[f"Prior_{m}"]) / denom

    return sort_rows(out)

def make_jobfunc_q4_sheet(stage_df: pd.DataFrame, prior_df: Optional[pd.DataFrame]) -> pd.DataFrame:
    d0 = attach_fi_type(normalize_quarter_col(stage_df)).copy()
    if "value" not in d0.columns: d0["value"] = 0
    d0["Dec"] = d0["value"]
    for m in [m for m in MONTHS if m != "Dec"]:
        if m not in d0.columns: d0[m] = 0
    d0 = d0.drop(columns=[c for c in d0.columns if c not in ["entity_name","fi_type","year","quarter","subquestion","worker_category","job_function", *MONTHS]])

    facet_dims = [c for c in ["subquestion","worker_category","job_function"] if c in d0.columns]
    stacked = build_rollup_blocks(d0, MONTHS, facet_dims)
    stacked = quarter_sums(stacked)
    out = stacked[["fi_type","entity_group","institution", *facet_dims, "year","quarter", *MONTHS, "Q1","Q2","Q3","Q4"]].copy()

    out = add_qoq(out)
    if prior_df is not None and not prior_df.empty:
        p0 = attach_fi_type(normalize_quarter_col(prior_df)).copy()
        if "value" not in p0.columns: p0["value"] = 0
        p0["Dec"] = p0["value"]
        for m in [m for m in MONTHS if m != "Dec"]:
            if m not in p0.columns: p0[m] = 0
        p0 = p0.drop(columns=[c for c in p0.columns if c not in ["entity_name","fi_type","year","quarter","subquestion","worker_category","job_function", *MONTHS]])
        pstack = build_rollup_blocks(p0, MONTHS, facet_dims)
        pstack = quarter_sums(pstack)
        join_dims = ["fi_type","entity_group","institution", *facet_dims]
        out = add_yoy_quarters(out, pstack, join_dims)

    return sort_rows(out)

# ----------------- MAIN -----------------
def main() -> int:
    ap = argparse.ArgumentParser(description="Fast, values-only QC workbook (embedded FI mapping + rollups).")
    ap.add_argument("--stage", required=True, help="Path to current staging_all.xlsx")
    ap.add_argument("--out", required=True, help="Output workbook .xlsx")
    ap.add_argument("--prior-stage", help="Optional prior-year staging_all.xlsx for YoY")
    args = ap.parse_args()

    stage_path = Path(args.stage)
    if not stage_path.exists():
        raise SystemExit(f"[ERROR] Stage not found: {stage_path}")

    sheets = load_xlsx(stage_path)
    if not sheets:
        raise SystemExit("[ERROR] Stage file has no readable sheets.")

    prior_sheets: Dict[str,pd.DataFrame] = {}
    if args.prior_stage:
        ppath = Path(args.prior_stage)
        if not ppath.exists():
            print(f"[WARN] Prior stage not found: {ppath} (YoY will be skipped)")
        else:
            prior_sheets = load_xlsx(ppath)

    current_q = detect_current_quarter(sheets)

    outputs: List[Tuple[str,pd.DataFrame]] = []

    # Q1A main
    if "Q1A_Main" in sheets and not sheets["Q1A_Main"].empty:
        prev = prior_sheets.get("Q1A_Main")
        outputs.append(("QC_Q1A", make_monthly_sheet(sheets["Q1A_Main"], current_q, prev)))

    # Q1B (Jun/Dec may exist one or both)
    if "Q1B" in sheets and not sheets["Q1B"].empty:
        months_avail = [m for m in ["Jun","Dec"] if m in sheets["Q1B"].columns]
        if months_avail:
            prev = prior_sheets.get("Q1B")
            outputs.append(("QC_Q1B", make_single_month_sheet(sheets["Q1B"], months_avail, prev)))

    # Q1A Job Function (Q4 only)
    if "Q1A_JobFunc_Q4" in sheets and not sheets["Q1A_JobFunc_Q4"].empty:
        prev = prior_sheets.get("Q1A_JobFunc_Q4")
        outputs.append(("QC_Q1A_JF_Q4", make_jobfunc_q4_sheet(sheets["Q1A_JobFunc_Q4"], prev)))

    # Q2A main
    if "Q2A_Main" in sheets and not sheets["Q2A_Main"].empty:
        df = sheets["Q2A_Main"].rename(columns={"subsection":"subquestion"})
        prev = prior_sheets.get("Q2A_Main")
        outputs.append(("QC_Q2A", make_monthly_sheet(df, current_q, prev)))

    # Q2B
    if "Q2B" in sheets and not sheets["Q2B"].empty:
        df = sheets["Q2B"].rename(columns={"subsection":"subquestion"})
        months_avail = [m for m in ["Jun","Dec"] if m in df.columns]
        if months_avail:
            prev = prior_sheets.get("Q2B")
            outputs.append(("QC_Q2B", make_single_month_sheet(df, months_avail, prev)))

    # Q2A Job Function (Q4 only)
    if "Q2A_JobFunc_Q4" in sheets and not sheets["Q2A_JobFunc_Q4"].empty:
        df = sheets["Q2A_JobFunc_Q4"].rename(columns={"subsection":"subquestion"})
        prev = prior_sheets.get("Q2A_JobFunc_Q4")
        outputs.append(("QC_Q2A_JF_Q4", make_jobfunc_q4_sheet(df, prev)))

    # Q3
    if "Q3" in sheets and not sheets["Q3"].empty:
        prev = prior_sheets.get("Q3")
        outputs.append(("QC_Q3", make_monthly_sheet(sheets["Q3"], current_q, prev)))

    # Q4
    if "Q4" in sheets and not sheets["Q4"].empty:
        prev = prior_sheets.get("Q4")
        outputs.append(("QC_Q4", make_monthly_sheet(sheets["Q4"], current_q, prev)))

    # Q5
    if "Q5" in sheets and not sheets["Q5"].empty:
        prev = prior_sheets.get("Q5")
        outputs.append(("QC_Q5", make_monthly_sheet(sheets["Q5"], current_q, prev)))

    if not outputs:
        raise SystemExit("[ERROR] No usable sheets in stage file.")

    # Write workbook (values only) + freeze header & autofilter
    with pd.ExcelWriter(args.out, engine="openpyxl") as w:
        for name, df in outputs:
            df.to_excel(w, index=False, sheet_name=name)
        wb = w.book
        for name, _ in outputs:
            ws = wb[name]
            ws.freeze_panes = "A2"
            ws.auto_filter.ref = f"A1:{ws.cell(row=ws.max_row, column=ws.max_column).coordinate}"

    print(f"[DONE] Wrote QC workbook → {args.out}  (Quarter in scope: {current_q})")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())



def sort_rows(df: pd.DataFrame) -> pd.DataFrame:
    # collect labels in desired order, but make them UNIQUE while preserving order
    fi_types = (
        df.get("fi_type", pd.Series([], dtype=object))
          .dropna()
          .astype(str)
          .unique()
          .tolist()
    )
    ordered_labels = []
    for x in ROLLUP_ORDER + fi_types:
        if x not in ordered_labels:
            ordered_labels.append(x)

    cat = pd.CategoricalDtype(categories=ordered_labels, ordered=True)

    dfo = df.copy()
    if "entity_group" in dfo.columns:
        dfo["entity_group"] = dfo["entity_group"].astype(str).astype(cat)

    # stable sort: entity_group (by our categorical order) → institution → other dims
    extra = [c for c in ["subquestion","worker_category","job_function"] if c in dfo.columns]
    return dfo.sort_values(by=["entity_group","institution", *extra], kind="stable")





