#!/usr/bin/env python3
# variance_consol.py â€” One-sheet "Variance" output (clean 9-column Excel)
from __future__ import annotations
import time, shutil, tempfile
from pathlib import Path
from typing import List, Dict, Tuple, Optional
import pandas as pd
from openpyxl import load_workbook

# =========================
# PATH CONFIG (edit these)
# =========================
INPUT_FOLDER = r"C:\YourFolder\VR_Files"  # ðŸ‘ˆ change me
OUTPUT_FILE  = r"C:\YourFolder\VR_Consol_2025_Quarter1.xlsx"  # ðŸ‘ˆ change me

# =========================
# SHEET & CELL CONFIG
# =========================
SHEET_KEYS = {
    "cover": ["cover"],
    "vr1": ["vr1", "vr 1"],
}
COVER = {"entity": "F6", "year": "F7", "quarter": "F8"}
MONTHS_BY_Q = {
    "Quarter 1": ["Jan","Feb","Mar"],
    "Quarter 2": ["Apr","May","Jun"],
    "Quarter 3": ["Jul","Aug","Sep"],
    "Quarter 4": ["Oct","Nov","Dec"],
    "Q1": ["Jan","Feb","Mar"],
    "Q2": ["Apr","May","Jun"],
    "Q3": ["Jul","Aug","Sep"],
    "Q4": ["Oct","Nov","Dec"],
}

# Growth & Justification columns (VR1)
GROWTH_COLS = ["H", "J", "L"]
JUST_COLS   = ["M", "N", "O"]

# =========================
# FIXED ROW CONFIG (VR layout)
# =========================
Q1A_MAIN = {
    "Employment = A + B(i) + B(ii)": [15, 17, 19, 21, 23, 25, 27, 28],
    "A. Malaysian": list(range(30, 36 + 1)),
    "B(i) Non-Malaysian: PR": list(range(38, 44 + 1)),
    "B(ii) Non-Malaysian: NPR": list(range(46, 52 + 1)),
}
Q1B_ISLAMIC = {
    "Employment = A + B(i) + B(ii)": list(range(57, 63 + 1)),
    "A. Malaysian": list(range(65, 71 + 1)),
    "B(i) PR": list(range(73, 79 + 1)),
    "B(ii) NPR": list(range(81, 87 + 1)),
}
Q2A_MAIN = {
    "Salary & Wages = A+B+C+D+E": list(range(93, 99 + 1)),
    "A. Basic Salary & Wages": list(range(101, 107 + 1)),
    "B. Arrears to Basic": [109,111,113,115,117,119,121],
    "C. Bonus": list(range(123, 129 + 1)),
    "D. Others (overtime, COLA, allowance, etc.)": list(range(131, 137 + 1)),
    "E. Commissions Paid At Least Once a Month (RM)": list(range(139, 145 + 1)),
}
Q2B_ISLAMIC = {
    "A. Salary & Wages": list(range(150, 156 + 1)),
    "B. Commissions Paid At Least Once a Month (RM)": list(range(158, 164 + 1)),
}
Q3_ROWS = [
    (169, "Managers"),
    (170, "Professional"),
    (171, "Technicians & Associate Professionals"),
    (172, "Clerical Occupations"),
    (173, "Operative Workers"),
    (174, "Elementary Occupations"),
    (175, "TOTAL Hours Worked During the Month, Including Overtime"),
]
Q4_BLOCKS = [
    ("A. Number of Job Vacancies as at End of the Month", 181, 187),
    ("B. Minimum Basic Starting Salaries of Job Vacancies during the month (RM)", 188, 195),
    ("C(i). Number of Job Vacancies Due to New Jobs Created During the Month", 197, 203),
    ("C(ii). Number Job Vacancies Due to Retirements, Resignations and All Reasons, other than New Jobs Created during the Month", 205, 211),
]
Q5_BLOCKS = [
    ("New Hires and Recalls", 218, 224),
    ("Separations = A + B + C", 226, 232),
    ("A. Quits and Resignations (except retirements)", 234, 240),
    ("B. Total Layoffs and Discharges", 242, 248),
    ("B(i). Layoffs and Discharges: of which; VSS/MSS", 250, 256),
    ("C. Other Separations", 258, 264),
]

# =========================
# HELPERS
# =========================
def _norm(s: object) -> str:
    return "" if s is None else str(s).strip()

def read_number(ws, addr: str) -> float:
    try:
        v = ws[addr].value
    except Exception:
        return 0.0
    if v in (None, "", "-", "â€“"):
        return 0.0
    try:
        return float(v)
    except Exception:
        try:
            return float(str(v).replace("%","").replace(",","").strip())
        except Exception:
            return 0.0

def read_text(ws, addr: str) -> str:
    try:
        v = ws[addr].value
    except Exception:
        return ""
    return "" if v in (None, "") else str(v).strip()

def find_sheetname(wb, keys):
    for n in wb.sheetnames:
        norm = n.lower().replace(" ", "")
        for k in keys:
            if k in norm:
                return n
    return None

def read_cover_meta(wb):
    sh = find_sheetname(wb, SHEET_KEYS["cover"])
    if not sh: return (None, None, None)
    ws = wb[sh]
    ent = _norm(ws[COVER["entity"]].value)
    yr  = ws[COVER["year"]].value
    q   = _norm(ws[COVER["quarter"]].value)
    try: yr = int(str(yr).strip())
    except: yr = None
    return (ent, yr, q)

def enforce_xlsx(path_str: str) -> Path:
    cleaned = path_str.strip().strip('"').strip("'")
    p = Path(cleaned).with_suffix(".xlsx")
    p.parent.mkdir(parents=True, exist_ok=True)
    print(f"[DEBUG] Output path â†’ {repr(str(p))}")
    return p

def emit(rows: List[dict], ent: str, yr: int, qlbl: str, month: str,
         qn: str, subq: str, wc: str, g: float, j: str):
    rows.append({
        "Entity Name": ent,
        "Year": yr,
        "Quarter": qlbl,
        "Month": month,
        "Question": qn,
        "Subquestion": subq,
        "Worker Category": wc,
        "%Growth": g,
        "Justification": j,
    })

# =========================
# EXTRACTOR
# =========================
def extract_vr1(ws, ent, yr, qlbl):
    out_rows = []
    months = MONTHS_BY_Q.get(qlbl, [])
    if len(months) != 3: return out_rows
    m1, m2, m3 = months
    # --- all question sets ---
    for subq, rows in Q1A_MAIN.items():
        for r in rows:
            wc=_norm(ws[f"A{r}"].value)
            g=[read_number(ws,f"{c}{r}") for c in GROWTH_COLS]
            j=[read_text(ws,f"{c}{r}") for c in JUST_COLS]
            emit(out_rows,ent,yr,qlbl,m1,"Q1A",subq,wc,g[0],j[0])
            emit(out_rows,ent,yr,qlbl,m2,"Q1A",subq,wc,g[1],j[1])
            emit(out_rows,ent,yr,qlbl,m3,"Q1A",subq,wc,g[2],j[2])
    # Repeat pattern for other question blocks
    for subq, row_list in Q1B_ISLAMIC.items():
        for r in row_list:
            wc=_norm(ws[f"A{r}"].value)
            g=[read_number(ws,f"{c}{r}") for c in GROWTH_COLS]
            j=[read_text(ws,f"{c}{r}") for c in JUST_COLS]
            emit(out_rows,ent,yr,qlbl,m1,"Q1B",subq,wc,g[0],j[0])
            emit(out_rows,ent,yr,qlbl,m2,"Q1B",subq,wc,g[1],j[1])
            emit(out_rows,ent,yr,qlbl,m3,"Q1B",subq,wc,g[2],j[2])
    for subq, rows in Q2A_MAIN.items():
        for r in rows:
            wc=_norm(ws[f"A{r}"].value)
            g=[read_number(ws,f"{c}{r}") for c in GROWTH_COLS]
            j=[read_text(ws,f"{c}{r}") for c in JUST_COLS]
            emit(out_rows,ent,yr,qlbl,m1,"Q2A",subq,wc,g[0],j[0])
            emit(out_rows,ent,yr,qlbl,m2,"Q2A",subq,wc,g[1],j[1])
            emit(out_rows,ent,yr,qlbl,m3,"Q2A",subq,wc,g[2],j[2])
    for subq, rows in Q2B_ISLAMIC.items():
        for r in rows:
            wc=_norm(ws[f"A{r}"].value)
            g=[read_number(ws,f"{c}{r}") for c in GROWTH_COLS]
            j=[read_text(ws,f"{c}{r}") for c in JUST_COLS]
            emit(out_rows,ent,yr,qlbl,m1,"Q2B",subq,wc,g[0],j[0])
            emit(out_rows,ent,yr,qlbl,m2,"Q2B",subq,wc,g[1],j[1])
            emit(out_rows,ent,yr,qlbl,m3,"Q2B",subq,wc,g[2],j[2])
    for r,wc in Q3_ROWS:
        g=[read_number(ws,f"{c}{r}") for c in GROWTH_COLS]
        j=[read_text(ws,f"{c}{r}") for c in JUST_COLS]
        emit(out_rows,ent,yr,qlbl,m1,"Q3","",wc,g[0],j[0])
        emit(out_rows,ent,yr,qlbl,m2,"Q3","",wc,g[1],j[1])
        emit(out_rows,ent,yr,qlbl,m3,"Q3","",wc,g[2],j[2])
    for sublabel,r0,r1 in Q4_BLOCKS:
        for r in range(r0,r1+1):
            wc=_norm(ws[f"A{r}"].value)
            if wc=="": continue
            g=[read_number(ws,f"{c}{r}") for c in GROWTH_COLS]
            j=[read_text(ws,f"{c}{r}") for c in JUST_COLS]
            emit(out_rows,ent,yr,qlbl,m1,"Q4",sublabel,wc,g[0],j[0])
            emit(out_rows,ent,yr,qlbl,m2,"Q4",sublabel,wc,g[1],j[1])
            emit(out_rows,ent,yr,qlbl,m3,"Q4",sublabel,wc,g[2],j[2])
    for sublabel,r0,r1 in Q5_BLOCKS:
        for r in range(r0,r1+1):
            wc=_norm(ws[f"A{r}"].value)
            if wc=="": continue
            g=[read_number(ws,f"{c}{r}") for c in GROWTH_COLS]
            j=[read_text(ws,f"{c}{r}") for c in JUST_COLS]
            emit(out_rows,ent,yr,qlbl,m1,"Q5",sublabel,wc,g[0],j[0])
            emit(out_rows,ent,yr,qlbl,m2,"Q5",sublabel,wc,g[1],j[1])
            emit(out_rows,ent,yr,qlbl,m3,"Q5",sublabel,wc,g[2],j[2])
    return out_rows

def extract_file(p: Path) -> pd.DataFrame:
    try: wb = load_workbook(str(p), data_only=True, read_only=True)
    except Exception: return pd.DataFrame()
    ent,yr,qlbl=read_cover_meta(wb)
    if not(ent and yr and qlbl): wb.close(); return pd.DataFrame()
    vr1=find_sheetname(wb,SHEET_KEYS["vr1"])
    if not vr1: wb.close(); return pd.DataFrame()
    ws=wb[vr1]; rows=extract_vr1(ws,ent,yr,qlbl)
    wb.close()
    return pd.DataFrame(rows)

# =========================
# SAFE SAVE (OneDrive-safe)
# =========================
def safe_save_xlsx(df: pd.DataFrame, final_path_str: str) -> Path:
    final_path = enforce_xlsx(final_path_str)
    with tempfile.TemporaryDirectory() as td:
        tmp = Path(td)/"tmp.xlsx"
        with pd.ExcelWriter(tmp, engine="openpyxl") as xw:
            df.to_excel(xw, index=False, sheet_name="Variance")
        shutil.copyfile(tmp, final_path)
    print(f"[INFO] Saved â†’ {final_path}")
    return final_path

# =========================
# MAIN
# =========================
def main():
    root = Path(INPUT_FOLDER)
    files = [p for ext in ("*.xlsx", "*.xlsm") for p in root.rglob(ext) if not p.name.startswith("~$")]
    print(f"[INFO] Files found: {len(files)}")

    t0 = time.perf_counter()
    frames = []
    for p in files:
        df = extract_file(p)
        if not df.empty:
            frames.append(df)

    out = pd.concat(frames, ignore_index=True) if frames else pd.DataFrame(columns=[
        "Entity Name", "Year", "Quarter", "Month", "Question", "Subquestion",
        "Worker Category", "%Growth", "Justification"
    ])

    # ðŸ”§ Round & format %Growth as whole percentages
    if not out.empty:
        out["%Growth"] = out["%Growth"].round(0).astype("Int64").astype(str) + "%"

    # âœ… Save the Excel file
    out_path = safe_save_xlsx(out, OUTPUT_FILE)

    print(f"[DONE] Rows={len(out):,}  Time={time.perf_counter()-t0:0.2f}s")


if __name__ == "__main__":
    main()
