from __future__ import annotations
import argparse, time, re
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import pandas as pd
from openpyxl import load_workbook

# -----------------------
# Static config
# -----------------------
LIKELY_DATA_SHEETS = [
    "Banking & DFI", "Banking & DFI ", "Banking & DFI  ",
    "Insurance/Takaful", "Insurance & Takaful", "Data"
]

COVER = {"entity":"F6", "year":"F7", "quarter":"F8"}

WC = [
    "Managers",
    "Professional",
    "Technicians & Associate Professionals",
    "Clerical Occupations",
    "Operative Workers",
    "Elementary Occupations",
    "TOTAL Salary & Wages",            # for Q2A main blocks
    "TOTAL Basic Salary & Wages",
    "TOTAL Arrears to Basic Salary & Wages",
    "TOTAL Bonus",
    "TOTAL Others (overtime, COLA, allowance, etc.)",
    "TOTAL Commissions Paid At Least Once a Month (RM)",
]

JOB_FUNCS = [
    "Banking Operations","Compliance","Corporate Banking","Credit Management",
    "Digital Banking & Innovation","Finance","Human Resources","Information Technology",
    "Internal Audit","Investment Banking","Legal","Retail Banking","Risk Management",
    "Sales and Marketing","Shariah","Treasury","Other functions"
]

MONTH_COLS = {"Q1":["C","D","E"], "Q2":["C","D","E"], "Q3":["C","D","E"], "Q4":["C","D","E"]}
MONTH_NAMES = {"Q1":["Jan","Feb","Mar"], "Q2":["Apr","May","Jun"], "Q3":["Jul","Aug","Sep"], "Q4":["Oct","Nov","Dec"]}

def _norm(s: object) -> str:
    if s is None: return ""
    s = str(s)
    s = s.replace("&"," and ")
    keep = "abcdefghijklmnopqrstuvwxyz0123456789()+/.:; -"
    return re.sub(r"\s+"," ","".join(ch.lower() if ch.lower() in keep else " " for ch in s)).strip()

def equals(a: object, b: str) -> bool:
    return _norm(a) == _norm(b)

def read_cover_meta(wb) -> Tuple[Optional[str], Optional[int], Optional[str]]:
    ent = yr = ql = None
    if "Cover" in wb.sheetnames:
        ws = wb["Cover"]
        ent = ws[COVER["entity"]].value
        yr  = ws[COVER["year"]].value
        ql  = ws[COVER["quarter"]].value
    # fallback
    if not ent or not yr or not ql:
        for s in wb.sheetnames[:3]:
            if s == "Cover": continue
            ws = wb[s]
            ent = ent or ws["C6"].value
            yr  = yr  or ws["C7"].value
            ql  = ql  or ws["C8"].value
    try:
        yr = int(str(yr).strip()) if yr is not None else None
    except Exception:
        yr = None
    if ql:
        ql_s = str(ql).strip()
        mp = {"Quarter 1":"Q1","Quarter 2":"Q2","Quarter 3":"Q3","Quarter 4":"Q4"}
        ql = mp.get(ql_s, ql_s)
    ent = str(ent).strip() if ent else None
    return ent, yr, ql

def pick_data_sheet(wb) -> str:
    names_norm = {_norm(s): s for s in wb.sheetnames}
    for want in LIKELY_DATA_SHEETS:
        if _norm(want) in names_norm:
            return names_norm[_norm(want)]
    for s in wb.sheetnames:
        if s != "Cover": return s
    return wb.sheetnames[0]

def read_num(ws, coord: str) -> float:
    v = ws[coord].value
    if v in (None, "", "-"): return 0.0
    try:
        return float(v)
    except Exception:
        try:
            return float(str(v).replace(",",""))
        except Exception:
            return 0.0

# -----------------------
# Q2A Main – fixed anchors (fast, robust)
# -----------------------
MAIN_BLOCKS = [
    ("Salary & Wages = A + B + C + D + E", "Salary & Wages = A+B+C+D+E"),
    ("A. Basic Salary & Wages",            "A. Basic Salary & Wages"),
    ("B. Arrears to Basic Salary & Wages", "B. Arrears to Basic Salary & Wages"),
    ("C. Bonus",                            "C. Bonus"),
    ("D. Others (overtime, COLA, allowance, etc.)", "D. Others (overtime, COLA, allowance, etc.)"),
    ("E. Commissions Paid At Least Once a Month (RM)", "E. Commissions Paid At Least Once a Month (RM)"),
]

WC_ORDER = [
    "Managers","Professional","Technicians & Associate Professionals",
    "Clerical Occupations","Operative Workers","Elementary Occupations",
]

def find_row(ws, target_text: str) -> Optional[int]:
    tgt = _norm(target_text)
    for r in range(1, ws.max_row+1):
        if _norm(ws.cell(r,1).value) == tgt:
            return r
    return None

def extract_q2a_main(ws, entity: str, year: int, q: str) -> pd.DataFrame:
    months = MONTH_NAMES.get(q, [])
    mcols  = MONTH_COLS.get(q, ["C","D","E"])
    out = []
    for label_print, label_key in MAIN_BLOCKS:
        anchor = find_row(ws, label_print)
        if anchor is None:
            # try with normalized key in case minor text change in file
            anchor = find_row(ws, label_key)
        if anchor is None:
            continue
        # From the row after anchor, read the standard 6 categories + total row (7 lines)
        r = anchor + 1
        seen = 0
        while r <= ws.max_row and seen < 7:
            a = ws.cell(r,1).value
            if _norm(a) in [_norm(x) for x in WC_ORDER] + [_norm("TOTAL " + label_key.split(".")[0] if "." in label_key else label_key.split(" = ")[0]) , _norm("TOTAL "+label_key)]:
                wc = str(a).strip()
                v1 = read_num(ws, f"{mcols[0]}{r}")
                v2 = read_num(ws, f"{mcols[1]}{r}")
                v3 = read_num(ws, f"{mcols[2]}{r}")
                out.append({
                    "entity_name": entity,
                    "year": year,
                    "quarter": {"Q1":"Quarter 1","Q2":"Quarter 2","Q3":"Quarter 3","Q4":"Quarter 4"}.get(q,q),
                    "subsection": label_key,
                    "worker_category": wc,
                    months[0]: v1, months[1]: v2, months[2]: v3
                })
                seen += 1
            r += 1
    return pd.DataFrame(out)

# -----------------------
# Q2A Job Function (Q4 only) – header-based pick-up
# -----------------------
def extract_q2a_jobfunc_q4(ws, entity: str, year: int, q: str) -> pd.DataFrame:
    if q != "Q4":
        return pd.DataFrame()
    # locate the header row that contains the job functions
    header = None
    best = 0
    for r in range(1, ws.max_row+1):
        row_vals = [_norm(ws.cell(r,c).value) for c in range(1, ws.max_column+1)]
        hits = sum(1 for jf in JOB_FUNCS if _norm(jf) in row_vals)
        if hits > best:
            best = hits; header = r
        if hits >= 8:
            break
    if not header:
        return pd.DataFrame()
    jf_cols = {}
    for c in range(1, ws.max_column+1):
        txt = ws.cell(header,c).value
        for jf in JOB_FUNCS:
            if equals(txt, jf) and jf not in jf_cols:
                jf_cols[jf] = c
    if not jf_cols:
        return pd.DataFrame()
    # take the rows for the 6 worker categories under this header window
    out = []
    end_scan = min(ws.max_row, header + 50)
    for r in range(header+1, end_scan+1):
        a = ws.cell(r,1).value
        if _norm(a) in [_norm(x) for x in WC_ORDER]:
            wc = str(a).strip()
            for jf, c in jf_cols.items():
                val = read_num(ws, f"{ws.cell(r,c).coordinate}")
                out.append({
                    "entity_name": entity,
                    "year": year,
                    "quarter": "Quarter 4",
                    "worker_category": wc,
                    "job_function": jf,
                    "value": val
                })
    return pd.DataFrame(out)

# -----------------------
# Q2B (Islamic ops only) – **fixed cells**
# -----------------------
# Rows/columns exactly as user specified (Jun for Q2, Dec for Q4). Values in column C.
Q2B_A_ROWS = list(range(151, 158))  # A. Salary & Wages (Managers .. TOTAL)
Q2B_B_ROWS = list(range(159, 166))  # B. Commissions … (Managers .. TOTAL)
Q2B_COL    = "C"

def extract_q2b_fixed(ws, entity: str, year: int, q: str) -> pd.DataFrame:
    """Read Q2B using fixed row/col. Return empty df if all zeros/blank."""
    if q not in ("Q2","Q4"):
        return pd.DataFrame()
    out = []
    # A block
    for r in Q2B_A_ROWS:
        a = ws.cell(r, 1).value
        if _norm(a) == "": continue
        v = read_num(ws, f"{Q2B_COL}{r}")
        out.append({
            "entity_name": entity,
            "year": year,
            "quarter": {"Q2":"Quarter 2","Q4":"Quarter 4"}[q],
            "subsection": "A. Salary & Wages",
            "worker_category": str(a).strip(),
            "value": v
        })
    # B block
    for r in Q2B_B_ROWS:
        a = ws.cell(r, 1).value
        if _norm(a) == "": continue
        v = read_num(ws, f"{Q2B_COL}{r}")
        out.append({
            "entity_name": entity,
            "year": year,
            "quarter": {"Q2":"Quarter 2","Q4":"Quarter 4"}[q],
            "subsection": "B. Commissions Paid At Least Once a Month (RM)",
            "worker_category": str(a).strip(),
            "value": v
        })
    df = pd.DataFrame(out)
    if df.empty:
        return df
    # show tab only if ANY non-zero exists across any file; we’ll decide at the end,
    # but keep the rows (including zeros) here.
    return df

# -----------------------
# File driver
# -----------------------
def extract_from_file(p: Path) -> Tuple[pd.DataFrame,pd.DataFrame,pd.DataFrame]:
    try:
        wb = load_workbook(str(p), data_only=True, read_only=True)
    except Exception:
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())
    ent, yr, q = read_cover_meta(wb)
    if not ent or not yr or not q:
        try: wb.close()
        except Exception: pass
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())
    ws = wb[pick_data_sheet(wb)]
    a = extract_q2a_main(ws, ent, yr, q)
    jf = extract_q2a_jobfunc_q4(ws, ent, yr, q)
    b = extract_q2b_fixed(ws, ent, yr, q)
    try: wb.close()
    except Exception: pass
    return (a, jf, b)

# -----------------------
# CLI
# -----------------------
def main() -> int:
    ap = argparse.ArgumentParser(description="Extract RLMS Q2 → staging (fast, fixed-cells for Q2B).")
    ap.add_argument("--inputs", required=True, help="Folder with submissions")
    ap.add_argument("--out", required=True, help="Output .xlsx path")
    ap.add_argument("--limit", type=int, default=None)
    args = ap.parse_args()

    root = Path(args.inputs)
    files: List[Path] = []
    for ext in ("*.xlsx","*.xlsm"):
        files.extend(p for p in root.rglob(ext) if not p.name.startswith("~$"))
    files.sort()
    if args.limit: files = files[:args.limit]
    print(f"[INFO] Files: {len(files)}")

    t0 = time.perf_counter()
    a_rows, jf_rows, b_rows = [], [], []
    for p in files:
        a, jf, b = extract_from_file(p)
        if not a.empty:  a_rows.append(a)
        if not jf.empty: jf_rows.append(jf)
        if not b.empty:  b_rows.append(b)

    df_a  = pd.concat(a_rows, ignore_index=True)  if a_rows else pd.DataFrame()
    df_jf = pd.concat(jf_rows, ignore_index=True) if jf_rows else pd.DataFrame()
    df_b  = pd.concat(b_rows, ignore_index=True)  if b_rows else pd.DataFrame()

    # keep Q2B tab only if ANY non-zero across all rows
    write_b = False
    if not df_b.empty:
        write_b = (pd.to_numeric(df_b["value"], errors="coerce").fillna(0) != 0).any()

    out = Path(args.out)
    out.parent.mkdir(parents=True, exist_ok=True)
    with pd.ExcelWriter(out, engine="openpyxl") as xw:
        if not df_a.empty:
            # sort & write
            order_cols = ["entity_name","year","quarter","subsection","worker_category"]
            month_cols = [c for c in ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"] if c in df_a.columns]
            df_a.sort_values(order_cols + month_cols, kind="mergesort").to_excel(xw, index=False, sheet_name="Q2A_Main")
        if not df_jf.empty:
            df_jf.sort_values(["entity_name","year","quarter","worker_category","job_function"], kind="mergesort") \
                 .to_excel(xw, index=False, sheet_name="Q2A_JobFunc_Q4")
        if write_b:
            # Only FIs that reported something: filter to entities with any nonzero
            nz = df_b.groupby("entity_name")["value"].apply(lambda s: (s.fillna(0)!=0).any())
            keep_ents = set(nz[nz].index)
            df_b = df_b[df_b["entity_name"].isin(keep_ents)].copy()
            df_b.sort_values(["entity_name","year","quarter","subsection","worker_category"], kind="mergesort") \
                .to_excel(xw, index=False, sheet_name="Q2B")
    print(f"[DONE] {out}  | in {time.perf_counter()-t0:0.2f}s")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
