from __future__ import annotations
import argparse, time, re
from pathlib import Path
from typing import Dict, List, Tuple, Optional

import pandas as pd
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter

# -------------------------------------------------
# Config
# -------------------------------------------------
LIKELY_SHEETS = [
    "Banking & DFI", "Banking & DFI ", "Banking & DFI  ",
    "Insurance/Takaful", "Insurance & Takaful", "Data"
]
COVER = {"entity": "F6", "year": "F7", "quarter": "F8"}

WORKER_CATEGORIES = [
    "Managers",
    "Professional",
    "Technicians & Associate Professionals",
    "Clerical Occupations",
    "Operative Workers",
    "Elementary Occupations",
]

MONTHS_BY_Q = {
    "Quarter 1": ["Jan","Feb","Mar"],
    "Quarter 2": ["Apr","May","Jun"],
    "Quarter 3": ["Jul","Aug","Sep"],
    "Quarter 4": ["Oct","Nov","Dec"],
    "Q1": ["Jan","Feb","Mar"],
    "Q2": ["Apr","May","Jun"],
    "Q3": ["Jul","Aug","Sep"],
    "Q4": ["Oct","Nov","Dec"],
}

JOB_FUNCTIONS = [
    "Banking Operations","Compliance","Corporate Banking","Credit Management",
    "Digital Banking & Innovation","Finance","Human Resources","Information Technology",
    "Internal Audit","Investment Banking","Legal","Retail Banking","Risk Management",
    "Sales and Marketing","Shariah","Treasury","Other functions"
]

# ---- Fixed positions for Q2A MAIN (rows are absolute in the template) ----
# Month values are always in columns C, D, E for the active quarter.
Q2A_BLOCKS: List[Dict] = [
    # Salary & Wages = A + B + C + D + E
    {"subq": "Salary & Wages = A+B+C+D+E",
     "rows": {"Managers":94,"Professional":95,"Technicians & Associate Professionals":96,
              "Clerical Occupations":97,"Operative Workers":98,"Elementary Occupations":99,
              "TOTAL Salary & Wages":100}},
    # A. Basic Salary & Wages
    {"subq": "A. Basic Salary & Wages",
     "rows": {"Managers":102,"Professional":103,"Technicians & Associate Professionals":104,
              "Clerical Occupations":105,"Operative Workers":106,"Elementary Occupations":107,
              "TOTAL Basic Salary & Wages":108}},
    # B. Arrears to Basic Salary & Wages  (note: period rows are interleaved; values at even rows below)
    {"subq": "B. Arrears to Basic Salary & Wages",
     "rows": {"Managers":110,"Professional":112,"Technicians & Associate Professionals":114,
              "Clerical Occupations":116,"Operative Workers":118,"Elementary Occupations":120,
              "TOTAL Arrears to Basic Salary & Wages":122}},
    # C. Bonus
    {"subq": "C. Bonus",
     "rows": {"Managers":124,"Professional":125,"Technicians & Associate Professionals":126,
              "Clerical Occupations":127,"Operative Workers":128,"Elementary Occupations":129,
              "TOTAL Bonus":130}},
    # D. Others (overtime, COLA, allowance, etc.)
    {"subq": "D. Others (overtime, COLA, allowance, etc.)",
     "rows": {"Managers":132,"Professional":133,"Technicians & Associate Professionals":134,
              "Clerical Occupations":135,"Operative Workers":136,"Elementary Occupations":137,
              "TOTAL Others (overtime, COLA, allowance, etc.)":138}},
    # E. Commissions Paid At Least Once a Month (RM)
    {"subq": "E. Commissions Paid At Least Once a Month (RM)",
     "rows": {"Managers":140,"Professional":141,"Technicians & Associate Professionals":142,
              "Clerical Occupations":143,"Operative Workers":144,"Elementary Occupations":145,
              "TOTAL Commissions Paid At Least Once a Month (RM)":146}},
]

# Q2B (Islamic ops only): fixed positions (single month in col C)
Q2B_START_SUBQ_A = 150   # "A. Salary & Wages"
Q2B_ROWS_A = {"Managers":151,"Professional":152,"Technicians & Associate Professionals":153,
              "Clerical Occupations":154,"Operative Workers":155,"Elementary Occupations":156,
              "TOTAL Salary & Wages":157}
Q2B_START_SUBQ_B = 158   # "B. Commissions Paid At Least Once a Month (RM)"
Q2B_ROWS_B = {"Managers":159,"Professional":160,"Technicians & Associate Professionals":161,
              "Clerical Occupations":162,"Operative Workers":163,"Elementary Occupations":164,
              "TOTAL Commissions Paid At Least Once a Month (RM)":165}

# -------------------------------------------------
# Helpers
# -------------------------------------------------
def _norm(s: object) -> str:
    if s is None: return ""
    s = str(s).replace("&"," and ")
    keep = "abcdefghijklmnopqrstuvwxyz0123456789:+().,%/- "
    s2 = "".join(ch.lower() if ch.lower() in keep else " " for ch in s)
    return re.sub(r"\s+"," ", s2).strip()

def read_cover_meta(wb) -> Tuple[Optional[str], Optional[int], Optional[str]]:
    ent = yr = ql = None
    if "Cover" in wb.sheetnames:
        ws = wb["Cover"]
        try:
            ent = ws[COVER["entity"]].value
            yr  = ws[COVER["year"]].value
            ql  = ws[COVER["quarter"]].value
        except Exception:
            pass
    # gentle fallback
    if not ent or not yr or not ql:
        for s in wb.sheetnames[:3]:
            if s == "Cover": continue
            ws = wb[s]
            for addr, var in (("C6","ent"),("C7","yr"),("C8","ql")):
                try:
                    v = ws[addr].value
                except Exception:
                    v = None
                if var=="ent" and not ent and v: ent=v
                if var=="yr"  and not yr  and v: yr=v
                if var=="ql"  and not ql  and v: ql=v
    try:
        yr = int(str(yr).strip()) if yr is not None else None
    except Exception:
        yr = None
    return (str(ent).strip() if ent else None, yr, str(ql).strip() if ql else None)

def pick_data_sheet(wb) -> str:
    names = { _norm(n): n for n in wb.sheetnames }
    for want in LIKELY_SHEETS:
        key = _norm(want)
        if key in names: return names[key]
    for n in wb.sheetnames:
        if n != "Cover": return n
    return wb.sheetnames[0]

def read_num_cell(ws, r: int, c_letter: str) -> float:
    try:
        v = ws[f"{c_letter}{r}"].value
    except Exception:
        return 0.0
    if v in (None, "", "-", " ", "–"): return 0.0
    try:
        return float(v)
    except Exception:
        s = str(v).replace(",","")
        try:
            return float(s)
        except Exception:
            return 0.0

# -------------------------------------------------
# Q2A – MAIN (fixed rows, no scanning)
# -------------------------------------------------
def extract_q2a_main(ws, entity: str, yr: int, qlabel: str) -> pd.DataFrame:
    months = MONTHS_BY_Q.get(qlabel, [])
    if len(months) != 3:
        return pd.DataFrame()

    out: List[Dict] = []
    for block in Q2A_BLOCKS:
        subq = block["subq"]
        for wc, r in block["rows"].items():
            rec = {
                "entity_name": entity,
                "year": yr,
                "quarter": qlabel,
                "subsection": subq,
                "worker_category": wc,
                months[0]: read_num_cell(ws, r, "C"),
                months[1]: read_num_cell(ws, r, "D"),
                months[2]: read_num_cell(ws, r, "E"),
            }
            out.append(rec)
    return pd.DataFrame(out)

# -------------------------------------------------
# Q2A – JOB FUNCTION (Q4 only, fixed rows + header match for columns)
# -------------------------------------------------
def find_jobfunc_header(ws) -> Tuple[int, Dict[str,int]]:
    """
    Return (header_row_index, {job_function -> column_index}).
    We scan for the row with the most job function name matches then map columns.
    """
    best_r, best_hits = None, -1
    for r in range(1, ws.max_row + 1):
        row_vals = [ _norm(ws.cell(r, c).value) for c in range(1, ws.max_column + 1) ]
        hits = sum(1 for jf in JOB_FUNCTIONS if _norm(jf) in row_vals)
        if hits > best_hits:
            best_hits, best_r = hits, r
        if hits >= 10:  # good enough
            break
    if not best_r or best_hits <= 0:
        return (0, {})
    # map headers in that row
    jf_cols: Dict[str,int] = {}
    for c in range(1, ws.max_column + 1):
        txt = ws.cell(best_r, c).value
        for jf in JOB_FUNCTIONS:
            if _norm(txt) == _norm(jf) and jf not in jf_cols:
                jf_cols[jf] = c
    return (best_r, jf_cols)

def extract_q2a_jobfunc_q4(ws, entity: str, yr: int, qlabel: str) -> pd.DataFrame:
    if _norm(qlabel) not in ("q4","quarter 4"):
        return pd.DataFrame()

    header_r, jf_cols = find_jobfunc_header(ws)
    if not header_r or not jf_cols:
        return pd.DataFrame()

    # Rows to read are exactly the SAME as Q2A main (across all blocks)
    # We'll read value at each (row, jf_col).
    out: List[Dict] = []
    for block in Q2A_BLOCKS:
        subq = block["subq"]
        for wc, r in block["rows"].items():
            for jf, c in jf_cols.items():
                # build address safely (avoid EmptyCell.coordinate)
                addr = f"{get_column_letter(c)}{r}"
                v = ws[addr].value
                try:
                    val = 0.0 if v in (None,"","-"," ") else float(str(v).replace(",",""))
                except Exception:
                    val = 0.0
                out.append({
                    "entity_name": entity,
                    "year": yr,
                    "quarter": qlabel,
                    "subsection": subq,
                    "worker_category": wc,
                    "job_function": jf,
                    "value": val,
                })
    return pd.DataFrame(out)

# -------------------------------------------------
# Q2B – Islamic ops (Jun/Dec only), include sheet if any FI has data
# -------------------------------------------------
def extract_q2b(ws, entity: str, yr: int, qlabel: str) -> pd.DataFrame:
    # Single month (Jun for Q2, Dec for Q4)
    qn = _norm(qlabel)
    if qn not in ("q2","quarter 2","q4","quarter 4"):
        return pd.DataFrame()

    month = MONTHS_BY_Q["Q2"][2] if qn in ("q2","quarter 2") else MONTHS_BY_Q["Q4"][2]  # Jun or Dec
    out: List[Dict] = []

    # Subsection A
    for wc, r in Q2B_ROWS_A.items():
        val = read_num_cell(ws, r, "C")
        out.append({
            "entity_name": entity, "year": yr, "quarter": qlabel,
            "subsection": "A. Salary & Wages", "worker_category": wc, month: val
        })
    # Subsection B
    for wc, r in Q2B_ROWS_B.items():
        val = read_num_cell(ws, r, "C")
        out.append({
            "entity_name": entity, "year": yr, "quarter": qlabel,
            "subsection": "B. Commissions Paid At Least Once a Month (RM)",
            "worker_category": wc, month: val
        })

    df = pd.DataFrame(out)
    # Keep only FIs that actually reported something (any non-zero)
    if df.select_dtypes(include="number").sum().sum() == 0:
        return pd.DataFrame()
    return df

# -------------------------------------------------
# File driver
# -------------------------------------------------
def extract_from_file(path: Path, verbose=False) -> Tuple[pd.DataFrame,pd.DataFrame,pd.DataFrame]:
    try:
        wb = load_workbook(str(path), data_only=True, read_only=True)
    except Exception as e:
        if verbose: print(f"[ERROR] open {path.name}: {e}")
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

    ent, yr, ql = read_cover_meta(wb)
    if not ent or not yr or not ql:
        if verbose: print(f"[WARN] {path.name}: missing cover meta; skip")
        try: wb.close()
        except: pass
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

    ws = wb[pick_data_sheet(wb)]
    a = extract_q2a_main(ws, ent, yr, ql)
    jf = extract_q2a_jobfunc_q4(ws, ent, yr, ql)
    b = extract_q2b(ws, ent, yr, ql)

    try: wb.close()
    except: pass
    return (a, jf, b)

# -------------------------------------------------
# CLI
# -------------------------------------------------
def main() -> int:
    ap = argparse.ArgumentParser(description="Extract RLMS Q2 → staging (fixed positions, fast)")
    ap.add_argument("--input", required=True, help="Folder with submissions")
    ap.add_argument("--out", required=True, help="Output staging workbook (.xlsx)")
    ap.add_argument("--limit", type=int, default=None)
    ap.add_argument("--verbose", action="store_true")
    args = ap.parse_args()

    root = Path(args.input)
    if not root.exists():
        print(f"[ERROR] Folder not found: {root}")
        return 2

    files: List[Path] = []
    for ext in ("*.xlsx","*.xlsm"):
        files.extend(p for p in root.rglob(ext) if not p.name.startswith("~$"))
    files.sort()
    if args.limit:
        files = files[:args.limit]
    print(f"[INFO] Files: {len(files)}")

    t0 = time.perf_counter()
    rows_a, rows_jf, rows_b = [], [], []
    for i, p in enumerate(files, 1):
        a, jf, b = extract_from_file(p, verbose=args.verbose)
        if not a.empty:  rows_a.append(a)
        if not jf.empty: rows_jf.append(jf)
        if not b.empty:  rows_b.append(b)
        if args.verbose and i % 25 == 0:
            print(f"  processed {i}/{len(files)}")

    df_a  = pd.concat(rows_a,  ignore_index=True) if rows_a  else pd.DataFrame()
    df_jf = pd.concat(rows_jf, ignore_index=True) if rows_jf else pd.DataFrame()
    df_b  = pd.concat(rows_b,  ignore_index=True) if rows_b  else pd.DataFrame()

    # Sort for readability (and stability)
    def _sort(df: pd.DataFrame) -> pd.DataFrame:
        if df.empty: return df
        sort_cols = [c for c in ["entity_name","year","quarter","subsection","worker_category","job_function"] if c in df.columns]
        return df.sort_values(sort_cols, kind="mergesort").reset_index(drop=True)

    df_a  = _sort(df_a)
    df_jf = _sort(df_jf)
    df_b  = _sort(df_b)

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with pd.ExcelWriter(out_path, engine="openpyxl") as xw:
        if not df_a.empty:
            df_a.to_excel(xw, sheet_name="Q2A_Main", index=False)
        if not df_jf.empty:
            df_jf.to_excel(xw, sheet_name="Q2A_JobFunc_Q4", index=False)
        if not df_b.empty:
            df_b.to_excel(xw, sheet_name="Q2B", index=False)

    print(f"[DONE] {out_path}  "
          f"(Q2A_Main rows={0 if df_a.empty else len(df_a):,}, "
          f"Q2A_JobFunc_Q4 rows={0 if df_jf.empty else len(df_jf):,}, "
          f"Q2B rows={0 if df_b.empty else len(df_b):,})")
    print(f"[TIME] {time.perf_counter()-t0:0.2f}s")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
