# extract_q2.py
from __future__ import annotations
import argparse, time, re
from pathlib import Path
from typing import Dict, List, Tuple, Optional

import pandas as pd
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter

# -------------------------------------------------
# Config
# -------------------------------------------------
LIKELY_SHEETS = [
    "Banking & DFI", "Banking & DFI ", "Banking & DFI  ",
    "Insurance/Takaful", "Insurance & Takaful", "Data"
]
COVER = {"entity": "F6", "year": "F7", "quarter": "F8"}

MONTHS_BY_Q = {
    "Quarter 1": ["Jan","Feb","Mar"],
    "Quarter 2": ["Apr","May","Jun"],
    "Quarter 3": ["Jul","Aug","Sep"],
    "Quarter 4": ["Oct","Nov","Dec"],
    "Q1": ["Jan","Feb","Mar"],
    "Q2": ["Apr","May","Jun"],
    "Q3": ["Jul","Aug","Sep"],
    "Q4": ["Oct","Nov","Dec"],
}

# ---- Fixed positions for Q2A MAIN (rows are absolute in the template) ----
# Month values are always in columns C, D, E for the active quarter.
Q2A_BLOCKS: List[Dict] = [
    # Salary & Wages = A + B + C + D + E
    {"subq": "Salary & Wages = A+B+C+D+E",
     "rows": {"Managers":94,"Professional":95,"Technicians & Associate Professionals":96,
              "Clerical Occupations":97,"Operative Workers":98,"Elementary Occupations":99,
              "TOTAL Salary & Wages":100}},
    # A. Basic Salary & Wages
    {"subq": "A. Basic Salary & Wages",
     "rows": {"Managers":102,"Professional":103,"Technicians & Associate Professionals":104,
              "Clerical Occupations":105,"Operative Workers":106,"Elementary Occupations":107,
              "TOTAL Basic Salary & Wages":108}},
    # B. Arrears to Basic Salary & Wages  (note: period rows interleaved in template)
    {"subq": "B. Arrears to Basic Salary & Wages",
     "rows": {"Managers":110,"Professional":112,"Technicians & Associate Professionals":114,
              "Clerical Occupations":116,"Operative Workers":118,"Elementary Occupations":120,
              "TOTAL Arrears to Basic Salary & Wages":122}},
    # C. Bonus
    {"subq": "C. Bonus",
     "rows": {"Managers":124,"Professional":125,"Technicians & Associate Professionals":126,
              "Clerical Occupations":127,"Operative Workers":128,"Elementary Occupations":129,
              "TOTAL Bonus":130}},
    # D. Others (overtime, COLA, allowance, etc.)
    {"subq": "D. Others (overtime, COLA, allowance, etc.)",
     "rows": {"Managers":132,"Professional":133,"Technicians & Associate Professionals":134,
              "Clerical Occupations":135,"Operative Workers":136,"Elementary Occupations":137,
              "TOTAL Others (overtime, COLA, allowance, etc.)":138}},
    # E. Commissions Paid At Least Once a Month (RM)
    {"subq": "E. Commissions Paid At Least Once a Month (RM)",
     "rows": {"Managers":140,"Professional":141,"Technicians & Associate Professionals":142,
              "Clerical Occupations":143,"Operative Workers":144,"Elementary Occupations":145,
              "TOTAL Commissions Paid At Least Once a Month (RM)":146}},
]

# Q2B (Islamic ops only): fixed positions (single month in col C)
Q2B_ROWS_A = {"Managers":151,"Professional":152,"Technicians & Associate Professionals":153,
              "Clerical Occupations":154,"Operative Workers":155,"Elementary Occupations":156,
              "TOTAL Salary & Wages":157}
Q2B_ROWS_B = {"Managers":159,"Professional":160,"Technicians & Associate Professionals":161,
              "Clerical Occupations":162,"Operative Workers":163,"Elementary Occupations":164,
              "TOTAL Commissions Paid At Least Once a Month (RM)":165}

# ---- Job functions (I..Y) ----
JOBFUNC_COLS = ["I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y"]

# Banking / DFI names
JOBFUNC_BANKING = [
    "Banking Operations","Compliance","Corporate Banking","Credit Management",
    "Digital Banking & Innovation","Finance","Human Resources","Information Technology",
    "Internal Audit","Investment Banking","Legal","Retail Banking","Risk Management",
    "Sales and Marketing","Shariah","Treasury","Other functions"
]

# Insurance / Takaful names (same columns I..Y, names differ)
JOBFUNC_INSURANCE = [
    "Actuarial","Claims","Compliance","Customer Service","Finance",
    "Human Resources","Information Technology","Internal Audit","Investment",
    "Legal","Operations","Product Development","Risk Management",
    "Sales and Marketing","Shariah","Treasury","Other functions"
]

# -------------------------------------------------
# Helpers
# -------------------------------------------------
def _norm(s: object) -> str:
    if s is None: return ""
    s = str(s).replace("&"," and ")
    keep = "abcdefghijklmnopqrstuvwxyz0123456789:+().,%/- "
    s2 = "".join(ch.lower() if ch.lower() in keep else " " for ch in s)
    return re.sub(r"\s+"," ", s2).strip()

def read_cover_meta(wb) -> Tuple[Optional[str], Optional[int], Optional[str]]:
    ent = yr = ql = None
    if "Cover" in wb.sheetnames:
        ws = wb["Cover"]
        try:
            ent = ws[COVER["entity"]].value
            yr  = ws[COVER["year"]].value
            ql  = ws[COVER["quarter"]].value
        except Exception:
            pass
    # gentle fallback
    if not ent or not yr or not ql:
        for s in wb.sheetnames[:3]:
            if s == "Cover": continue
            ws = wb[s]
            for addr, var in (("C6","ent"),("C7","yr"),("C8","ql")):
                try:
                    v = ws[addr].value
                except Exception:
                    v = None
                if var=="ent" and not ent and v: ent=v
                if var=="yr"  and not yr  and v: yr=v
                if var=="ql"  and not ql  and v: ql=v
    try:
        yr = int(str(yr).strip()) if yr is not None else None
    except Exception:
        yr = None
    return (str(ent).strip() if ent else None, yr, str(ql).strip() if ql else None)

def pick_data_sheet(wb) -> str:
    names = { _norm(n): n for n in wb.sheetnames }
    for want in LIKELY_SHEETS:
        key = _norm(want)
        if key in names: return names[key]
    for n in wb.sheetnames:
        if n != "Cover": return n
    return wb.sheetnames[0]

def read_num_cell(ws, r: int, c_letter: str) -> float:
    try:
        v = ws[f"{c_letter}{r}"].value
    except Exception:
        return 0.0
    if v in (None, "", "-", " ", "–"): return 0.0
    try:
        return float(v)
    except Exception:
        s = str(v).replace(",","")
        try:
            return float(s)
        except Exception:
            return 0.0

# -------------------------------------------------
# Q2A – MAIN (fixed rows, no scanning)
# -------------------------------------------------
def extract_q2a_main(ws, entity: str, yr: int, qlabel: str) -> pd.DataFrame:
    months = MONTHS_BY_Q.get(qlabel, [])
    if len(months) != 3:
        return pd.DataFrame()

    out: List[Dict] = []
    for block in Q2A_BLOCKS:
        subq = block["subq"]
        for wc, r in block["rows"].items():
            rec = {
                "entity_name": entity,
                "year": yr,
                "quarter": qlabel,
                "question": "Q2A",
                "subsection": subq,
                "worker_category": wc,
                months[0]: read_num_cell(ws, r, "C"),
                months[1]: read_num_cell(ws, r, "D"),
                months[2]: read_num_cell(ws, r, "E"),
            }
            out.append(rec)
    return pd.DataFrame(out)

# -------------------------------------------------
# Q2A – JOB FUNCTION (Q4 only, fixed rows; two name sets)
# -------------------------------------------------
def extract_q2a_jobfunc_q4(ws, entity: str, yr: int, qlabel: str) -> pd.DataFrame:
    if _norm(qlabel) not in ("q4","quarter 4"):
        return pd.DataFrame()

    # Pick the job-function names from sheet title (Banking/DFI vs Insurance/Takaful)
    sheet_name = ws.title.lower()
    if ("insurance" in sheet_name) or ("takaful" in sheet_name):
        jobfuncs = JOBFUNC_INSURANCE
    else:
        jobfuncs = JOBFUNC_BANKING

    out: List[Dict] = []
    for block in Q2A_BLOCKS:
        subq = block["subq"]
        for wc, r in block["rows"].items():
            for col_letter, jf_name in zip(JOBFUNC_COLS, jobfuncs):
                val = read_num_cell(ws, r, col_letter)
                out.append({
                    "entity_name": entity,
                    "year": yr,
                    "quarter": qlabel,
                    "subsection": subq,
                    "worker_category": wc,
                    "job_function": jf_name,
                    "value": val,
                })
    return pd.DataFrame(out)

# -------------------------------------------------
# Q2B – Islamic ops (Jun/Dec only), include sheet if any FI has data
# -------------------------------------------------
def extract_q2b(ws, entity: str, yr: int, qlabel: str) -> pd.DataFrame:
    qn = _norm(qlabel)
    if qn not in ("q2","quarter 2","q4","quarter 4"):
        return pd.DataFrame()

    month = MONTHS_BY_Q["Q2"][2] if qn in ("q2","quarter 2") else MONTHS_BY_Q["Q4"][2]  # Jun or Dec
    out: List[Dict] = []

    # Subsection A
    for wc, r in Q2B_ROWS_A.items():
        val = read_num_cell(ws, r, "C")
        out.append({
            "entity_name": entity, "year": yr, "quarter": qlabel,
            "question": "Q2B",
            "subsection": "A. Salary & Wages", "worker_category": wc, month: val
        })
    # Subsection B
    for wc, r in Q2B_ROWS_B.items():
        val = read_num_cell(ws, r, "C")
        out.append({
            "entity_name": entity, "year": yr, "quarter": qlabel,
            "question": "Q2B",
            "subsection": "B. Commissions Paid At Least Once a Month (RM)",
            "worker_category": wc, month: val
        })

    df = pd.DataFrame(out)
    # Keep only FIs that actually reported something (any non-zero)
    if df.select_dtypes(include="number").sum().sum() == 0:
        return pd.DataFrame()
    return df

# -------------------------------------------------
# File driver
# -------------------------------------------------
def extract_q2_from_file(path: Path, verbose=False) -> Tuple[pd.DataFrame,pd.DataFrame,pd.DataFrame]:
    try:
        wb = load_workbook(str(path), data_only=True, read_only=True)
    except Exception as e:
        if verbose: print(f"[ERROR] open {path.name}: {e}")
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

    ent, yr, ql = read_cover_meta(wb)
    if not ent or not yr or not ql:
        if verbose: print(f"[WARN] {path.name}: missing cover meta; skip")
        try: wb.close()
        except: pass
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

    ws = wb[pick_data_sheet(wb)]
    a  = extract_q2a_main(ws, ent, yr, ql)
    jf = extract_q2a_jobfunc_q4(ws, ent, yr, ql)
    b  = extract_q2b(ws, ent, yr, ql)

    try: wb.close()
    except: pass
    return (a, jf, b)

# -------------------------------------------------
# CLI (optional; handy for quick checks)
# -------------------------------------------------
def main() -> int:
    ap = argparse.ArgumentParser(description="Extract RLMS Q2 → staging (fixed positions, fast)")
    ap.add_argument("--input", required=True, help="Folder with submissions")
    ap.add_argument("--out", required=True, help="Output staging workbook (.xlsx)")
    ap.add_argument("--limit", type=int, default=None)
    ap.add_argument("--verbose", action="store_true")
    args = ap.parse_args()

    root = Path(args.input)
    if not root.exists():
        print(f"[ERROR] Folder not found: {root}")
        return 2

    files: List[Path] = []
    for ext in ("*.xlsx","*.xlsm"):
        files.extend(p for p in root.rglob(ext) if not p.name.startswith("~$"))
    files.sort()
    if args.limit:
        files = files[:args.limit]
    print(f"[INFO] Files: {len(files)}")

    t0 = time.perf_counter()
    rows_a, rows_jf, rows_b = [], [], []
    for i, p in enumerate(files, 1):
        a, jf, b = extract_q2_from_file(p, verbose=args.verbose)
        if not a.empty:  rows_a.append(a)
        if not jf.empty: rows_jf.append(jf)
        if not b.empty:  rows_b.append(b)
        if args.verbose and i % 25 == 0:
            print(f"  processed {i}/{len(files)}")

    df_a  = pd.concat(rows_a,  ignore_index=True) if rows_a  else pd.DataFrame()
    df_jf = pd.concat(rows_jf, ignore_index=True) if rows_jf else pd.DataFrame()
    df_b  = pd.concat(rows_b,  ignore_index=True) if rows_b  else pd.DataFrame()

    # Sort for readability (and stability)
    def _sort(df: pd.DataFrame) -> pd.DataFrame:
        if df.empty: return df
        sort_cols = [c for c in ["entity_name","year","quarter","subsection","worker_category","job_function"] if c in df.columns]
        mcols = [c for c in ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"] if c in df.columns]
        return df.sort_values(sort_cols + mcols, kind="mergesort").reset_index(drop=True)

    df_a  = _sort(df_a)
    df_jf = _sort(df_jf)
    df_b  = _sort(df_b)

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with pd.ExcelWriter(out_path, engine="openpyxl") as xw:
        if not df_a.empty:
            df_a.to_excel(xw, sheet_name="Q2A_Main", index=False)
        if not df_jf.empty:
            df_jf.to_excel(xw, sheet_name="Q2A_JobFunc_Q4", index=False)
        if not df_b.empty:
            df_b.to_excel(xw, sheet_name="Q2B", index=False)

    print(f"[DONE] {out_path}  "
          f"(Q2A_Main rows={0 if df_a.empty else len(df_a):,}, "
          f"Q2A_JobFunc_Q4 rows={0 if df_jf.empty else len(df_jf):,}, "
          f"Q2B rows={0 if df_b.empty else len(df_b):,})")
    print(f"[TIME] {time.perf_counter()-t0:0.2f}s")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
