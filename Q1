# extract_q1_staging.py
from __future__ import annotations
import argparse, re, time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import pandas as pd
from openpyxl import load_workbook

# =========================
# Config (tune here)
# =========================

# Which sheet names are likely to hold the Q1 tables
LIKELY_DATA_SHEETS = [
    "Banking & DFI", "Banking & DFI ", "Banking & DFI  ",  # common variants
    "Insurance/Takaful", "Insurance & Takaful", "Data"
]

# Cover cells (fallbacks handled automatically)
COVER_CELLS = {"entity": "F6", "year": "F7", "quarter": "F8"}

# Worker categories (exact labels as they appear in col A)
WORKER_CATEGORIES = [
    "Managers",
    "Professional",
    "Technicians & Associate Professionals",
    "Clerical Occupations",
    "Operative Workers",
    "Elementary Occupations",
    "TOTAL Employment",  # we will include totals too
]

# Citizenship block anchors (as they appear in col A)
CITIZENSHIP_ANCHORS = [
    ("A. Malaysian", "Malaysian"),
    ("B (i) Non-Malaysian: Permanent Resident", "Non-Malaysian: PR"),
    ("B (ii) Non-Malaysian: Non-Permanent Resident", "Non-Malaysian: Non-PR"),
]

# Job-function headings (Q4 only). Keep in the same order as columns in the template.
JOB_FUNCTIONS = [
    "Banking Operations", "Compliance", "Corporate Banking", "Credit Management",
    "Digital Banking & Innovation", "Finance", "Human Resources", "Information Technology",
    "Internal Audit", "Investment Banking", "Legal", "Retail Banking", "Risk Management",
    "Sales and Marketing", "Shariah", "Treasury", "Other functions"
]

# Quarter -> Months (labels in staging)
MONTHS_BY_Q = {
    "Quarter 1": ["Jan", "Feb", "Mar"],
    "Quarter 2": ["Apr", "May", "Jun"],
    "Quarter 3": ["Jul", "Aug", "Sep"],
    "Quarter 4": ["Oct", "Nov", "Dec"],
    # In case the file already says Q1..Q4
    "Q1": ["Jan", "Feb", "Mar"],
    "Q2": ["Apr", "May", "Jun"],
    "Q3": ["Jul", "Aug", "Sep"],
    "Q4": ["Oct", "Nov", "Dec"],
}

# In the Q1 tables, the three month columns are the same 3 Excel columns each quarter.
# (Only the header text changes from Jan–Mar to Apr–Jun etc.)
Q1_MONTH_COLS = ["C", "D", "E"]  # three adjacent month columns for the active quarter


# =========================
# Helpers
# =========================

def _norm(s: object) -> str:
    if s is None:
        return ""
    s = str(s)
    s = s.replace("&", " and ")
    keep = "abcdefghijklmnopqrstuvwxyz0123456789()+/.:; -"
    out = "".join(ch.lower() if ch.lower() in keep else " " for ch in s)
    return re.sub(r"\s+", " ", out).strip()

def _equals(a: object, b: str) -> bool:
    return _norm(a) == _norm(b)

def _contains(a: object, b: str) -> bool:
    return _norm(b) in _norm(a)

@dataclass
class CoverMeta:
    entity: Optional[str]
    year: Optional[int]
    quarter_label: Optional[str]

def read_cover_meta(wb) -> CoverMeta:
    ent = yr = ql = None
    # First try explicit Cover sheet
    if "Cover" in wb.sheetnames:
        ws = wb["Cover"]
        try:
            ent = ws[COVER_CELLS["entity"]].value
            yr  = ws[COVER_CELLS["year"]].value
            ql  = ws[COVER_CELLS["quarter"]].value
        except Exception:
            pass
    # Fallback: scan first few sheets for C6:C8 pattern
    if not ent or not yr or not ql:
        for s in wb.sheetnames[:3]:
            if s == "Cover":
                continue
            ws = wb[s]
            try:
                ent = ent or ws["C6"].value
                yr  = yr  or ws["C7"].value
                ql  = ql  or ws["C8"].value
            except Exception:
                continue
    try:
        yr = int(str(yr).strip()) if yr is not None else None
    except Exception:
        yr = None
    ql = str(ql).strip() if ql else None
    ent = str(ent).strip() if ent else None
    return CoverMeta(ent, yr, ql)

def pick_data_sheet(wb) -> str:
    names_norm = { _norm(s): s for s in wb.sheetnames }
    for want in LIKELY_DATA_SHEETS:
        key = _norm(want)
        if key in names_norm:
            return names_norm[key]
    # otherwise first non-cover
    for s in wb.sheetnames:
        if s != "Cover": return s
    return wb.sheetnames[0]

def read_number(ws, addr: str) -> float:
    try:
        v = ws[addr].value
    except Exception:
        return 0.0
    if v in (None, "", "-"):
        return 0.0
    try:
        return float(v)
    except Exception:
        try:
            return float(str(v).replace(",", ""))
        except Exception:
            return 0.0

def find_row(ws, target_text: str, col: int = 1) -> Optional[int]:
    tgt = _norm(target_text)
    for r in range(1, ws.max_row + 1):
        if _norm(ws.cell(r, col).value) == tgt:
            return r
    return None

def find_nearest_row_after(ws, anchor_text: str, probe_text: str, col: int = 1) -> Optional[int]:
    """Find the first row *after* anchor_text where A == probe_text."""
    anchor = find_row(ws, anchor_text, col=col)
    if anchor is None:
        return None
    tgt = _norm(probe_text)
    for r in range(anchor + 1, ws.max_row + 1):
        if _norm(ws.cell(r, col).value) == tgt:
            return r
    return None

def find_column_headers(ws, header_row: int, wanted: List[str]) -> Dict[str, int]:
    """Return mapping of wanted header text -> 1-based column index when they appear in the header_row."""
    res: Dict[str, int] = {}
    for c in range(1, ws.max_column + 1):
        txt = ws.cell(header_row, c).value
        for want in wanted:
            if _equals(txt, want):
                res[want] = c
    return res


# =========================
# Extraction – Q1A (main)
# =========================

def extract_q1a_main(ws, meta: CoverMeta) -> pd.DataFrame:
    """
    Extract the 'Q1A' monthly totals for each Worker Category × Citizenship block.
    Works for all quarters (Q1..Q4). Month values are always in 3 adjacent columns (C/D/E).
    """
    months = MONTHS_BY_Q.get(meta.quarter_label or "", [])
    if len(months) != 3:
        return pd.DataFrame()

    # Locate the overall anchor for the Employment table
    anchor = find_row(ws, "Employment = A + B(i) + B(ii)")
    if anchor is None:
        return pd.DataFrame()

    out_rows: List[Dict] = []

    # Process each citizenship block in order
    for block_anchor, citizen_label in CITIZENSHIP_ANCHORS:
        # The block's first worker-category row is the first category we can find after the anchor
        start_r = find_nearest_row_after(ws, block_anchor, WORKER_CATEGORIES[0])  # "Managers"
        if start_r is None:
            # Sometimes there is an empty block (e.g., non-applicable); skip gracefully
            continue

        # We read rows until we've passed all expected categories (including TOTAL Employment)
        found = 0
        r = start_r
        while r <= ws.max_row and found < len(WORKER_CATEGORIES):
            label = ws.cell(r, 1).value
            if _norm(label) in [_norm(w) for w in WORKER_CATEGORIES]:
                wc = str(label).strip()
                # three month columns (fixed physical columns C/D/E)
                v1 = read_number(ws, f"{Q1_MONTH_COLS[0]}{r}")
                v2 = read_number(ws, f"{Q1_MONTH_COLS[1]}{r}")
                v3 = read_number(ws, f"{Q1_MONTH_COLS[2]}{r}")

                rec = {
                    "entity_name": meta.entity,
                    "year": meta.year,
                    "quarter": meta.quarter_label,
                    "question": "Q1A",
                    "citizenship": citizen_label,
                    "worker_category": wc,
                    months[0]: v1,
                    months[1]: v2,
                    months[2]: v3,
                }
                out_rows.append(rec)
                found += 1
            r += 1

    return pd.DataFrame(out_rows)


# =========================
# Extraction – Q1A (Q4 job functions)
# =========================

def extract_q1a_jobfunc_q4(ws, meta: CoverMeta) -> pd.DataFrame:
    """
    For Quarter 4 only: capture job-function breakdown by worker category.
    We assume the job functions appear as a header row with those labels across columns.
    """
    if (meta.quarter_label or "").upper() not in ("Q4", "QUARTER 4"):
        return pd.DataFrame()

    # Find the header row that contains most job-function names
    header_row_idx = None
    best_count = 0
    for r in range(1, ws.max_row + 1):
        row_texts = [_norm(ws.cell(r, c).value) for c in range(1, ws.max_column + 1)]
        hits = sum(1 for jf in JOB_FUNCTIONS if _norm(jf) in row_texts)
        if hits > best_count:
            best_count, header_row_idx = hits, r
        if hits >= max(6, len(JOB_FUNCTIONS) // 2):
            break  # good enough

    if not header_row_idx:
        return pd.DataFrame()

    # Map job functions -> column indices
    jf_cols: Dict[str, int] = {}
    for c in range(1, ws.max_column + 1):
        txt = ws.cell(header_row_idx, c).value
        for jf in JOB_FUNCTIONS:
            if _equals(txt, jf) and jf not in jf_cols:
                jf_cols[jf] = c

    if not jf_cols:
        return pd.DataFrame()

    # Now locate the worker-category rows under this header region.
    # We’ll scan downward from header_row_idx+1 and capture any line that matches a worker category.
    out_rows: List[Dict] = []
    end_scan = min(ws.max_row, header_row_idx + 100)  # limit the scan window

    for r in range(header_row_idx + 1, end_scan + 1):
        label = ws.cell(r, 1).value
        if _norm(label) in [_norm(w) for w in WORKER_CATEGORIES]:
            wc = str(label).strip()
            for jf, cidx in jf_cols.items():
                val = ws.cell(r, cidx).value
                try:
                    v = 0.0 if val in (None, "", "-") else float(str(val).replace(",", ""))
                except Exception:
                    v = 0.0
                out_rows.append({
                    "entity_name": meta.entity,
                    "year": meta.year,
                    "quarter": meta.quarter_label,
                    "question": "Q1A_JobFunction",
                    "worker_category": wc,
                    "job_function": jf,
                    "value": v,
                })

    return pd.DataFrame(out_rows)


# =========================
# Extraction – Q1B (Islamic ops, Q2 & Q4)
# =========================

def extract_q1b(ws, meta: CoverMeta, entity_name: str) -> pd.DataFrame:
    """
    Islamic Banking Scheme Operations only, reported in Q2 and Q4.
    Structure mirrors Q1A main (citizenship blocks), but only one month column in Q2 (Jun) and Q4 (Dec).
    In the template the input area is the same C/D/E columns, but only the last month is relevant (Jun or Dec).
    We’ll still expose 3 month fields using MONTHS_BY_Q for consistency.
    """
    q = (meta.quarter_label or "").strip()
    if q not in ("Quarter 2", "Quarter 4", "Q2", "Q4"):
        return pd.DataFrame()

    months = MONTHS_BY_Q.get(q, [])
    if not months:
        return pd.DataFrame()

    # Anchor "Question 1B" then "Employment = A + B(i) + B(ii)" below it
    anchor_q1b = find_row(ws, "Question 1B:")
    if anchor_q1b is None:
        return pd.DataFrame()
    anchor_emp = find_row(ws, "Employment = A + B(i) + B(ii)")
    if anchor_emp is None or anchor_emp < anchor_q1b:
        # If a second employment table appears below Question 1B header
        anchor_emp = find_nearest_row_after(ws, "Question 1B:", "Employment = A + B(i) + B(ii)")
        # The helper above is for exact label row; make a looser fallback:
        if anchor_emp is None:
            # attempt linear search for exact row under 1B header
            for r in range(anchor_q1b, min(ws.max_row, anchor_q1b + 300)):
                if _equals(ws.cell(r, 1).value, "Employment = A + B(i) + B(ii)"):
                    anchor_emp = r
                    break
    if anchor_emp is None:
        return pd.DataFrame()

    out_rows: List[Dict] = []
    for block_anchor, citizen_label in CITIZENSHIP_ANCHORS:
        start_r = find_nearest_row_after(ws, block_anchor, WORKER_CATEGORIES[0])  # "Managers"
        if start_r is None:
            continue
        found = 0
        r = start_r
        while r <= ws.max_row and found < len(WORKER_CATEGORIES):
            label = ws.cell(r, 1).value
            if _norm(label) in [_norm(w) for w in WORKER_CATEGORIES]:
                wc = str(label).strip()
                # In practice only M3 (Jun for Q2, Dec for Q4) is required, but we’ll read all three for completeness.
                v1 = read_number(ws, f"{Q1_MONTH_COLS[0]}{r}")
                v2 = read_number(ws, f"{Q1_MONTH_COLS[1]}{r}")
                v3 = read_number(ws, f"{Q1_MONTH_COLS[2]}{r}")

                out_rows.append({
                    "entity_name": entity_name,
                    "year": meta.year,
                    "quarter": q,
                    "question": "Q1B",
                    "citizenship": citizen_label,
                    "worker_category": wc,
                    months[0]: v1 if len(months) > 0 else 0.0,
                    months[1]: v2 if len(months) > 1 else 0.0,
                    months[2]: v3 if len(months) > 2 else 0.0,
                })
                found += 1
            r += 1

    return pd.DataFrame(out_rows)


# =========================
# File-level driver
# =========================

def extract_q1_from_file(path: Path, verbose: bool = False) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """Return (Q1A_main, Q1A_jobfunc_Q4, Q1B) as DataFrames (any may be empty)."""
    try:
        wb = load_workbook(str(path), data_only=True, read_only=True)
    except Exception as e:
        if verbose:
            print(f"[ERROR] open {path.name}: {e}")
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

    meta = read_cover_meta(wb)
    if not meta.entity or not meta.year or not meta.quarter_label:
        if verbose:
            print(f"[WARN] {path.name}: missing cover meta; skipping.")
        try: wb.close()
        except Exception: pass
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

    sheet_name = pick_data_sheet(wb)
    ws = wb[sheet_name]

    q1a_main = extract_q1a_main(ws, meta)
    q1a_jobf = extract_q1a_jobfunc_q4(ws, meta)
    q1b      = extract_q1b(ws, meta, meta.entity)

    try: wb.close()
    except Exception: pass

    # Add a source column for traceability (optional)
    for df in (q1a_main, q1a_jobf, q1b):
        if not df.empty:
            df["source_file"] = path.name
    return (q1a_main, q1a_jobf, q1b)


# =========================
# CLI
# =========================

def main() -> int:
    ap = argparse.ArgumentParser(description="Extract RLMS Question 1 (A & B) into staging workbook.")
    ap.add_argument("--inputs", required=True, help="Folder containing submissions (.xlsx/.xlsm)")
    ap.add_argument("--out", required=True, help="Output staging workbook (.xlsx)")
    ap.add_argument("--limit", type=int, default=None, help="Limit files (debug)")
    ap.add_argument("--verbose", action="store_true")
    args = ap.parse_args()

    root = Path(args.inputs)
    if not root.exists():
        print(f"[ERROR] Folder not found: {root}")
        return 2

    # Collect files
    files: List[Path] = []
    for ext in ("*.xlsx", "*.xlsm"):
        files.extend(p for p in root.rglob(ext) if not p.name.startswith("~$"))
    files.sort()
    if args.limit:
        files = files[:args.limit]
    print(f"[INFO] Files to scan: {len(files)}")

    t0 = time.perf_counter()
    rows_q1a, rows_jobf, rows_q1b = [], [], []

    for i, p in enumerate(files, 1):
        a, jf, b = extract_q1_from_file(p, verbose=args.verbose)
        if not a.empty:  rows_q1a.append(a)
        if not jf.empty: rows_jobf.append(jf)
        if not b.empty:  rows_q1b.append(b)
        if args.verbose and i % 25 == 0:
            print(f"  processed {i}/{len(files)}")

    df_q1a = pd.concat(rows_q1a, ignore_index=True) if rows_q1a else pd.DataFrame()
    df_job = pd.concat(rows_jobf, ignore_index=True) if rows_jobf else pd.DataFrame()
    df_q1b = pd.concat(rows_q1b, ignore_index=True) if rows_q1b else pd.DataFrame()

    # Sort for readability
    def _sort(df: pd.DataFrame) -> pd.DataFrame:
        order_cols = [c for c in ["entity_name","year","quarter","citizenship","worker_category","job_function"] if c in df.columns]
        month_cols = [c for c in ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"] if c in df.columns]
        return df.sort_values(order_cols + month_cols, kind="mergesort").reset_index(drop=True) if not df.empty else df

    df_q1a = _sort(df_q1a)
    df_job = _sort(df_job)
    df_q1b = _sort(df_q1b)

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with pd.ExcelWriter(out_path, engine="openpyxl") as xw:
        if not df_q1a.empty: df_q1a.to_excel(xw, index=False, sheet_name="Q1A_Main")
        if not df_job.empty: df_job.to_excel(xw, index=False, sheet_name="Q1A_JobFunc_Q4")
        if not df_q1b.empty: df_q1b.to_excel(xw, index=False, sheet_name="Q1B")
    print(f"[DONE] Wrote staging → {out_path}")
    print(f"[TIMER] {time.perf_counter() - t0:0.2f}s")

    return 0

if __name__ == "__main__":
    raise SystemExit(main())
