# qc_common.py

from **future** import annotations

from typing import Dict, List, Optional, Sequence, Tuple
from datetime import datetime

import pandas as pd
import numpy as np
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.formatting.rule import FormulaRule

# =============== CONFIGURATION DICTIONARIES ===============

# Entity type hierarchy - customize based on your jurisdiction

ROLLUPS: Dict[str, List[str]] = {
“All FI”: [“Commercial Bank”, “Islamic Bank”, “DFI”, “Insurance”, “Takaful”],
“Banking Institution”: [“Commercial Bank”, “Islamic Bank”],
“Insurance/Takaful”: [“Insurance”, “Takaful”],
}

ROLLUP_ORDER: List[str] = [
“All FI”,
“Banking Institution”,
“Insurance/Takaful”,
]

# Map institution names to types (uppercase keys for case-insensitive matching)

# ADD YOUR INSTITUTIONS HERE:

ENTITY_TO_TYPE: Dict[str, str] = {
# Commercial Banks
“MAYBANK”: “Commercial Bank”,
“CIMB BANK”: “Commercial Bank”,
“PUBLIC BANK”: “Commercial Bank”,
“RHB BANK”: “Commercial Bank”,
“HONG LEONG BANK”: “Commercial Bank”,
“AMBANK”: “Commercial Bank”,
“UOB MALAYSIA”: “Commercial Bank”,
“OCBC BANK”: “Commercial Bank”,
“HSBC BANK MALAYSIA”: “Commercial Bank”,
“STANDARD CHARTERED BANK MALAYSIA”: “Commercial Bank”,

```
# Islamic Banks
"BANK ISLAM MALAYSIA": "Islamic Bank",
"BANK MUAMALAT MALAYSIA": "Islamic Bank",
"CIMB ISLAMIC BANK": "Islamic Bank",
"MAYBANK ISLAMIC": "Islamic Bank",
"PUBLIC ISLAMIC BANK": "Islamic Bank",
"RHB ISLAMIC BANK": "Islamic Bank",
"HONG LEONG ISLAMIC BANK": "Islamic Bank",
"AMBANK ISLAMIC": "Islamic Bank",
"AFFIN ISLAMIC BANK": "Islamic Bank",
"ALLIANCE ISLAMIC BANK": "Islamic Bank",
"OCBC AL-AMIN BANK": "Islamic Bank",
"STANDARD CHARTERED SAADIQ": "Islamic Bank",
"HSBC AMANAH MALAYSIA": "Islamic Bank",
"Kuwait FINANCE HOUSE": "Islamic Bank",
"AL RAJHI BANKING": "Islamic Bank",

# Development Financial Institutions
"BANK PEMBANGUNAN MALAYSIA": "DFI",
"BANK PERUSAHAAN KECIL & SEDERHANA MALAYSIA": "DFI",
"BANK SIMPANAN NASIONAL": "DFI",
"BANK KERJASAMA RAKYAT MALAYSIA": "DFI",
"EXPORT-IMPORT BANK OF MALAYSIA": "DFI",

# Insurance Companies
"ALLIANZ GENERAL INSURANCE": "Insurance",
"AXA AFFIN GENERAL INSURANCE": "Insurance",
"ZURICH GENERAL INSURANCE MALAYSIA": "Insurance",
"TOKIO MARINE INSURANS": "Insurance",
"MSIG INSURANCE": "Insurance",
"PACIFIC & ORIENT INSURANCE": "Insurance",
"LIBERTY INSURANCE": "Insurance",
"PROGRESSIVE INSURANCE": "Insurance",

# Takaful Operators
"TAKAFUL MALAYSIA": "Takaful",
"ETIQA TAKAFUL": "Takaful",
"PRUDENTIAL BSN TAKAFUL": "Takaful",
"GREAT EASTERN TAKAFUL": "Takaful",
"ZURICH TAKAFUL MALAYSIA": "Takaful",
"TAKAFUL IKHLAS": "Takaful",
"SUN TAKAFUL MALAYSIA": "Takaful",
"HONG LEONG MSIG TAKAFUL": "Takaful",
```

}

# Helper function to add entities dynamically if needed

def add_entity_mapping(entity_name: str, entity_type: str) -> None:
“”“Add a new entity mapping at runtime.”””
ENTITY_TO_TYPE[entity_name.upper().strip()] = entity_type

# ===========================================================

# ========= Quarter / Month Configuration =========

QMAP = {
“Quarter 1”: “Q1”, “Quarter 2”: “Q2”, “Quarter 3”: “Q3”, “Quarter 4”: “Q4”,
“Q1”: “Q1”, “Q2”: “Q2”, “Q3”: “Q3”, “Q4”: “Q4”,
}

Q_TO_MONTHS = {
“Q1”: [“Jan”, “Feb”, “Mar”],
“Q2”: [“Apr”, “May”, “Jun”],
“Q3”: [“Jul”, “Aug”, “Sep”],
“Q4”: [“Oct”, “Nov”, “Dec”],
}

MONTHS_FULL = [“Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”,
“Jul”, “Aug”, “Sep”, “Oct”, “Nov”, “Dec”]

Q_ORDER = {“Q1”: 1, “Q2”: 2, “Q3”: 3, “Q4”: 4}

def normalize_quarter(q: str) -> str:
“”“Convert quarter string to standard format (Q1-Q4).”””
return QMAP.get(str(q).strip(), str(q).strip())

def normalize_quarter_label(qseries: pd.Series) -> str:
“”“Pick the ‘latest’ quarter label from a series.”””
if qseries is None or qseries.empty:
return “Q1”
qs = qseries.astype(str).map(normalize_quarter)
valid_qs = qs.map(Q_ORDER.get).dropna()
if valid_qs.empty:
return “Q1”
return qs.iloc[valid_qs.idxmax()]

def months_up_to(q_label: str) -> List[str]:
“”“Return all months from Q1 start up to (and including) specified quarter.”””
q = normalize_quarter(q_label)
out: List[str] = []
for qq in [“Q1”, “Q2”, “Q3”, “Q4”]:
out.extend(Q_TO_MONTHS[qq])
if qq == q:
break
return out

# ========= Styling Configuration =========

FILL_Q1 = PatternFill(start_color=“E8F3FF”, end_color=“E8F3FF”, fill_type=“solid”)
FILL_Q2 = PatternFill(start_color=“E8F8E8”, end_color=“E8F8E8”, fill_type=“solid”)
FILL_Q3 = PatternFill(start_color=“FFF3E0”, end_color=“FFF3E0”, fill_type=“solid”)
FILL_Q4 = PatternFill(start_color=“F3E5F5”, end_color=“F3E5F5”, fill_type=“solid”)
FILL_RAW = PatternFill(start_color=“E6EEF7”, end_color=“E6EEF7”, fill_type=“solid”)
FILL_TOTAL_ROW = PatternFill(start_color=“F7F7F7”, end_color=“F7F7F7”, fill_type=“solid”)
FILL_RED = PatternFill(start_color=“FFE5E5”, end_color=“FFE5E5”, fill_type=“solid”)
FILL_YELLOW = PatternFill(start_color=“FFF7CC”, end_color=“FFF7CC”, fill_type=“solid”)
FILL_ROLLUP = PatternFill(start_color=“E8E8E8”, end_color=“E8E8E8”, fill_type=“solid”)

QFILL = {“Q1”: FILL_Q1, “Q2”: FILL_Q2, “Q3”: FILL_Q3, “Q4”: FILL_Q4}

# ========= Entity Type and Rollups =========

def attach_entity_type(df: pd.DataFrame, entity_col: str = “entity_name”) -> pd.DataFrame:
“”“Add ‘entity_type’ column using ENTITY_TO_TYPE map (case-insensitive).”””
if df.empty:
return df.copy()

```
out = df.copy()
out["_ENT_UP"] = out[entity_col].astype(str).str.upper().str.strip()
out["entity_type"] = out["_ENT_UP"].map(ENTITY_TO_TYPE).fillna("Unknown")
out.drop(columns=["_ENT_UP"], inplace=True)
return out
```

def expand_rollups(
df: pd.DataFrame,
numeric_cols: Optional[Sequence[str]] = None,
entity_col: str = “entity_name”,
entity_type_col: str = “entity_type”,
) -> pd.DataFrame:
“””
Create rollup rows by summing numeric columns across entity types.
Returns dataframe with rollup rows marked with is_rollup=True.
“””
if df.empty:
return df

```
df = df.copy()
df["is_rollup"] = False

base_cols = list(df.columns)
if numeric_cols is None:
    numeric_cols = df.select_dtypes(include="number").columns.tolist()

# Group-by columns = all non-numeric, non-entity columns
gcols = [
    c for c in base_cols 
    if c not in set(numeric_cols) | {entity_col, entity_type_col, "is_rollup"}
]

out = [df]
for roll_name, members in ROLLUPS.items():
    sub = df[df[entity_type_col].isin(members)]
    if sub.empty:
        continue
    
    agg = sub.groupby(gcols, dropna=False)[list(numeric_cols)].sum(min_count=1).reset_index()
    agg[entity_col] = roll_name
    agg[entity_type_col] = roll_name
    agg["is_rollup"] = True
    out.append(agg)

return pd.concat(out, ignore_index=True)
```

# ========= Calculation Functions (All in Pandas) =========

def calculate_monthly_changes(df: pd.DataFrame, month_cols: List[str]) -> pd.DataFrame:
“””
Calculate month-over-month differences and percentages.
Returns df with added Diff and MoM columns.
“””
df = df.copy()

```
for i, m in enumerate(MONTHS_FULL):
    if m not in month_cols or i == 0:
        continue
    
    prev = MONTHS_FULL[i - 1]
    if prev not in month_cols:
        continue
    
    # Difference
    diff_col = f"Diff {m}"
    df[diff_col] = df[m] - df[prev]
    
    # MoM percentage
    mom_col = f"MoM {m}"
    df[mom_col] = np.where(
        (df[m] == 0) & (df[prev] == 0),
        0.0,
        np.where(
            (df[m] != 0) & (df[prev] == 0),
            np.nan,  # Will display as "N/A"
            (df[m] - df[prev]) / df[prev]
        )
    )

return df
```

def calculate_quarterly_sums(df: pd.DataFrame, month_cols: List[str]) -> pd.DataFrame:
“””
Calculate quarterly sums from monthly data.
Returns df with added Q1-Q4 columns.
“””
df = df.copy()

```
for qh in ["Q1", "Q2", "Q3", "Q4"]:
    q_months = [m for m in Q_TO_MONTHS[qh] if m in month_cols]
    if q_months:
        df[qh] = df[q_months].sum(axis=1, min_count=1)

return df
```

def calculate_quarterly_changes(df: pd.DataFrame, q_cols: List[str]) -> pd.DataFrame:
“””
Calculate quarter-over-quarter differences and percentages.
Returns df with added Diff Qx and %Diff Qx columns.
“””
df = df.copy()

```
for i, qh in enumerate(q_cols):
    if i == 0:
        continue
    
    prev_q = q_cols[i - 1]
    
    # Difference
    diff_col = f"Diff {qh}"
    df[diff_col] = df[qh] - df[prev_q]
    
    # Percentage
    pct_col = f"%Diff {qh}"
    df[pct_col] = np.where(
        (df[qh] == 0) & (df[prev_q] == 0),
        0.0,
        np.where(
            (df[qh] != 0) & (df[prev_q] == 0),
            np.nan,
            (df[qh] - df[prev_q]) / df[prev_q]
        )
    )

return df
```

def calculate_yoy(
df: pd.DataFrame,
prior_df: pd.DataFrame,
key_cols: List[str],
q_cols: List[str]
) -> pd.DataFrame:
“””
Calculate year-over-year changes using prior year data.
Returns df with added Prior Qx and YoY Qx columns.
“””
if prior_df is None or prior_df.empty:
for qh in q_cols:
df[f”Prior {qh}”] = np.nan
df[f”YoY {qh}”] = np.nan
return df

```
df = df.copy()
prior_df = prior_df.copy()

# Create merge key
df["_merge_key"] = df[key_cols].astype(str).agg("|".join, axis=1)
prior_df["_merge_key"] = prior_df[key_cols].astype(str).agg("|".join, axis=1)

for qh in q_cols:
    if qh not in prior_df.columns:
        df[f"Prior {qh}"] = np.nan
        df[f"YoY {qh}"] = np.nan
        continue
    
    # Merge prior values
    prior_lookup = prior_df[["_merge_key", qh]].rename(columns={qh: f"Prior {qh}"})
    df = df.merge(prior_lookup, on="_merge_key", how="left")
    
    # Calculate YoY
    prior_col = f"Prior {qh}"
    yoy_col = f"YoY {qh}"
    
    df[yoy_col] = np.where(
        df[prior_col].isna(),
        np.nan,
        np.where(
            (df[qh] == 0) & (df[prior_col] == 0),
            0.0,
            np.where(
                (df[qh] != 0) & (df[prior_col] == 0),
                np.nan,
                (df[qh] - df[prior_col]) / df[prior_col]
            )
        )
    )

df.drop(columns=["_merge_key"], inplace=True)
return df
```

def identify_anomalies(
df: pd.DataFrame,
pct_cols: List[str],
diff_cols: List[str],
pct_threshold: float = 0.25,
abs_cutoff: float = 50.0
) -> pd.DataFrame:
“””
Add columns flagging red (large change) or yellow (moderate change) anomalies.
Returns df with added flag columns.
“””
df = df.copy()

```
for pct_col in pct_cols:
    # Find corresponding diff column
    suffix = pct_col.replace("MoM ", "").replace("%Diff ", "").replace("YoY ", "")
    diff_col = None
    for dc in diff_cols:
        if suffix in dc:
            diff_col = dc
            break
    
    if diff_col is None:
        continue
    
    flag_col = f"_flag_{pct_col}"
    
    df[flag_col] = np.where(
        df[pct_col].notna() & (np.abs(df[pct_col]) >= pct_threshold) & (np.abs(df[diff_col]) >= abs_cutoff),
        "RED",
        np.where(
            df[pct_col].notna() & (np.abs(df[pct_col]) >= pct_threshold) & (np.abs(df[diff_col]) < abs_cutoff),
            "YELLOW",
            None
        )
    )

return df
```

# ========= Workbook Utilities =========

def new_empty_workbook() -> Workbook:
“”“Create a new empty workbook.”””
return Workbook()

def append_about_sheet_last(
wb: Workbook,
title: str,
year: int,
current_q: str
) -> None:
“”“Add or replace an ‘About’ sheet with metadata.”””
if “About” in wb.sheetnames:
del wb[“About”]

```
ws = wb.create_sheet("About")
ws["A1"] = title
ws["A2"] = "Year"
ws["B2"] = year
ws["A3"] = "Up to Quarter"
ws["B3"] = normalize_quarter(current_q)
ws["A4"] = "Generated at"
ws["B4"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
```

# ========= Main Writer Function =========

def write_qc_sheet(
wb: Workbook,
sheet_name: str,
stage_df: pd.DataFrame,
*,
include_job_function: bool,
months_to_show: Sequence[str],
current_q: str,
year: int,
prior_df: Optional[pd.DataFrame],
mom_pct_threshold: float = 0.25,
qoq_pct_threshold: float = 0.25,
yoy_pct_threshold: float = 0.25,
abs_cutoff: float = 50.0,
) -> None:
“””
Create a QC sheet with all calculations done in pandas (no Excel formulas).
“””
qlbl = normalize_quarter(current_q)
months_to_show = [m for m in months_to_show if m in MONTHS_FULL]

```
# Prepare data
df = stage_df.copy()
if "quarter" in df.columns:
    df["quarter"] = df["quarter"].astype(str).map(normalize_quarter)
df = attach_entity_type(df, "entity_name")

# Value-only mode check
value_only_mode = (
    include_job_function and 
    not months_to_show and 
    "value" in df.columns
)

# Synthetic quarters for Jun/Dec-only sheets
if not value_only_mode and set(months_to_show) <= {"Jun", "Dec"}:
    if "Jun" in months_to_show:
        df["Q2"] = df.get("Jun", 0)
    if "Dec" in months_to_show:
        df["Q4"] = df.get("Dec", 0)

# Define dimension columns
dims = ["entity_type", "entity_name"]
if "subquestion" in df.columns:
    dims.append("subquestion")
if "worker_category" in df.columns:
    dims.append("worker_category")
if include_job_function and "job_function" in df.columns:
    dims.append("job_function")

# Numeric columns
num_cols: List[str] = []
if value_only_mode:
    num_cols = ["value"]
    df.rename(columns={"value": "Q4"}, inplace=True)
    q_cols = ["Q4"]
else:
    num_cols = [c for c in months_to_show if c in df.columns]
    
    # Calculate quarterly sums
    df = calculate_quarterly_sums(df, num_cols)
    q_cols = [q for q in ["Q1", "Q2", "Q3", "Q4"] if q in df.columns]
    
    # Calculate monthly changes
    df = calculate_monthly_changes(df, num_cols)
    
    # Calculate quarterly changes
    df = calculate_quarterly_changes(df, q_cols)

# Add rollups
all_numeric = [c for c in df.columns if df[c].dtype in ['int64', 'float64']]
df = expand_rollups(df, numeric_cols=all_numeric)

# Prepare prior data for YoY
if prior_df is not None and not prior_df.empty:
    prior_df = prior_df.copy()
    prior_df = attach_entity_type(prior_df, "entity_name")
    
    if value_only_mode:
        prior_df["Q4"] = prior_df.get("value", 0)
    else:
        prior_df = calculate_quarterly_sums(prior_df, [m for m in months_to_show if m in prior_df.columns])
    
    # Aggregate prior by dimensions
    prior_numeric = [c for c in prior_df.columns if prior_df[c].dtype in ['int64', 'float64']]
    prior_dims = [d for d in dims if d in prior_df.columns]
    prior_df = prior_df.groupby(prior_dims, dropna=False)[prior_numeric].sum(min_count=1).reset_index()
    
    # Calculate YoY
    merge_keys = [d for d in dims if d in df.columns]
    df = calculate_yoy(df, prior_df, merge_keys, q_cols)

# Identify anomalies
pct_cols = [c for c in df.columns if c.startswith("MoM ") or c.startswith("%Diff ") or c.startswith("YoY ")]
diff_cols = [c for c in df.columns if c.startswith("Diff ")]
df = identify_anomalies(df, pct_cols, diff_cols, mom_pct_threshold, abs_cutoff)

# Sort rows
roll_rank = {n: i for i, n in enumerate(ROLLUP_ORDER)}
df["_erank"] = df["entity_type"].map(lambda x: roll_rank.get(x, 10_000))

if "worker_category" in df.columns:
    wc_order = {
        "Managers": 0, "Professional": 1,
        "Technicians & Associate Professionals": 2,
        "Clerical Occupations": 3, "Operative Workers": 4,
        "Elementary Occupations": 5, "TOTAL": 6, "TOTAL Employment": 6
    }
    df["_wcrank"] = df["worker_category"].map(lambda x: wc_order.get(str(x), 99))
else:
    df["_wcrank"] = 99

sort_cols = ["_erank", "entity_type"]
if "subquestion" in df.columns:
    sort_cols.append("subquestion")
sort_cols.extend(["_wcrank", "entity_name"])
if "job_function" in df.columns:
    sort_cols.append("job_function")

df = df.sort_values(sort_cols, kind="mergesort")
df.drop(columns=["_erank", "_wcrank"], errors="ignore", inplace=True)

# Build headers
base_headers = ["Entity Type", "Institution"]
if "subquestion" in df.columns:
    base_headers.append("Subquestion")
if "worker_category" in df.columns:
    base_headers.append("Worker Category")
if include_job_function and "job_function" in df.columns:
    base_headers.append("Job Function")

# Build column order
display_cols = base_headers[:]

# Add monthly columns
if not value_only_mode and months_to_show:
    display_cols.extend(months_to_show)
    display_cols.append(" ")  # spacer
    
    # Diffs
    for i, m in enumerate(MONTHS_FULL):
        if m in months_to_show and i > 0:
            prev = MONTHS_FULL[i - 1]
            if prev in months_to_show and f"Diff {m}" in df.columns:
                display_cols.append(f"Diff {m}")
    if any(c.startswith("Diff ") and c in df.columns for c in display_cols):
        display_cols.append("  ")  # spacer
    
    # MoM%
    for i, m in enumerate(MONTHS_FULL):
        if m in months_to_show and i > 0:
            prev = MONTHS_FULL[i - 1]
            if prev in months_to_show and f"MoM {m}" in df.columns:
                display_cols.append(f"MoM {m}")
    if any(c.startswith("MoM ") and c in df.columns for c in display_cols):
        display_cols.append("   ")  # spacer

# Add quarterly columns
for q in q_cols:
    if q in df.columns:
        display_cols.append(q)

# QoQ
for i, q in enumerate(q_cols):
    if i > 0:
        if f"Diff {q}" in df.columns:
            display_cols.append(f"Diff {q}")
        if f"%Diff {q}" in df.columns:
            display_cols.append(f"%Diff {q}")
if any(c.startswith("Diff Q") or c.startswith("%Diff") for c in display_cols):
    display_cols.append("    ")  # spacer

# YoY
for q in q_cols:
    if f"Prior {q}" in df.columns:
        display_cols.append(f"Prior {q}")
for q in q_cols:
    if f"YoY {q}" in df.columns:
        display_cols.append(f"YoY {q}")

# Map display headers to dataframe columns
header_to_col = {
    "Entity Type": "entity_type",
    "Institution": "entity_name",
    "Subquestion": "subquestion",
    "Worker Category": "worker_category",
    "Job Function": "job_function"
}

# Write to Excel
if sheet_name in wb.sheetnames:
    del wb[sheet_name]
ws = wb.create_sheet(sheet_name)

banner_row = 7
header_row = 8
bold = Font(bold=True)
center = Alignment(horizontal="center", vertical="center")

# Write headers
for idx, h in enumerate(display_cols, start=1):
    cell = ws.cell(header_row, idx, h)
    cell.font = bold
    if h in months_to_show:
        cell.fill = FILL_RAW

col_index = {h: i + 1 for i, h in enumerate(display_cols)}

# Write data
first_data_row = header_row + 1
for _, row in df.iterrows():
    row_data = []
    is_rollup_row = row.get("is_rollup", False)
    
    for h in display_cols:
        if h in header_to_col:
            col_name = header_to_col[h]
            val = row.get(col_name, "")
        elif h in df.columns:
            val = row.get(h, "")
            # Convert NaN to "N/A" for percentages
            if pd.isna(val) and (h.startswith("MoM ") or h.startswith("%Diff ") or h.startswith("YoY ")):
                val = "N/A"
        else:
            val = ""  # spacer
        
        row_data.append(val)
    
    ws.append(row_data)
    
    # Highlight rollup rows
    if is_rollup_row:
        row_idx = ws.max_row
        for col_idx in range(1, len(display_cols) + 1):
            ws.cell(row_idx, col_idx).fill = FILL_ROLLUP
            ws.cell(row_idx, col_idx).font = Font(bold=True)

last_data_row = first_data_row + len(df) - 1

# Apply number formats
for h in display_cols:
    if h not in col_index:
        continue
    col_idx = col_index[h]
    
    if h.startswith("MoM ") or h.startswith("%Diff ") or h.startswith("YoY "):
        for r in range(first_data_row, last_data_row + 1):
            ws.cell(r, col_idx).number_format = "0.0%"
    elif h in months_to_show or h in q_cols or h.startswith("Diff ") or h.startswith("Prior "):
        for r in range(first_data_row, last_data_row + 1):
            ws.cell(r, col_idx).number_format = "#,##0"

# Apply conditional formatting based on flags
for h in [c for c in display_cols if c.startswith("MoM ") or c.startswith("%Diff ") or c.startswith("YoY ")]:
    if h not in col_index:
        continue
    
    col_idx = col_index[h]
    col_letter = ws.cell(1, col_idx).column_letter
    flag_col = f"_flag_{h}"
    
    if flag_col not in df.columns:
        continue
    
    # Apply cell-by-cell coloring based on flags
    for i, (_, row) in enumerate(df.iterrows(), start=first_data_row):
        flag = row.get(flag_col)
        if flag == "RED":
            ws.cell(i, col_idx).fill = FILL_RED
        elif flag == "YELLOW":
            ws.cell(i, col_idx).fill = FILL_YELLOW

# Add banners (same as before)
# Dimensions banner
ws.merge_cells(start_row=banner_row, start_column=1, end_row=banner_row, end_column=len(base_headers))
ws.cell(banner_row, 1, "Dimensions").font = bold
ws.cell(banner_row, 1).alignment = center

# Freeze panes and filters
first_month_col = col_index.get(months_to_show[0], len(base_headers) + 1) if months_to_show else len(base_headers) + 1
ws.freeze_panes = ws.cell(first_data_row, first_month_col)
ws.auto_filter.ref = f"A{header_row}:{ws.cell(last_data_row, len(display_cols)).coordinate}"

# Add table
table_ref = f"A{header_row}:{ws.cell(last_data_row, len(display_cols)).coordinate}"
table = Table(displayName=sheet_name.replace(" ", "_"), ref=table_ref)
table.tableStyleInfo = TableStyleInfo(name="TableStyleLight9", showRowStripes=True, showColumnStripes=False)
ws.add_table(table)

print(f"[INFO] Sheet '{sheet_name}' created with {len(df)} rows ({df['is_rollup'].sum()} rollups)")
```
