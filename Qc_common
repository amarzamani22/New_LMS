# qc_common.py
from __future__ import annotations
from typing import Dict, List, Optional, Sequence, Tuple
from dataclasses import dataclass
from datetime import datetime

import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.formatting.rule import FormulaRule

# ========= Rollups =========
ROLLUPS: Dict[str, List[str]] = {
    "All Financial Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks", "DFI",
        "Insurers", "Takaful Operators", "Foreign Banks",
        "International Islamic Banks", "Digital Banks"
    ],
    "Banking Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks",
        "Digital Banks", "International Islamic Banks", "Foreign Banks"
    ],
    "Commercial Banks": ["Commercial Banks", "Foreign Banks"],
    "Investment Banks": ["Investment Banks"],
    "Islamic Banks": ["Islamic Banks"],
    "Digital Banks": ["Digital Banks"],
    "International Islamic Banks": ["International Islamic Banks"],
    "Foreign Banks": ["Foreign Banks"],
    "DFI": ["DFI"],
    "Insurers": ["Insurers"],
    "Takaful Operators": ["Takaful Operators"],
}
ROLLUP_ORDER = [
    "All Financial Institutions",
    "Banking Institutions",
    "Commercial Banks",
    "Investment Banks",
    "Islamic Banks",
    "Foreign Banks",
    "Digital Banks",
    "International Islamic Banks",
    "DFI",
    "Insurers",
    "Takaful Operators",
]

# ========= FI → Type mapping =========
ENTITY_TO_TYPE: Dict[str, str] = {
    # (… your long mapping list …)
    # Keep exactly as you pasted before. Omitted here for brevity.
}

# ========= Quarter / Month utils =========
QMAP = {
    "Quarter 1": "Q1", "Quarter 2": "Q2", "Quarter 3": "Q3", "Quarter 4": "Q4",
    "Q1":"Q1","Q2":"Q2","Q3":"Q3","Q4":"Q4"
}
Q_TO_MONTHS = {
    "Q1": ["Jan","Feb","Mar"],
    "Q2": ["Apr","May","Jun"],
    "Q3": ["Jul","Aug","Sep"],
    "Q4": ["Oct","Nov","Dec"],
}
MONTHS_FULL = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]

def normalize_quarter_label(qseries: pd.Series) -> str:
    """
    Return the *latest* quarter label (Q1..Q4) present in the series.
    """
    if qseries is None or qseries.empty:
        return "Q1"
    tmp = qseries.astype(str).map(lambda s: QMAP.get(s.strip(), s.strip()))
    rank = {"Q1":1,"Q2":2,"Q3":3,"Q4":4}
    # pick the item with the max rank; if ties, last occurrence is fine
    idx = tmp.map(rank).fillna(0).idxmax()
    return tmp.loc[idx]

def months_up_to(q: str) -> List[str]:
    order = ["Q1","Q2","Q3","Q4"]
    qn = QMAP.get(str(q).strip(), str(q).strip())
    out: List[str] = []
    for qq in order:
        out += Q_TO_MONTHS[qq]
        if qq == qn: break
    return out

# ========= Styling =========
FILL_HEADER = PatternFill(start_color="F2F2F2", end_color="F2F2F2", fill_type="solid")
FILL_INFO   = PatternFill(start_color="EEF5FF", end_color="EEF5FF", fill_type="solid")
FILL_RED    = PatternFill(start_color="FFE5E5", end_color="FFE5E5", fill_type="solid")
FILL_YEL    = PatternFill(start_color="FFF8DB", end_color="FFF8DB", fill_type="solid")
FILL_BAND   = PatternFill(start_color="EDEDED", end_color="EDEDED", fill_type="solid")
BTHIN       = Border(left=Side(style="thin", color="DDDDDD"),
                     right=Side(style="thin", color="DDDDDD"),
                     top=Side(style="thin", color="DDDDDD"),
                     bottom=Side(style="thin", color="DDDDDD"))

def new_empty_workbook() -> Workbook:
    wb = Workbook()
    ws0 = wb.active
    wb.remove(ws0)
    return wb

def append_about_sheet_last(wb: Workbook, title: str, year: int, qlabel: str, notes: str = "") -> None:
    ws = wb.create_sheet("_About")
    ws["A1"] = title
    ws["A1"].font = Font(bold=True, size=14)
    ws["A3"] = "Year";    ws["B3"] = int(year)
    ws["A4"] = "Quarter"; ws["B4"] = QMAP.get(str(qlabel).strip(), str(qlabel).strip())
    ws["A5"] = "Generated"; ws["B5"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if notes:
        ws["A7"] = "Notes"; ws["B7"] = notes

# ========= Entity type + Rollups =========
def attach_entity_type(df: pd.DataFrame, entity_col: str = "entity_name") -> pd.DataFrame:
    df = df.copy()
    df["_E"] = df[entity_col].astype(str).str.upper().str.strip()
    df["entity_type"] = df["_E"].map(ENTITY_TO_TYPE).fillna("Unknown")
    df.drop(columns=["_E"], inplace=True)
    return df

def expand_rollups(
    df: pd.DataFrame,
    numeric_cols: Optional[Sequence[str]],
    keys: Sequence[str],
    entity_col: str = "entity_name",
    entity_type_col: str = "entity_type",
) -> pd.DataFrame:
    """
    Append rollup rows (All FI, Banking Institutions, …). Rollups are emitted as new rows
    where entity_name == rollup label and entity_type == rollup label.
    """
    if df.empty:
        return df
    if numeric_cols is None:
        numeric_cols = df.select_dtypes(include="number").columns.tolist()

    out = [df]
    for label, members in ROLLUPS.items():
        sub = df[df[entity_type_col].isin(members)]
        if sub.empty:
            continue
        agg = (sub.groupby(list(keys), dropna=False)[list(numeric_cols)]
                   .sum(min_count=1)
                   .reset_index())
        agg[entity_col] = label
        agg[entity_type_col] = label
        out.append(agg)
    return pd.concat(out, ignore_index=True)

# ========= YoY helpers (INDEX/MATCH; no XLOOKUP) =========
def _add_prior_sheet(wb: Workbook, prior: pd.DataFrame,
                     key_cols: Sequence[str], qcols: Sequence[str],
                     sheet_name: str) -> Tuple[str, Dict[str,str]]:
    if prior is None or prior.empty:
        return (sheet_name, {})
    if sheet_name in wb.sheetnames:
        del wb[sheet_name]
    ws = wb.create_sheet(sheet_name)
    ws["A1"] = "KEY"
    colmap: Dict[str,str] = {}
    usable = [q for q in ["Q1","Q2","Q3","Q4"] if q in qcols and q in prior.columns]
    for j, q in enumerate(usable, start=2):
        ws.cell(1, j, q)
        colmap[q] = ws.cell(1, j).column_letter
    for i, row in prior.iterrows():
        key = "|".join(str(row.get(k, "")).strip() for k in key_cols)
        ws.cell(i+2, 1, key)
        for j, q in enumerate(usable, start=2):
            ws.cell(i+2, j, row.get(q, 0) or 0)
    ws.sheet_state = "hidden"
    return (sheet_name, colmap)

def _ensure_hidden_key_col(ws, header_row: int, first_data_row: int, last_data_row: int,
                           col_index: Dict[str,int], key_cols: Sequence[str], title: str) -> int:
    if title in col_index:
        return col_index[title]
    key_idx = len(col_index) + 1
    col_index[title] = key_idx
    ws.cell(header_row, key_idx, title)
    parts = []
    for name in key_cols:
        c = col_index[name]
        parts.append(f'{ws.cell(1, c).column_letter}{{r}}')
    expr = "=" + '&"|"&'.join(parts)
    for r in range(first_data_row, last_data_row + 1):
        ws.cell(r, key_idx).value = expr.replace("{r}", str(r))
    ws.column_dimensions[ws.cell(1, key_idx).column_letter].hidden = True
    return key_idx

# ========= Band helpers =========
def _merge_and_band(ws, top_row: int, left_col: int, right_col: int, title: str) -> None:
    if right_col < left_col:
        return
    c1 = ws.cell(top_row, left_col)
    c2 = ws.cell(top_row, right_col)
    ws.merge_cells(start_row=top_row, start_column=left_col, end_row=top_row, end_column=right_col)
    c1.value = title
    c1.font = Font(bold=True)
    c1.alignment = Alignment(horizontal="center", vertical="center")
    c1.fill = FILL_BAND
    c1.border = BTHIN
    # add thin borders to merged region
    for col in range(left_col, right_col + 1):
        ws.cell(top_row, col).border = BTHIN

def _add_quarter_band(ws, header_row: int, col_index: Dict[str,int], current_q: str) -> None:
    """Add a band row above header labeling Q1/Q2/Q3/Q4 over month columns."""
    band_row = header_row - 1
    # ensure the row exists
    if ws.cell(band_row, 1).value is None:
        ws.insert_rows(header_row)  # push header down one row
        band_row = header_row
        header_row += 1
        # We can't update all formulas/coords here, so only call this BEFORE writing any data.
        # In our writer below, we always call this immediately after headers are set, before data.
    # Build ranges
    q_ranges = []
    for q in ["Q1","Q2","Q3","Q4"]:
        months = Q_TO_MONTHS[q]
        if all(m in col_index for m in months):
            left  = min(col_index[m] for m in months)
            right = max(col_index[m] for m in months)
            q_ranges.append((q, left, right))
    # Merge and label
    for q, left, right in q_ranges:
        _merge_and_band(ws, band_row, left, right, f"{q}")

def _add_calc_bands(ws, header_row: int, col_index: Dict[str,int]) -> None:
    """
    Add one-line bands above MoM, QoQ, YoY blocks (if present).
    We place them on the same band row used for quarter bands (header_row-1).
    This function expects _add_quarter_band to have already inserted the band row (if needed).
    """
    band_row = header_row - 1

    # Collect contiguous ranges by prefixes
    def ranges(prefixes: List[Tuple[str,str]]) -> List[Tuple[str,int,int,str]]:
        out = []
        for title, pref in prefixes:
            # find columns whose header startswith pref (exact match too)
            cols = [c for h, c in col_index.items() if h.startswith(pref)]
            if not cols:
                continue
            left, right = min(cols), max(cols)
            out.append((title, left, right, pref))
        return out

    mom = ranges([("MoM Analysis", "MoM ")])
    qoq = ranges([("QoQ Analysis", "%Diff "), ("QoQ Analysis", "Diff Q")])  # ensure we cover both sets
    yoy = ranges([("YoY Analysis", "YoY ")])

    # Merge them (avoid overlapping with month bands)
    for title, left, right, _ in mom + qoq + yoy:
        _merge_and_band(ws, band_row, left, right, title)

# ========= QC writer =========
@dataclass
class QCArgs:
    sheet_name: str
    df: pd.DataFrame                       # raw staging (for a single question sheet)
    wb: Workbook
    year: int
    current_q: str
    prior_df: Optional[pd.DataFrame]
    months_to_show: List[str]              # subset of MONTHS_FULL (in order) to display
    include_job_function: bool             # if True: expects a 'value' column (Q4 jobfunc)
    yoy_quarters: Optional[List[str]] = None   # override for jobfunc (e.g., ["Q4"])
    mom_pct_threshold: float = 0.25
    qoq_pct_threshold: float = 0.25
    yoy_pct_threshold: float = 0.25
    abs_cutoff: float = 50.0

def write_qc_sheet(args: QCArgs) -> None:
    """
    Build a clean, auditable QC sheet with formulas:
      - MoM diffs/% over months_to_show (if length >= 2)
      - Quarter sums present in months_to_show (Q1..current)
      - QoQ diffs/% between quarter sums (if >= 2)
      - YoY via hidden prior sheet (INDEX/MATCH), both Prior Qx and YoY % for Qx
        or for month-only frames (e.g., Q1B) we add Prior <Mon> and YoY <Mon>.
      - Red/Yellow highlighting with thresholds.
      - Quarter band above month columns; calc bands above MoM/QoQ/YoY.
    """
    df = args.df.copy()
    if df.empty:
        return

    # ----- 1) Normalize structural columns -----
    for col in ["subquestion","worker_category","job_function"]:
        if col not in df.columns:
            df[col] = ""
    df = attach_entity_type(df, entity_col="entity_name")

    # months subset (in order)
    months = [m for m in args.months_to_show if m in MONTHS_FULL]
    for m in months:
        if m not in df.columns:
            df[m] = 0.0

    jobfunc_mode = bool(args.include_job_function)
    if jobfunc_mode:
        if "value" not in df.columns:
            df["value"] = 0.0
        yoy_qs = args.yoy_quarters or ["Q4"]
    else:
        yoy_qs = []

    # ----- 2) Expand with rollups -----
    key_cols = ["entity_type","entity_name","subquestion","worker_category"]
    if jobfunc_mode:
        key_cols.append("job_function")
    num_cols = (["value"] if jobfunc_mode else months)
    df_full = expand_rollups(df, numeric_cols=num_cols, keys=key_cols)

    # ----- 3) Sort rollups → A–Z -----
    roll_rank = {n:i for i,n in enumerate(ROLLUP_ORDER)}
    df_full["_rank"] = df_full["entity_name"].map(lambda x: roll_rank.get(x, 10_000))
    df_full = df_full.sort_values(
        ["_rank","entity_type","entity_name","subquestion","worker_category","job_function"],
        kind="mergesort"
    ).drop(columns=["_rank"]).reset_index(drop=True)

    # ----- 4) Prepare sheet & info band -----
    ws = args.wb.create_sheet(args.sheet_name)
    info_rows = 4
    ws["A1"] = f"{args.sheet_name}"; ws["A1"].font = Font(bold=True, size=13)
    ws["A2"] = "Year"; ws["B2"] = int(args.year)
    ws["A3"] = "Quarter"; ws["B3"] = QMAP.get(str(args.current_q).strip(), str(args.current_q).strip())
    ws["D2"] = "Threshold (±%)"; ws["E2"] = float(args.mom_pct_threshold)
    ws["D3"] = "Abs cutoff";     ws["E3"] = float(args.abs_cutoff)
    for cell in ("A1:A3","B2:B3","D2:E3"):
        for rng in ws[cell]:
            for c in rng:
                c.fill = FILL_INFO
                c.border = BTHIN

    # ----- 5) Column headers -----
    dims = ["Entity Type","Entity / Group","Subquestion","Worker Category"]
    if jobfunc_mode:
        dims.append("Job Function")
    headers: List[str] = dims[:]

    if jobfunc_mode:
        headers += ["Q4"]
    else:
        headers += months

    # MoM
    month_diff_headers: List[str] = []
    month_pct_headers: List[str]  = []
    if not jobfunc_mode and len(months) >= 2:
        for i in range(1, len(months)):
            m = months[i]
            month_diff_headers.append(f"Diff {m}")
            month_pct_headers.append(f"MoM {m}")
        headers += month_diff_headers + month_pct_headers

    # Quarter sums + QoQ
    q_sums: List[str] = []
    if not jobfunc_mode:
        for q in ["Q1","Q2","Q3","Q4"]:
            need = set(Q_TO_MONTHS[q])
            if need.issubset(set(months)):
                q_sums.append(q)
        if q_sums:
            headers += q_sums
            for i in range(1, len(q_sums)):
                headers += [f"Diff {q_sums[i]}", f"%Diff {q_sums[i]}"]

    # YoY
    yoy_prior_headers: List[str] = []
    yoy_pct_headers: List[str]   = []
    yoy_months: List[str] = []
    if jobfunc_mode:
        yoy_prior_headers = [f"Prior {q}" for q in yoy_qs]
        yoy_pct_headers   = [f"YoY {q}" for q in yoy_qs]
    else:
        if len(months) <= 2:
            yoy_months = months[:]
            yoy_prior_headers = [f"Prior {m}" for m in months]
            yoy_pct_headers   = [f"YoY {m}" for m in months]
        else:
            yoy_qs = q_sums[:]
            yoy_prior_headers = [f"Prior {q}" for q in yoy_qs]
            yoy_pct_headers   = [f"YoY {q}" for q in yoy_qs]
    headers += yoy_prior_headers + yoy_pct_headers

    # spacer row + header row
    ws.append([""] * len(headers))  # spacer @ (info_rows + 1)
    header_row = info_rows + 2
    for j, h in enumerate(headers, start=1):
        c = ws.cell(header_row, j, h)
        c.font = Font(bold=True)
        c.fill = FILL_HEADER
        c.alignment = Alignment(horizontal="center", vertical="center")
        c.border = BTHIN
    col_index = {h: i+1 for i, h in enumerate(headers)}

    # ----- 6) Quarter band + calc bands (placed on header_row - 1) -----
    # We insert the band row right above the header and then re-write header styling if needed.
    # Quarter band (month groups)
    _add_quarter_band(ws, header_row, col_index, args.current_q)
    # Recompute header_row if a row was inserted
    # (If _add_quarter_band inserted a row, our headers moved down by 1)
    if ws.cell(header_row, 1).value != headers[0]:
        header_row += 1
    # Calc bands (MoM/QoQ/YoY blocks)
    _add_calc_bands(ws, header_row, col_index)

    # ----- 7) Data rows -----
    first_data_row = header_row + 1
    for _, r in df_full.iterrows():
        row_vals: List = [
            r.get("entity_type",""),
            r.get("entity_name",""),
            r.get("subquestion",""),
            r.get("worker_category",""),
        ]
        if jobfunc_mode:
            row_vals.append(r.get("job_function",""))
        if jobfunc_mode:
            row_vals.append(r.get("value", 0))
        else:
            for m in months:
                row_vals.append(r.get(m, 0))
        need = len(headers) - len(row_vals)
        row_vals += [""] * max(0, need)
        ws.append(row_vals)

    last_data_row = first_data_row + len(df_full) - 1
    if last_data_row < first_data_row:
        return

    # Freeze panes & table
    freeze_col = 5 if jobfunc_mode else 4
    ws.freeze_panes = ws.cell(first_data_row, freeze_col)
    table_ref = f"A{header_row}:{ws.cell(last_data_row, len(headers)).coordinate}"
    tbl = Table(displayName=args.sheet_name.replace(" ","_"), ref=table_ref)
    tbl.tableStyleInfo = TableStyleInfo(name="TableStyleLight9", showRowStripes=True)
    ws.add_table(tbl)

    # Number formats
    value_like = []
    if jobfunc_mode:
        value_like += ["Q4"]
    else:
        value_like += months + q_sums + [h for h in headers if h.startswith("Diff ")]
    for h in value_like:
        if h in col_index:
            cidx = col_index[h]
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, cidx).number_format = "#,##0"

    # ----- 8) Formulas -----
    # MoM
    if not jobfunc_mode and len(months) >= 2:
        for i in range(1, len(months)):
            m = months[i]; prev = months[i-1]
            if f"Diff {m}" in col_index:
                diff_col = col_index[f"Diff {m}"]
                for r in range(first_data_row, last_data_row + 1):
                    a = ws.cell(r, col_index[m]).coordinate
                    b = ws.cell(r, col_index[prev]).coordinate
                    ws.cell(r, diff_col).value = f"={a}-{b}"
                    ws.cell(r, diff_col).number_format = "#,##0"
            if f"MoM {m}" in col_index:
                pct_col = col_index[f"MoM {m}"]
                for r in range(first_data_row, last_data_row + 1):
                    a = ws.cell(r, col_index[m]).coordinate
                    b = ws.cell(r, col_index[prev]).coordinate
                    ws.cell(r, pct_col).value = (
                        f"=IF(AND({a}=0,{b}=0),0,IF({b}=0,\"N/A\",({a}-{b})/{b}))"
                    )
                    ws.cell(r, pct_col).number_format = "0.0%"

    # Quarter sums
    if not jobfunc_mode:
        if "Q1" in q_sums:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q1"]).value = f"=SUM({ws.cell(r,col_index['Jan']).coordinate}:{ws.cell(r,col_index['Mar']).coordinate})"
        if "Q2" in q_sums:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q2"]).value = f"=SUM({ws.cell(r,col_index['Apr']).coordinate}:{ws.cell(r,col_index['Jun']).coordinate})"
        if "Q3" in q_sums:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q3"]).value = f"=SUM({ws.cell(r,col_index['Jul']).coordinate}:{ws.cell(r,col_index['Sep']).coordinate})"
        if "Q4" in q_sums:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q4"]).value = f"=SUM({ws.cell(r,col_index['Oct']).coordinate}:{ws.cell(r,col_index['Dec']).coordinate})"
        # QoQ diffs/%
        for i in range(1, len(q_sums)):
            q = q_sums[i]; prevq = q_sums[i-1]
            if f"Diff {q}" in col_index:
                cd = col_index[f"Diff {q}"]
                for r in range(first_data_row, last_data_row + 1):
                    a = ws.cell(r, col_index[q]).coordinate
                    b = ws.cell(r, col_index[prevq]).coordinate
                    ws.cell(r, cd).value = f"={a}-{b}"
                    ws.cell(r, cd).number_format = "#,##0"
            if f"%Diff {q}" in col_index:
                cp = col_index[f"%Diff {q}"]
                for r in range(first_data_row, last_data_row + 1):
                    a = ws.cell(r, col_index[q]).coordinate
                    b = ws.cell(r, col_index[prevq]).coordinate
                    ws.cell(r, cp).value = f"=IF(AND({a}=0,{b}=0),0,IF({b}=0,\"N/A\",({a}-{b})/{b}))"
                    ws.cell(r, cp).number_format = "0.0%"

    # YoY
    key_cols_for_yoy = ["Entity / Group","Subquestion","Worker Category"]
    if jobfunc_mode:
        key_cols_for_yoy.append("Job Function")

    prior = args.prior_df.copy() if args.prior_df is not None and not args.prior_df.empty else None
    if prior is not None:
        prior = attach_entity_type(prior, "entity_name")
        p_key_cols = ["entity_type","entity_name","subquestion","worker_category"]
        if jobfunc_mode:
            p_key_cols.append("job_function")
        p_num = ["value"] if jobfunc_mode else months
        prior_full = expand_rollups(prior, numeric_cols=p_num, keys=p_key_cols)

        if jobfunc_mode:
            prior_full = prior_full.rename(columns={"job_function":"Job Function"})
            prior_full["Entity / Group"] = prior_full["entity_name"]
            prior_full["Subquestion"]    = prior_full["subquestion"]
            prior_full["Worker Category"]= prior_full["worker_category"]
            prior_full["Q4"] = prior_full["value"]
            prior_qc_df = prior_full[["Entity / Group","Subquestion","Worker Category","Job Function","Q4"]].copy()
        else:
            prior_full["Entity / Group"] = prior_full["entity_name"]
            prior_full["Subquestion"]    = prior_full["subquestion"]
            prior_full["Worker Category"]= prior_full["worker_category"]
            for q in ["Q1","Q2","Q3","Q4"]:
                need = set(Q_TO_MONTHS[q])
                if need.issubset(set(prior_full.columns)):
                    prior_full[q] = prior_full[list(need)].sum(axis=1)
            prior_qc_df = prior_full[["Entity / Group","Subquestion","Worker Category"] +
                                     [c for c in ["Q1","Q2","Q3","Q4"] if c in prior_full.columns]].copy()
    else:
        prior_qc_df = None

    def _add_prior_and_fill_qoy(yoy_quarters: List[str]):
        if not yoy_quarters:
            return
        prior_sheet_name = f"_{args.sheet_name}_PRIOR"
        (ps, qmap) = _add_prior_sheet(args.wb, prior_qc_df, ["Entity / Group","Subquestion","Worker Category","Job Function"], yoy_quarters, prior_sheet_name)
        if not qmap:
            return
        key_idx = _ensure_hidden_key_col(ws, header_row, first_data_row, last_data_row, col_index,
                                         ["Entity / Group","Subquestion","Worker Category","Job Function"], "_KEY")
        for q in yoy_quarters:
            prior_hdr = f"Prior {q}"
            yoy_hdr   = f"YoY {q}"
            if prior_hdr not in col_index and yoy_hdr not in col_index:
                continue
            if q not in qmap:
                continue
            prior_letter = qmap[q]
            prior_range = f"{ps}!${prior_letter}:${prior_letter}"
            key_range   = f"{ps}!$A:$A"
            prior_col = col_index.get(prior_hdr)
            yoy_col   = col_index.get(yoy_hdr)
            curr_col  = col_index.get(q)
            for r in range(first_data_row, last_data_row + 1):
                key_addr = ws.cell(r, key_idx).coordinate
                prior_expr = f"INDEX({prior_range},MATCH({key_addr},{key_range},0))"
                if prior_col:
                    ws.cell(r, prior_col).value = f"=IFERROR({prior_expr},\"\")"
                    ws.cell(r, prior_col).number_format = "#,##0"
                if yoy_col and curr_col:
                    curr_addr = ws.cell(r, curr_col).coordinate
                    ws.cell(r, yoy_col).value = (
                        f'=IFERROR(IF({prior_expr}="","N/A",'
                        f'IF(AND({prior_expr}=0,{curr_addr}=0),0,'
                        f'IF(AND({prior_expr}=0,{curr_addr}>0),"N/A",'
                        f'({curr_addr}-{prior_expr})/{prior_expr}))),"N/A")'
                    )
                    ws.cell(r, yoy_col).number_format = "0.0%"

    def _add_prior_and_fill_months(yoy_months: List[str]):
        if not yoy_months or prior_qc_df is None or prior_qc_df.empty:
            return
        ps = f"_{args.sheet_name}_PRIOR_M"
        if ps in args.wb.sheetnames:
            del args.wb[ps]
        wsp = args.wb.create_sheet(ps)
        wsp["A1"] = "KEY"
        m_map: Dict[str,str] = {}
        for j, m in enumerate(yoy_months, start=2):
            wsp.cell(1, j, m)
            m_map[m] = wsp.cell(1, j).column_letter
        p = args.prior_df.copy()
        p = attach_entity_type(p, "entity_name")
        p = expand_rollups(p, numeric_cols=yoy_months, keys=["entity_type","entity_name","subquestion","worker_category"])
        p["Entity / Group"] = p["entity_name"]
        p["Subquestion"]    = p["subquestion"]
        p["Worker Category"]= p["worker_category"]
        for i, row in p.iterrows():
            key = "|".join(str(row.get(k, "")).strip() for k in ["Entity / Group","Subquestion","Worker Category","Job Function"])
            wsp.cell(i+2, 1, key)
            for j, m in enumerate(yoy_months, start=2):
                wsp.cell(i+2, j, row.get(m, 0) or 0)
        wsp.sheet_state = "hidden"

        key_idx = _ensure_hidden_key_col(ws, header_row, first_data_row, last_data_row, col_index,
                                         ["Entity / Group","Subquestion","Worker Category","Job Function"], "_KEY_M")
        for m in yoy_months:
            prior_hdr = f"Prior {m}"
            yoy_hdr   = f"YoY {m}"
            if prior_hdr not in col_index and yoy_hdr not in col_index:
                continue
            prior_letter = m_map[m]
            prior_range = f"{ps}!${prior_letter}:${prior_letter}"
            key_range   = f"{ps}!$A:$A"
            prior_col = col_index.get(prior_hdr)
            yoy_col   = col_index.get(yoy_hdr)
            curr_col  = col_index.get(m)
            for r in range(first_data_row, last_data_row + 1):
                key_addr = ws.cell(r, key_idx).coordinate
                prior_expr = f"INDEX({prior_range},MATCH({key_addr},{key_range},0))"
                if prior_col:
                    ws.cell(r, prior_col).value = f"=IFERROR({prior_expr},\"\")"
                    ws.cell(r, prior_col).number_format = "#,##0"
                if yoy_col and curr_col:
                    curr_addr = ws.cell(r, curr_col).coordinate
                    ws.cell(r, yoy_col).value = (
                        f'=IFERROR(IF({prior_expr}="","N/A",'
                        f'IF(AND({prior_expr}=0,{curr_addr}=0),0,'
                        f'IF(AND({prior_expr}=0,{curr_addr}>0),"N/A",'
                        f'({curr_addr}-{prior_expr})/{prior_expr}))),"N/A")'
                    )
                    ws.cell(r, yoy_col).number_format = "0.0%"

    if yoy_qs:
        _add_prior_and_fill_qoy(yoy_qs)
    if yoy_months:
        _add_prior_and_fill_months(yoy_months)

    # ----- 9) Conditional formatting (RED/YELLOW) -----
    def _cf_for_percent(col_title: str, diff_title: Optional[str]):
        if col_title not in col_index:
            return
        pct_col = col_index[col_title]
        letter  = ws.cell(header_row, pct_col).column_letter
        rng = f"{letter}{first_data_row}:{letter}{last_data_row}"
        top = f"{letter}{first_data_row}"
        if diff_title and diff_title in col_index:
            dletter = ws.cell(header_row, col_index[diff_title]).column_letter
            dtop = f"{dletter}{first_data_row}"
            red_formula = f"=AND(ISNUMBER({top}),ABS({top})>={args.mom_pct_threshold},ABS({dtop})>={args.abs_cutoff})"
            yel_formula = f"=AND(ISNUMBER({top}),ABS({top})>={args.mom_pct_threshold},ABS({dtop})<{args.abs_cutoff})"
        else:
            red_formula = f"=AND(ISNUMBER({top}),ABS({top})>C$2,ABS({top})>C$2)"  # simple
            yel_formula = f"=AND(ISNUMBER({top}),ABS({top})>C$2,ABS({top})<=C$2)"
        ws.conditional_formatting.add(rng, FormulaRule(formula=[red_formula], fill=FILL_RED))
        ws.conditional_formatting.add(rng, FormulaRule(formula=[yel_formula], fill=FILL_YEL))

    if not jobfunc_mode and len(months) >= 2:
        for i in range(1, len(months)):
            m = months[i]
            _cf_for_percent(f"MoM {m}", f"Diff {m}")

    if not jobfunc_mode and q_sums:
        for i in range(1, len(q_sums)):
            q = q_sums[i]
            _cf_for_percent(f"%Diff {q}", f"Diff {q}")

    if jobfunc_mode:
        for q in yoy_qs:
            _cf_for_percent(f"YoY {q}", None)
    else:
        if len(months) <= 2:
            for m in months:
                _cf_for_percent(f"YoY {m}", None)
        else:
            for q in yoy_qs:
                _cf_for_percent(f"YoY {q}", None)

    # ----- 10) Auto width (lightweight) -----
    for col in range(1, len(headers) + 1):
        maxw = max(len(str(ws.cell(header_row, col).value or "")), 10)
        for r in range(first_data_row, min(first_data_row + 50, last_data_row + 1)):
            v = ws.cell(r, col).value
            if v is not None:
                maxw = max(maxw, len(str(v)))
        ws.column_dimensions[ws.cell(1, col).column_letter].width = min(maxw + 2, 28)
