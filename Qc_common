# qc_common.py
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Sequence, Tuple

import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.formatting.rule import FormulaRule

# =====================================================================================
# Replace these two dicts with your full mappings
# =====================================================================================
ROLLUPS: Dict[str, List[str]] = {
    # PLACEHOLDER – replace with full list
    "All Financial Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks",
        "DFI", "Insurers", "Takaful Operators", "Foreign Banks",
        "International Islamic Banks", "Digital Banks"
    ],
    "Banking Institutions": [
        "Commercial Banks", "Investment Banks", "Islamic Banks",
        "Digital Banks", "International Islamic Banks", "Foreign Banks"
    ],
    "Commercial Banks": ["Commercial Banks", "Foreign Banks"],
    "Investment Banks": ["Investment Banks"],
    "Islamic Banks": ["Islamic Banks"],
    "Digital Banks": ["Digital Banks"],
    "International Islamic Banks": ["International Islamic Banks"],
    "Foreign Banks": ["Foreign Banks"],
    "DFI": ["DFI"],
    "Insurers": ["Insurers"],
    "Takaful Operators": ["Takaful Operators"],
}
ROLLUP_ORDER = [
    "All Financial Institutions",
    "Banking Institutions",
    "Commercial Banks",
    "Investment Banks",
    "Islamic Banks",
    "Foreign Banks",
    "Digital Banks",
    "International Islamic Banks",
    "DFI",
    "Insurers",
    "Takaful Operators",
]

ENTITY_TO_TYPE: Dict[str, str] = {
    # PLACEHOLDER – replace with full FI→type mapping (UPPER-CASED KEYS)
    "MALAYAN BANKING BERHAD": "Commercial Banks",
    "BANK ISLAM MALAYSIA BERHAD": "Islamic Banks",
    "PUBLIC BANK BERHAD": "Commercial Banks",
    "ZURICH GENERAL INSURANCE MALAYSIA BERHAD": "Insurers",
    "AGROBANK (BANK PERTANIAN MALAYSIA BERHAD)": "DFI",
}
# =====================================================================================

# -------- Quarter / Month utils --------
QMAP = {
    "Quarter 1": "Q1", "Quarter 2": "Q2", "Quarter 3": "Q3", "Quarter 4": "Q4",
    "Q1": "Q1", "Q2": "Q2", "Q3": "Q3", "Q4": "Q4",
}
Q_TO_MONTHS = {
    "Q1": ["Jan", "Feb", "Mar"],
    "Q2": ["Apr", "May", "Jun"],
    "Q3": ["Jul", "Aug", "Sep"],
    "Q4": ["Oct", "Nov", "Dec"],
}
MONTHS_FULL = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]


def normalize_quarter_label(qseries: pd.Series) -> str:
    """Pick the max-realized quarter label (“Q1..Q4”) from a series."""
    if qseries is None or qseries.empty:
        return "Q1"
    s = qseries.astype(str).str.strip().map(lambda x: QMAP.get(x, x))
    rank = {"Q1": 1, "Q2": 2, "Q3": 3, "Q4": 4}
    idx = s.map(rank).fillna(0).idxmax()
    return s.loc[idx]


# -------- Styling --------
FILL_HEADER = PatternFill("solid", fgColor="F2F2F2")
FILL_INFO   = PatternFill("solid", fgColor="EEF5FF")
FILL_BAND1  = PatternFill("solid", fgColor="E8F1FF")  # month bands
FILL_BAND2  = PatternFill("solid", fgColor="F9F1FF")  # diff
FILL_BAND3  = PatternFill("solid", fgColor="FFF7E8")  # MoM
FILL_BAND4  = PatternFill("solid", fgColor="EAF7EA")  # quarter sums
FILL_BAND5  = PatternFill("solid", fgColor="FFECEC")  # QoQ
FILL_BAND6  = PatternFill("solid", fgColor="F4F4F4")  # YoY
FILL_RED    = PatternFill("solid", fgColor="FFE5E5")
FILL_YEL    = PatternFill("solid", fgColor="FFF8DB")
BTHIN       = Border(*(Side(style="thin", color="DDDDDD") for _ in range(4)))
BLEFT_THICK = Side(style="medium", color="999999")


def new_empty_workbook() -> Workbook:
    wb = Workbook()
    wb.remove(wb.active)
    return wb


def append_about_sheet_last(wb: Workbook, title: str, year: int, qlabel: str, notes: str = "") -> None:
    ws = wb.create_sheet("_About")
    ws["A1"] = title; ws["A1"].font = Font(bold=True, size=14)
    ws["A3"] = "Year";    ws["B3"] = int(year)
    ws["A4"] = "Quarter"; ws["B4"] = QMAP.get(str(qlabel).strip(), str(qlabel).strip())
    ws["A5"] = "Generated"; ws["B5"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if notes:
        ws["A7"] = "Notes"; ws["B7"] = notes


# -------- Entity type + Rollups --------
def attach_entity_type(df: pd.DataFrame, entity_col: str = "entity_name") -> pd.DataFrame:
    df = df.copy()
    df["_ENT_UP"] = df[entity_col].astype(str).str.upper().str.strip()
    df["entity_type"] = df["_ENT_UP"].map(ENTITY_TO_TYPE).fillna("Unknown")
    df.drop(columns=["_ENT_UP"], inplace=True)
    return df


def expand_rollups_and_collapse(
    df: pd.DataFrame,
    numeric_cols: Sequence[str],
    group_keys_source: Sequence[str],   # keys using source column names
    group_keys_display: Sequence[str],  # keys using display column names we’ll write to Excel
) -> pd.DataFrame:
    """
    1) Add rollup rows (entity_name := each rollup label).
    2) Map to display keys (Entity / Group, Subquestion, Worker Category[, Job Function]).
    3) Final collapse (groupby/sum) so there’s exactly ONE row per display key.
    """
    if df.empty:
        return df

    # Step 1: rollups (work in source columns)
    out = [df]
    for label, members in ROLLUPS.items():
        sub = df[df["entity_type"].isin(members)]
        if not sub.empty:
            agg = sub.groupby(list(group_keys_source), dropna=False)[list(numeric_cols)].sum(min_count=1).reset_index()
            agg["entity_name"] = label
            agg["entity_type"] = label
            out.append(agg)

    base = pd.concat(out, ignore_index=True)

    # Step 2: map to display keys
    disp = base.copy()
    disp["Entity / Group"]  = disp["entity_name"]
    disp["Subquestion"]     = disp.get("subquestion", "")
    disp["Worker Category"] = disp.get("worker_category", "")
    if "job_function" in disp.columns:
        disp["Job Function"] = disp["job_function"]
    # Step 3: final collapse on DISPLAY keys
    disp_keys = list(group_keys_display)
    collapsed = (disp.groupby(disp_keys, dropna=False)[list(numeric_cols)]
                    .sum(min_count=1)
                    .reset_index())
    return collapsed


# -------- YoY helpers (INDEX/MATCH; no XLOOKUP) --------
def _add_prior_sheet(
    wb: Workbook,
    prior_df: pd.DataFrame,
    key_cols: Sequence[str],   # display keys
    value_cols: Sequence[str], # either ["Q1","Q2","Q3","Q4"] or subset/months
    sheet_name: str,
) -> Tuple[str, Dict[str, str]]:
    if prior_df is None or prior_df.empty:
        return (sheet_name, {})

    if sheet_name in wb.sheetnames:
        del wb[sheet_name]
    ws = wb.create_sheet(sheet_name)
    ws["A1"] = "KEY"

    colmap: Dict[str, str] = {}
    usable = [c for c in value_cols if c in prior_df.columns]
    for j, c in enumerate(usable, start=2):
        ws.cell(1, j, c)
        colmap[c] = ws.cell(1, j).column_letter

    for i, row in prior_df.iterrows():
        key = "|".join(str(row.get(k, "")).strip() for k in key_cols)
        ws.cell(i + 2, 1, key)
        for j, c in enumerate(usable, start=2):
            ws.cell(i + 2, j, row.get(c, 0) or 0)

    ws.sheet_state = "hidden"
    return (sheet_name, colmap)


def _ensure_hidden_key_col(
    ws,
    header_row: int,
    first_data_row: int,
    last_data_row: int,
    col_index: Dict[str, int],
    key_cols: Sequence[str],
    title: str = "_KEY",
) -> int:
    if title in col_index:
        return col_index[title]
    idx = len(col_index) + 1
    col_index[title] = idx
    ws.cell(header_row, idx, title)

    # CONCAT formula pieces
    parts = []
    for name in key_cols:
        c = col_index[name]
        parts.append(f'{ws.cell(1, c).column_letter}{{r}}')
    expr = "=" + '&"|"&'.join(parts)
    for r in range(first_data_row, last_data_row + 1):
        ws.cell(r, idx).value = expr.replace("{r}", str(r))
    ws.column_dimensions[ws.cell(header_row, idx).column_letter].hidden = True
    return idx


# -------- QC writer (row-wise, single row per entity/subq/worker cat[/job func]) --------
@dataclass
class QCArgs:
    wb: Workbook
    sheet_name: str
    df: pd.DataFrame                    # raw staging for a question tab
    year: int
    current_q: str

    # behavior
    include_job_function: bool          # True for Q4 job-func sheet
    months_to_show: List[str]           # which months to display (subset of MONTHS_FULL)

    # prior (for YoY)
    prior_df: Optional[pd.DataFrame] = None

    # thresholds
    mom_pct_threshold: float = 0.25
    qoq_pct_threshold: float = 0.25
    yoy_pct_threshold: float = 0.25
    abs_cutoff: float = 50.0


def write_qc_sheet_rowwise(args: QCArgs) -> None:
    """
    Build a tidy QC sheet:
      - one row per (Entity / Group, Subquestion, Worker Category[, Job Function])
      - months Jan..Dec in same row (subset shown)
      - derived blocks: Diff, MoM%, Quarter sums, QoQ%, YoY
      - banded headers (no merges), conditional colors
    """
    src = args.df.copy()
    if src.empty:
        return

    # Ensure structure columns exist
    for c in ["subquestion", "worker_category", "job_function"]:
        if c not in src.columns:
            src[c] = ""

    # Attach type for rollups
    src = attach_entity_type(src, "entity_name")

    # Numeric basis
    if args.include_job_function:
        if "value" not in src.columns:
            src["value"] = 0.0
        numeric_cols = ["value"]
    else:
        # months to show (ensure present)
        for m in args.months_to_show:
            if m not in src.columns:
                src[m] = 0.0
        numeric_cols = list(args.months_to_show)

    # Expand + collapse to DISPLAY keys
    gsrc = ["entity_type", "entity_name", "subquestion", "worker_category"] + (
        ["job_function"] if args.include_job_function else []
    )
    gdisp = ["Entity / Group", "Subquestion", "Worker Category"] + (
        ["Job Function"] if args.include_job_function else []
    )
    data = expand_rollups_and_collapse(src, numeric_cols, gsrc, gdisp)

    # Sort: rollups first by ROLLUP_ORDER, then institutions A→Z
    rank = {n: i for i, n in enumerate(ROLLUP_ORDER)}
    data["_rk"] = data["Entity / Group"].map(lambda x: rank.get(x, 9999))
    data = data.sort_values(["_rk"] + gdisp, kind="mergesort").drop(columns=["_rk"]).reset_index(drop=True)

    # ---------- Prepare sheet ----------
    ws = args.wb.create_sheet(args.sheet_name)

    # Info panel
    ws["A1"] = args.sheet_name; ws["A1"].font = Font(bold=True, size=13)
    ws["A2"] = "Year";    ws["B2"] = int(args.year)
    ws["A3"] = "Quarter"; ws["B3"] = QMAP.get(str(args.current_q).strip(), str(args.current_q).strip())
    ws["D2"] = "Threshold (±%)"; ws["E2"] = float(args.mom_pct_threshold)
    ws["D3"] = "Abs cutoff";     ws["E3"] = float(args.abs_cutoff)
    for rng in ("A1:A1","A2:B3","D2:E3"):
        for r in ws[rng]:
            for c in r:
                c.fill = FILL_INFO
                c.border = BTHIN

    # ---------- Header layout ----------
    band_row   = 6   # band labels (Q1/Q2/… / block names)
    header_row = 7   # actual column headers

    # Left dimensions
    headers = ["Entity / Group", "Subquestion", "Worker Category"]
    if args.include_job_function:
        headers.append("Job Function")

    # MONTH columns
    month_headers = list(args.months_to_show) if not args.include_job_function else []
    # DIFF/MOM/QSUM/QOQ/YOY blocks
    diff_headers, mom_headers, qsum_headers, qoq_headers = [], [], [], []
    yoy_prior_headers, yoy_pct_headers = [], []

    if args.include_job_function:
        headers += ["Q4"]            # single quarter value
        yoy_prior_headers = ["Prior Q4"]
        yoy_pct_headers   = ["YoY Q4"]
    else:
        # months
        headers += month_headers

        # diff & mom
        for i in range(1, len(month_headers)):
            m = month_headers[i]
            diff_headers.append(f"Diff {m}")
            mom_headers.append(f"MoM {m}")

        # quarter sums present
        q_avail = []
        for q in ["Q1", "Q2", "Q3", "Q4"]:
            if set(Q_TO_MONTHS[q]).issubset(set(month_headers)):
                q_avail.append(q)
        qsum_headers = q_avail

        # QoQ (needs >=2)
        for i in range(1, len(q_avail)):
            q = q_avail[i]
            qoq_headers += [f"Diff {q}", f"%Diff {q}"]

        # YoY per quarter (if we have q sums) else per month (for Q1B)
        if q_avail:
            yoy_prior_headers = [f"Prior {q}" for q in q_avail]
            yoy_pct_headers   = [f"YoY {q}"   for q in q_avail]
        else:
            yoy_prior_headers = [f"Prior {m}" for m in month_headers]
            yoy_pct_headers   = [f"YoY {m}"   for m in month_headers]

    # Assemble full headers
    headers += diff_headers + mom_headers + qsum_headers + qoq_headers + yoy_prior_headers + yoy_pct_headers

    # Band row values & fills (no merges)
    band_vals: List[Tuple[str, PatternFill]] = []
    # left dims
    for _ in (["Entity / Group","Subquestion","Worker Category"] + (["Job Function"] if args.include_job_function else [])):
        band_vals.append(("", FILL_HEADER))

    # months with Q band labels
    if not args.include_job_function:
        for m in month_headers:
            # figure the quarter
            qlabel = ""
            for q, months in Q_TO_MONTHS.items():
                if m in months:
                    qlabel = q; break
            band_vals.append((qlabel, FILL_BAND1))
    else:
        band_vals.append(("Q4", FILL_BAND1))

    # diff
    for _ in diff_headers:
        band_vals.append(("Monthly – Differences", FILL_BAND2))
    # mom
    for _ in mom_headers:
        band_vals.append(("Monthly – MoM%", FILL_BAND3))
    # q sums
    for _ in qsum_headers:
        band_vals.append(("Quarter Sums", FILL_BAND4))
    # qoq
    for _ in qoq_headers:
        band_vals.append(("QoQ", FILL_BAND5))
    # yoy
    for _ in yoy_prior_headers + yoy_pct_headers:
        band_vals.append(("YoY", FILL_BAND6))

    # Write band row & header row
    ws.append([""] * len(headers))  # placeholder so we can address band_row
    while ws.max_row < band_row - 1:
        ws.append([])
    ws.append([t for (t, _) in band_vals])   # band_row
    for j, (_, fill) in enumerate(band_vals, start=1):
        c = ws.cell(band_row, j); c.fill = fill; c.alignment = Alignment(horizontal="center")
    # header row
    ws.append(headers)
    for j, h in enumerate(headers, start=1):
        c = ws.cell(header_row, j, h)
        c.font = Font(bold=True)
        c.fill = FILL_HEADER
        c.alignment = Alignment(horizontal="center", vertical="center")
        c.border = BTHIN

    col_index = {h: i + 1 for i, h in enumerate(headers)}

    # Thicker left borders at block starts (visual “spacing” without blank columns)
    def mark_block_start(col_title: str):
        if col_title in col_index:
            col = col_index[col_title]
            letter = ws.cell(header_row, col).column_letter
            for r in (band_row, header_row):
                cc = ws.cell(r, col)
                cc.border = Border(left=BLEFT_THICK, right=cc.border.right,
                                   top=cc.border.top, bottom=cc.border.bottom)

    # Starts of each block
    first_month = month_headers[0] if month_headers else ("Q4" if args.include_job_function else None)
    for ct in (first_month,
               (diff_headers[0] if diff_headers else None),
               (mom_headers[0]  if mom_headers  else None),
               (qsum_headers[0] if qsum_headers else None),
               (qoq_headers[0]  if qoq_headers  else None),
               (yoy_prior_headers[0] if yoy_prior_headers else None)):
        if ct: mark_block_start(ct)

    # ---------- Data rows ----------
    first_data_row = header_row + 1
    for _, r in data.iterrows():
        row = [r.get("Entity / Group",""), r.get("Subquestion",""), r.get("Worker Category","")]
        if args.include_job_function:
            row.append(r.get("Job Function",""))
            row.append(r.get("value", 0))
        else:
            row += [r.get(m, 0) for m in month_headers]
        # placeholders for derived columns
        while len(row) < len(headers):
            row.append("")
        ws.append(row)
    last_data_row = first_data_row + len(data) - 1
    if last_data_row < first_data_row:
        return

    # Table (nice stripes)
    tbl_ref = f"A{header_row}:{ws.cell(last_data_row, len(headers)).coordinate}"
    tbl = Table(displayName=args.sheet_name.replace(" ","_"), ref=tbl_ref)
    tbl.tableStyleInfo = TableStyleInfo(name="TableStyleLight9", showRowStripes=True)
    ws.add_table(tbl)

    # Freeze panes at first data value column
    freeze_col = 4 + (1 if args.include_job_function else 0) + 1
    ws.freeze_panes = ws.cell(first_data_row, freeze_col)

    # Number formats for raw numbers & diffs
    value_like = []
    if args.include_job_function:
        value_like += ["Q4"]
    else:
        value_like += month_headers + qsum_headers + [h for h in diff_headers + qoq_headers if h.startswith("Diff ")]
    for h in value_like:
        if h in col_index:
            ci = col_index[h]
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, ci).number_format = "#,##0"

    # ---------- Formulas ----------
    # Diff / MoM
    if not args.include_job_function and len(month_headers) >= 2:
        for i in range(1, len(month_headers)):
            m, prev = month_headers[i], month_headers[i-1]
            # Diff m
            dc = col_index[f"Diff {m}"]
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, dc).value = f"={ws.cell(r, col_index[m]).coordinate}-{ws.cell(r, col_index[prev]).coordinate}"
                ws.cell(r, dc).number_format = "#,##0"
            # MoM m
            pc = col_index[f"MoM {m}"]
            for r in range(first_data_row, last_data_row + 1):
                a = ws.cell(r, col_index[m]).coordinate
                b = ws.cell(r, col_index[prev]).coordinate
                ws.cell(r, pc).value = f"=IF(AND({a}=0,{b}=0),0,IF({b}=0,\"N/A\",({a}-{b})/{b}))"
                ws.cell(r, pc).number_format = "0.0%"

    # Quarter sums
    if not args.include_job_function:
        if "Q1" in qsum_headers:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q1"]).value = f"=SUM({ws.cell(r,col_index['Jan']).coordinate}:{ws.cell(r,col_index['Mar']).coordinate})"
        if "Q2" in qsum_headers:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q2"]).value = f"=SUM({ws.cell(r,col_index['Apr']).coordinate}:{ws.cell(r,col_index['Jun']).coordinate})"
        if "Q3" in qsum_headers:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q3"]).value = f"=SUM({ws.cell(r,col_index['Jul']).coordinate}:{ws.cell(r,col_index['Sep']).coordinate})"
        if "Q4" in qsum_headers:
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, col_index["Q4"]).value = f"=SUM({ws.cell(r,col_index['Oct']).coordinate}:{ws.cell(r,col_index['Dec']).coordinate})"

        # QoQ
        for i in range(1, len(qsum_headers)):
            q, prevq = qsum_headers[i], qsum_headers[i-1]
            # Diff
            dc = col_index[f"Diff {q}"]
            for r in range(first_data_row, last_data_row + 1):
                ws.cell(r, dc).value = f"={ws.cell(r,col_index[q]).coordinate}-{ws.cell(r,col_index[prevq]).coordinate}"
                ws.cell(r, dc).number_format = "#,##0"
            # %Diff
            pc = col_index[f"%Diff {q}"]
            for r in range(first_data_row, last_data_row + 1):
                a = ws.cell(r, col_index[q]).coordinate
                b = ws.cell(r, col_index[prevq]).coordinate
                ws.cell(r, pc).value = f"=IF(AND({a}=0,{b}=0),0,IF({b}=0,\"N/A\",({a}-{b})/{b}))"
                ws.cell(r, pc).number_format = "0.0%"

    # YoY: build prior helper sheet
    prior_qc_df = None
    if args.prior_df is not None and not args.prior_df.empty:
        p = args.prior_df.copy()
        for c in ["subquestion","worker_category","job_function"]:
            if c not in p.columns: p[c] = ""
        p = attach_entity_type(p, "entity_name")
        if args.include_job_function:
            p_num = ["value"]
            p_disp = expand_rollups_and_collapse(
                p, p_num,
                ["entity_type","entity_name","subquestion","worker_category","job_function"],
                ["Entity / Group","Subquestion","Worker Category","Job Function"]
            )
            # rename 'value' to Q4 for prior
            p_disp = p_disp.rename(columns={"value":"Q4"})
            prior_qc_df = p_disp
        else:
            # ensure months exist
            for m in month_headers:
                if m not in p.columns: p[m] = 0.0
            p_disp = expand_rollups_and_collapse(
                p, month_headers,
                ["entity_type","entity_name","subquestion","worker_category"],
                ["Entity / Group","Subquestion","Worker Category"]
            )
            # build quarter sums if we’re using quarter YoY
            for q in ["Q1","Q2","Q3","Q4"]:
                need = set(Q_TO_MONTHS[q])
                if need.issubset(set(p_disp.columns)):
                    p_disp[q] = p_disp[list(need)].sum(axis=1)
            prior_qc_df = p_disp

    key_cols = ["Entity / Group","Subquestion","Worker Category"] + (["Job Function"] if args.include_job_function else [])
    if args.include_job_function:
        yoy_vals = ["Q4"]
    else:
        yoy_vals = qsum_headers if qsum_headers else month_headers

    prior_sheet, prior_colmap = _add_prior_sheet(args.wb, prior_qc_df, key_cols, yoy_vals,
                                                 sheet_name=f"_{args.sheet_name}_PRIOR")

    # Hidden KEY on main QC sheet
    key_idx = _ensure_hidden_key_col(ws, header_row, first_data_row, last_data_row,
                                     col_index, key_cols, title="_KEY")

    # Wire Prior and YoY columns
    for colname in yoy_vals:
        # headers we created earlier:
        prior_hdr = f"Prior {colname}"
        yoy_hdr   = f"YoY {colname}"
        if prior_hdr not in col_index and yoy_hdr not in col_index:
            continue
        if colname not in prior_colmap:
            continue

        prior_letter = prior_colmap[colname]
        prior_range  = f"{prior_sheet}!${prior_letter}:${prior_letter}"
        key_range    = f"{prior_sheet}!$A:$A"
        prior_out    = col_index.get(prior_hdr)
        yoy_out      = col_index.get(yoy_hdr)
        curr_col     = col_index.get(colname)
        for r in range(first_data_row, last_data_row + 1):
            key_addr   = ws.cell(r, key_idx).coordinate
            prior_expr = f"INDEX({prior_range},MATCH({key_addr},{key_range},0))"
            if prior_out:
                ws.cell(r, prior_out).value = f"=IFERROR({prior_expr},\"\")"
                ws.cell(r, prior_out).number_format = "#,##0"
            if yoy_out and curr_col:
                curr_addr = ws.cell(r, curr_col).coordinate
                ws.cell(r, yoy_out).value = (
                    f'=IFERROR(IF({prior_expr}="","N/A",'
                    f'IF(AND({prior_expr}=0,{curr_addr}=0),0,'
                    f'IF(AND({prior_expr}=0,{curr_addr}>0),"N/A",'
                    f'({curr_addr}-{prior_expr})/{prior_expr}))),"N/A")'
                )
                ws.cell(r, yoy_out).number_format = "0.0%"

    # ---------- Conditional formatting ----------
    def add_cf_pct(col_title: str, diff_title: Optional[str], threshold: float):
        if col_title not in col_index:
            return
        c = col_index[col_title]
        col_letter = ws.cell(header_row, c).column_letter
        rng = f"{col_letter}{first_data_row}:{col_letter}{last_data_row}"
        top = f"{col_letter}{first_data_row}"
        if diff_title and diff_title in col_index:
            d = col_index[diff_title]
            dletter = ws.cell(header_row, d).column_letter
            dtop = f"{dletter}{first_data_row}"
            red = f"=AND(ISNUMBER({top}),ABS({top})>={threshold},ABS({dtop})>={args.abs_cutoff})"
            yel = f"=AND(ISNUMBER({top}),ABS({top})>={threshold},ABS({dtop})<{args.abs_cutoff})"
        else:
            red = f"=AND(ISNUMBER({top}),ABS({top})>={threshold},ABS({top})>={threshold})"
            yel = f"=AND(ISNUMBER({top}),ABS({top})>={threshold},ABS({top})<{threshold})"

        ws.conditional_formatting.add(rng, FormulaRule(formula=[red], fill=FILL_RED))
        ws.conditional_formatting.add(rng, FormulaRule(formula=[yel], fill=FILL_YEL))

    # MoM%
    if not args.include_job_function:
        for i in range(1, len(month_headers)):
            m = month_headers[i]
            add_cf_pct(f"MoM {m}", f"Diff {m}", args.mom_pct_threshold)

    # QoQ %Diff
    for i in range(1, len(qsum_headers)):
        q = qsum_headers[i]
        add_cf_pct(f"%Diff {q}", f"Diff {q}", args.qoq_pct_threshold)

    # YoY %
    for colname in yoy_vals:
        add_cf_pct(f"YoY {colname}", None, args.yoy_pct_threshold)

    # ---------- Simple auto-width ----------
    for col in range(1, len(headers) + 1):
        width = max(10, len(str(ws.cell(header_row, col).value or "")))
        for r in range(first_data_row, min(last_data_row, first_data_row + 50) + 1):
            v = ws.cell(r, col).value
            if v is not None:
                width = max(width, len(str(v)))
        ws.column_dimensions[ws.cell(1, col).column_letter].width = min(width + 2, 28)


# Backwards-compat alias (some scripts import this name)
def write_qc_sheet(*, wb: Workbook, sheet_name: str, df: pd.DataFrame, year: int,
                   current_q: str, include_job_function: bool, months_to_show: List[str],
                   prior_df: Optional[pd.DataFrame] = None,
                   mom_pct_threshold: float = 0.25, qoq_pct_threshold: float = 0.25,
                   abs_cutoff: float = 50.0, yoy_pct_threshold: float = 0.25) -> None:
    args = QCArgs(
        wb=wb, sheet_name=sheet_name, df=df, year=year, current_q=current_q,
        include_job_function=include_job_function, months_to_show=months_to_show,
        prior_df=prior_df, mom_pct_threshold=mom_pct_threshold,
        qoq_pct_threshold=qoq_pct_threshold, yoy_pct_threshold=yoy_pct_threshold,
        abs_cutoff=abs_cutoff,
    )
    write_qc_sheet_rowwise(args)
