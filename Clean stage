#!/usr/bin/env python3
from __future__ import annotations
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Optional

import pandas as pd
import numpy as np
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.worksheet.table import Table, TableStyleInfo

# --------- Constants (match your QC structure) ----------
QC_SHEETS_ORDER = [
    "QC_Q1A_Main", "QC_Q1A_JobFunc_Q4", "QC_Q1B",
    "QC_Q2A_Main", "QC_Q2A_JobFunc_Q4", "QC_Q2B",
    "QC_Q3", "QC_Q4", "QC_Q5",
]
MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
QMAP = {"Jan":"Q1","Feb":"Q1","Mar":"Q1",
        "Apr":"Q2","May":"Q2","Jun":"Q2",
        "Jul":"Q3","Aug":"Q3","Sep":"Q3",
        "Oct":"Q4","Nov":"Q4","Dec":"Q4"}

# Simple styles for the output workbook
FILL_HEADER = PatternFill(start_color="F2F2F2", end_color="F2F2F2", fill_type="solid")
BTHIN = Border(*(Side(style="thin", color="DDDDDD") for _ in range(4)))

# --------- Helpers to read QC tables robustly ----------
def read_qc_table(xlsx: Path, sheet_name: str) -> Tuple[pd.DataFrame, Dict[str,float]]:
    """
    Return (df, thresholds) for a QC sheet.
    - Finds the header row (first row containing 'Entity / Group')
    - Reads the table beneath it
    - Grabs Threshold (±%) and Abs cutoff from the info band (cells near D2/E2)
    """
    try:
        raw = pd.read_excel(xlsx, sheet_name=sheet_name, header=None, engine="openpyxl")
    except Exception:
        return pd.DataFrame(), {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}

    if raw.empty:
        return pd.DataFrame(), {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}

    # Find header row
    header_idx = None
    for i in range(min(len(raw), 30)):  # headers are always near the top
        row_vals = raw.iloc[i].astype(str).str.strip().tolist()
        if "Entity / Group" in row_vals:
            header_idx = i
            break
    if header_idx is None:
        return pd.DataFrame(), {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}

    # Try to read thresholds from the small info band above the header:
    # The pattern in QC is "Threshold (±%)" text in col D, value in col E (0-based: 3 and 4),
    # and "Abs cutoff" text in next row same columns.
    thresh = {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}
    try:
        # search the first ~10 rows for the labels
        band = raw.iloc[:header_idx+1].copy()
        val = None
        for r in range(len(band)):
            row = band.iloc[r].astype(str).tolist()
            if any("Threshold" in str(x) for x in row):
                # value usually next cell to the right of the "Threshold..." cell
                c = next((k for k, x in enumerate(row) if "Threshold" in str(x)), None)
                if c is not None and c+1 < len(row):
                    try:
                        v = float(band.iloc[r, c+1])
                        thresh["mom"] = v
                        thresh["qoq"] = v
                        thresh["yoy"] = v
                    except Exception:
                        pass
            if any("Abs cutoff" in str(x) for x in row):
                c = next((k for k, x in enumerate(row) if "Abs cutoff" in str(x)), None)
                if c is not None and c+1 < len(row):
                    try:
                        v = float(band.iloc[r, c+1])
                        thresh["abs"] = v
                    except Exception:
                        pass
    except Exception:
        pass

    # Build clean dataframe
    header = raw.iloc[header_idx].astype(str).str.replace(r"^Unnamed:\s*\d+$", "", regex=True).tolist()
    data = raw.iloc[header_idx+1:].copy()
    data.columns = header
    # Drop entirely empty columns
    data = data.drop(columns=[c for c in data.columns if (c == "" or c.startswith("Unnamed")) and data[c].isna().all()])
    # Keep only real table rows
    if "Entity / Group" in data.columns:
        data = data[~data["Entity / Group"].isna()].reset_index(drop=True)

    # Normalize dimension name casing (just in case)
    ren = {}
    if "subquestion" in data.columns and "Subquestion" not in data.columns: ren["subquestion"] = "Subquestion"
    if "worker_category" in data.columns and "Worker Category" not in data.columns: ren["worker_category"] = "Worker Category"
    if "job_function" in data.columns and "Job Function" not in data.columns: ren["job_function"] = "Job Function"
    data = data.rename(columns=ren)

    return data, thresh

# --------- Flag logic (mirror QC conditional formatting) ----------
def build_flags(df: pd.DataFrame, thresh: Dict[str,float]) -> pd.DataFrame:
    """
    For a QC table, return a long-form table with one row per flagged cell:
      Severity (Yellow/Red), MetricType (MoM/QoQ/YoY), Period, Current, Previous, Diff, Percent, Thresholds…
    """
    if df.empty:
        return pd.DataFrame()

    # Ensure numeric
    def to_num(s): return pd.to_numeric(s, errors="coerce")
    for c in df.columns:
        if c in MONTHS or c in ("Q1","Q2","Q3","Q4") or \
           c.startswith("Diff ") or c.startswith("MoM ") or \
           c.startswith("%Diff ") or c.startswith("YoY ") or c.startswith("Prior "):
            df[c] = to_num(df[c])

    dim_cols = ["Entity / Group"]
    if "Subquestion" in df.columns:     dim_cols.append("Subquestion")
    if "Worker Category" in df.columns: dim_cols.append("Worker Category")
    if "Job Function" in df.columns:    dim_cols.append("Job Function")

    out_rows: List[Dict] = []

    # ---- MoM (monthly) ----
    mom_cols = [c for c in df.columns if isinstance(c, str) and c.startswith("MoM ")]
    for mc in mom_cols:
        m = mc.replace("MoM ","",1).strip()
        prev_m = None
        try:
            idx = MONTHS.index(m)
            if idx > 0: prev_m = MONTHS[idx-1]
        except Exception:
            prev_m = None
        diff_col = f"Diff {m}"
        for i, row in df.iterrows():
            pct = row.get(mc, np.nan)
            if pd.isna(pct): continue
            passes = abs(pct) >= float(thresh["mom"])
            if not passes: continue
            diff = row.get(diff_col, np.nan)
            severity = "Yellow"
            if pd.notna(diff) and abs(diff) >= float(thresh["abs"]):
                severity = "Red"
            out_rows.append({
                "Severity": severity,
                "MetricType": "MoM",
                "Period": m,
                "Quarter": QMAP.get(m, ""),
                "Percent": pct,
                "Diff": diff if pd.notna(diff) else None,
                "Current": row.get(m, None),
                "Previous": row.get(prev_m, None) if prev_m else None,
                "AbsCutoff": float(thresh["abs"]),
                "PctThreshold": float(thresh["mom"]),
                **{k: row.get(k,"") for k in dim_cols}
            })

    # ---- QoQ (quarters) ----
    q_pct_cols = [c for c in df.columns if isinstance(c, str) and c.startswith("%Diff ")]
    for qc in q_pct_cols:
        q = qc.replace("%Diff ","",1).strip()
        diff_col = f"Diff {q}"
        for i, row in df.iterrows():
            pct = row.get(qc, np.nan)
            if pd.isna(pct): continue
            passes = abs(pct) >= float(thresh["qoq"])
            if not passes: continue
            diff = row.get(diff_col, np.nan)
            severity = "Yellow"
            if pd.notna(diff) and abs(diff) >= float(thresh["abs"]):
                severity = "Red"
            out_rows.append({
                "Severity": severity,
                "MetricType": "QoQ",
                "Period": q,
                "Quarter": q,
                "Percent": pct,
                "Diff": diff if pd.notna(diff) else None,
                "Current": row.get(q, None),
                # Previous quarter value not stored explicitly; leave None
                "Previous": None,
                "AbsCutoff": float(thresh["abs"]),
                "PctThreshold": float(thresh["qoq"]),
                **{k: row.get(k,"") for k in dim_cols}
            })

    # ---- YoY (month or quarter) ----
    yoy_cols = [c for c in df.columns if isinstance(c, str) and c.startswith("YoY ")]
    for yc in yoy_cols:
        lab = yc.replace("YoY ","",1).strip()  # could be 'Feb' or 'Q2' or 'Q4'
        for i, row in df.iterrows():
            pct = row.get(yc, np.nan)
            if pd.isna(pct): continue
            passes = abs(pct) >= float(thresh["yoy"])
            if not passes: continue
            out_rows.append({
                "Severity": "Yellow",  # no diff cutoff for YoY in QC CF
                "MetricType": "YoY",
                "Period": lab,
                "Quarter": QMAP.get(lab, lab if lab in ("Q1","Q2","Q3","Q4") else ""),
                "Percent": pct,
                "Diff": None,
                "Current": row.get(lab, None) if lab in df.columns else None,
                "Previous": row.get(f"Prior {lab}", None) if f"Prior {lab}" in df.columns else None,
                "AbsCutoff": None,
                "PctThreshold": float(thresh["yoy"]),
                **{k: row.get(k,"") for k in dim_cols}
            })

    if not out_rows:
        return pd.DataFrame(columns=["Severity","MetricType","Period","Quarter","Percent","Diff","Current","Previous","AbsCutoff","PctThreshold"] + dim_cols)

    alerts = pd.DataFrame(out_rows)

    # Order columns nicely
    ordered = dim_cols + ["MetricType","Period","Quarter","Current","Previous","Diff","Percent","PctThreshold","AbsCutoff","Severity"]
    for c in ordered:
        if c not in alerts.columns:
            alerts[c] = np.nan
    alerts = alerts[ordered]
    return alerts

# --------- Output writer ----------
def write_alert_workbook(out_path: Path, sheets: Dict[str, pd.DataFrame]) -> None:
    wb = Workbook()
    # remove default
    wb.remove(wb.active)

    for name in QC_SHEETS_ORDER:
        if name not in sheets: continue
        df = sheets[name]
        title = f"ALERT_{name}"
        ws = wb.create_sheet(title)
        if df.empty:
            ws["A1"] = f"{title} (no flags)"; ws["A1"].font = Font(bold=True)
            continue

        # Header
        ws.append(list(df.columns))
        header_row = 1
        for j, h in enumerate(df.columns, start=1):
            c = ws.cell(header_row, j)
            c.font = Font(bold=True)
            c.alignment = Alignment(horizontal="center", vertical="center")
            c.fill = FILL_HEADER
            c.border = BTHIN

        # Data
        for _, r in df.iterrows():
            ws.append([r.get(c, "") for c in df.columns])

        # As a formal table (filters on)
        last_row = ws.max_row
        last_col = ws.max_column
        ref = f"A1:{ws.cell(last_row, last_col).coordinate}"
        tbl = Table(displayName=title.replace(" ","_"), ref=ref)
        tbl.tableStyleInfo = TableStyleInfo(name="TableStyleLight9", showRowStripes=True)
        ws.add_table(tbl)

        # Column formats
        fmt_num = {"Current":"#,##0", "Previous":"#,##0", "Diff":"#,##0"}
        fmt_pct = {"Percent":"0.0%", "PctThreshold":"0.0%"}
        for j, h in enumerate(df.columns, start=1):
            nf = None
            if h in fmt_num: nf = fmt_num[h]
            if h in fmt_pct: nf = fmt_pct[h]
            if nf:
                for r in range(2, last_row+1):
                    ws.cell(r, j).number_format = nf

        # Auto width
        for j in range(1, last_col+1):
            maxw = max(len(str(ws.cell(1, j).value or "")), 10)
            for r in range(2, min(200, last_row+1)):
                v = ws.cell(r, j).value
                if v is not None:
                    maxw = max(maxw, len(str(v)))
            ws.column_dimensions[ws.cell(1, j).column_letter].width = min(maxw+2, 40)

    wb.save(out_path)

# --------- CLI ----------
def main() -> int:
    if len(sys.argv) < 2:
        print("Usage: python qc_extract_flags.py <QC_WORKBOOK.xlsx> [OUTPUT.xlsx]")
        return 2
    qc_path = Path(sys.argv[1])
    out_path = Path(sys.argv[2]) if len(sys.argv) >= 3 else qc_path.with_name(f"ALERTS_{qc_path.name}")

    all_alerts: Dict[str, pd.DataFrame] = {}
    for sheet in QC_SHEETS_ORDER:
        df, thr = read_qc_table(qc_path, sheet)
        if df.empty:
            continue
        alerts = build_flags(df, thr)
        all_alerts[sheet] = alerts

    if not all_alerts:
        print("[INFO] No QC sheets found or no flags detected.")
        # still create an empty workbook with a note
        write_alert_workbook(out_path, {})
        return 0

    write_alert_workbook(out_path, all_alerts)
    print(f"[DONE] {out_path}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
