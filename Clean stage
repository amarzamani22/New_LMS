#!/usr/bin/env python3
from __future__ import annotations
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Optional

import pandas as pd
import numpy as np
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.worksheet.table import Table, TableStyleInfo

# --------- Constants (match your QC structure) ----------
QC_SHEETS_ORDER = [
    "QC_Q1A_Main", "QC_Q1A_JobFunc_Q4", "QC_Q1B",
    "QC_Q2A_Main", "QC_Q2A_JobFunc_Q4", "QC_Q2B",
    "QC_Q3", "QC_Q4", "QC_Q5",
]
MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
QMAP = {"Jan":"Q1","Feb":"Q1","Mar":"Q1",
        "Apr":"Q2","May":"Q2","Jun":"Q2",
        "Jul":"Q3","Aug":"Q3","Sep":"Q3",
        "Oct":"Q4","Nov":"Q4","Dec":"Q4"}

# Simple styles for the output workbook
FILL_HEADER = PatternFill(start_color="F2F2F2", end_color="F2F2F2", fill_type="solid")
BTHIN = Border(*(Side(style="thin", color="DDDDDD") for _ in range(4)))

# --------- Helpers to read QC tables robustly ----------
def read_qc_table(xlsx: Path, sheet_name: str) -> Tuple[pd.DataFrame, Dict[str,float]]:
    """
    Return (df, thresholds) for a QC sheet.
    - Finds the header row (first row containing 'Entity / Group')
    - Reads the table beneath it
    - Grabs Threshold (±%) and Abs cutoff from the info band above
    """
    try:
        raw = pd.read_excel(xlsx, sheet_name=sheet_name, header=None, engine="openpyxl")
    except Exception:
        return pd.DataFrame(), {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}

    if raw.empty:
        return pd.DataFrame(), {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}

    # Find header row
    header_idx = None
    for i in range(min(len(raw), 40)):  # headers near top
        row_vals = raw.iloc[i].astype(str).str.strip().tolist()
        if "Entity / Group" in row_vals:
            header_idx = i
            break
    if header_idx is None:
        return pd.DataFrame(), {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}

    # Thresholds from info band
    thresh = {"mom":0.25, "qoq":0.25, "yoy":0.25, "abs":50.0}
    try:
        band = raw.iloc[:header_idx+1].copy()
        for r in range(len(band)):
            row = band.iloc[r].astype(str).tolist()
            if any("Threshold" in str(x) for x in row):
                c = next((k for k, x in enumerate(row) if "Threshold" in str(x)), None)
                if c is not None and c+1 < len(row):
                    try:
                        v = float(band.iloc[r, c+1])
                        thresh["mom"] = v; thresh["qoq"] = v; thresh["yoy"] = v
                    except Exception:
                        pass
            if any("Abs cutoff" in str(x) for x in row):
                c = next((k for k, x in enumerate(row) if "Abs cutoff" in str(x)), None)
                if c is not None and c+1 < len(row):
                    try:
                        v = float(band.iloc[r, c+1]); thresh["abs"] = v
                    except Exception:
                        pass
    except Exception:
        pass

    # Clean dataframe
    header = raw.iloc[header_idx].astype(str).str.replace(r"^Unnamed:\s*\d+$", "", regex=True).tolist()
    data = raw.iloc[header_idx+1:].copy()
    data.columns = header
    # Drop empty columns
    data = data.drop(columns=[c for c in data.columns if (c == "" or c.startswith("Unnamed")) and data[c].isna().all()])
    # Keep rows that look like table rows
    if "Entity / Group" in data.columns:
        data = data[~data["Entity / Group"].isna()].reset_index(drop=True)

    # Normalize dimension names if lowercased
    ren = {}
    if "subquestion" in data.columns and "Subquestion" not in data.columns: ren["subquestion"] = "Subquestion"
    if "worker_category" in data.columns and "Worker Category" not in data.columns: ren["worker_category"] = "Worker Category"
    if "job_function" in data.columns and "Job Function" not in data.columns: ren["job_function"] = "Job Function"
    data = data.rename(columns=ren)

    return data, thresh

# --------- Flag logic (mirror QC conditional formatting) ----------
def build_flags(df: pd.DataFrame, thresh: Dict[str,float]) -> pd.DataFrame:
    """
    For a QC table, return a long-form table with one row per flagged cell:
      Severity (Yellow/Red), MetricType (MoM/QoQ/YoY), Period, Current, Previous, Diff, Percent, Thresholds, dims…
    """
    if df.empty:
        return pd.DataFrame()

    # Ensure numeric
    def to_num(s): return pd.to_numeric(s, errors="coerce")
    for c in df.columns:
        if c in MONTHS or c in ("Q1","Q2","Q3","Q4") or \
           c.startswith("Diff ") or c.startswith("MoM ") or \
           c.startswith("%Diff ") or c.startswith("YoY ") or c.startswith("Prior "):
            df[c] = to_num(df[c])

    dim_cols = ["Entity / Group"]
    if "Subquestion" in df.columns:     dim_cols.append("Subquestion")
    if "Worker Category" in df.columns: dim_cols.append("Worker Category")
    if "Job Function" in df.columns:    dim_cols.append("Job Function")

    out_rows: List[Dict] = []

    # ---- MoM (monthly) ----
    mom_cols = [c for c in df.columns if isinstance(c, str) and c.startswith("MoM ")]
    for mc in mom_cols:
        m = mc.replace("MoM ","",1).strip()
        prev_m = None
        try:
            idx = MONTHS.index(m)
            if idx > 0: prev_m = MONTHS[idx-1]
        except Exception:
            prev_m = None
        diff_col = f"Diff {m}"
        for _, row in df.iterrows():
            pct = row.get(mc, np.nan)
            if pd.isna(pct): continue
            if abs(pct) < float(thresh["mom"]): continue
            diff = row.get(diff_col, np.nan)
            severity = "Yellow"
            if pd.notna(diff) and abs(diff) >= float(thresh["abs"]):
                severity = "Red"
            out_rows.append({
                "Severity": severity,
                "MetricType": "MoM",
                "Period": m,
                "Quarter": QMAP.get(m, ""),
                "Percent": pct,
                "Diff": diff if pd.notna(diff) else None,
                "Current": row.get(m, None),
                "Previous": row.get(prev_m, None) if prev_m else None,
                "AbsCutoff": float(thresh["abs"]),
                "PctThreshold": float(thresh["mom"]),
                **{k: row.get(k,"") for k in dim_cols}
            })

    # ---- QoQ (quarters) ----
    q_pct_cols = [c for c in df.columns if isinstance(c, str) and c.startswith("%Diff ")]
    for qc in q_pct_cols:
        q = qc.replace("%Diff ","",1).strip()
        diff_col = f"Diff {q}"
        for _, row in df.iterrows():
            pct = row.get(qc, np.nan)
            if pd.isna(pct): continue
            if abs(pct) < float(thresh["qoq"]): continue
            diff = row.get(diff_col, np.nan)
            severity = "Yellow"
            if pd.notna(diff) and abs(diff) >= float(thresh["abs"]):
                severity = "Red"
            out_rows.append({
                "Severity": severity,
                "MetricType": "QoQ",
                "Period": q,
                "Quarter": q,
                "Percent": pct,
                "Diff": diff if pd.notna(diff) else None,
                "Current": row.get(q, None),
                "Previous": None,  # not available explicitly in QC table
                "AbsCutoff": float(thresh["abs"]),
                "PctThreshold": float(thresh["qoq"]),
                **{k: row.get(k,"") for k in dim_cols}
            })

    # ---- YoY (month or quarter) ----
    yoy_cols = [c for c in df.columns if isinstance(c, str) and c.startswith("YoY ")]
    for yc in yoy_cols:
        lab = yc.replace("YoY ","",1).strip()  # could be 'Feb' or 'Q2' or 'Q4'
        for _, row in df.iterrows():
            pct = row.get(yc, np.nan)
            if pd.isna(pct): continue
            if abs(pct) < float(thresh["yoy"]): continue
            out_rows.append({
                "Severity": "Yellow",  # QC rule: only % for YoY (no abs diff)
                "MetricType": "YoY",
                "Period": lab,
                "Quarter": QMAP.get(lab, lab if lab in ("Q1","Q2","Q3","Q4") else ""),
                "Percent": pct,
                "Diff": None,
                "Current": row.get(lab, None) if lab in df.columns else None,
                "Previous": row.get(f"Prior {lab}", None) if f"Prior {lab}" in df.columns else None,
                "AbsCutoff": None,
                "PctThreshold": float(thresh["yoy"]),
                **{k: row.get(k,"") for k in dim_cols}
            })

    if not out_rows:
        cols = dim_cols + ["MetricType","Period","Quarter","Current","Previous","Diff","Percent","PctThreshold","AbsCutoff","Severity"]
        return pd.DataFrame(columns=cols)

    alerts = pd.DataFrame(out_rows)
    # Order columns nicely
    ordered = dim_cols + ["MetricType","Period","Quarter","Current","Previous","Diff","Percent","PctThreshold","AbsCutoff","Severity"]
    alerts = alerts[ordered]
    return alerts

def build_context(df: pd.DataFrame, alerts: pd.DataFrame) -> pd.DataFrame:
    """Return the raw QC rows (full numeric context) for entities that were flagged."""
    if df.empty or alerts.empty:
        return pd.DataFrame()

    # Dimension keys present in both frames
    dim_candidates = ["Entity / Group","Subquestion","Worker Category","Job Function"]
    keys = [c for c in dim_candidates if c in df.columns and c in alerts.columns]

    if not keys:
        return pd.DataFrame()

    # Create a set of flagged keys
    flagged = set(tuple(x) for x in alerts[keys].astype(str).itertuples(index=False, name=None))

    # Filter df rows that match flagged keys
    mask = df[keys].astype(str).apply(lambda r: tuple(r.values.tolist()) in flagged, axis=1)
    ctx = df.loc[mask].copy()

    # Keep only “useful” columns: dims + numeric signals
    useful = keys[:]
    numeric_cols = []
    for c in ctx.columns:
        if c in MONTHS or c in ("Q1","Q2","Q3","Q4") or \
           c.startswith("Diff ") or c.startswith("MoM ") or \
           c.startswith("%Diff ") or c.startswith("YoY ") or c.startswith("Prior "):
            numeric_cols.append(c)
    # Preserve original order
    ctx = ctx[useful + numeric_cols]

    return ctx

# --------- Output writer ----------
def write_alert_workbook(out_path: Path, sheets: Dict[str, Tuple[pd.DataFrame,pd.DataFrame]]) -> None:
    wb = Workbook()
    wb.remove(wb.active)

    for name in QC_SHEETS_ORDER:
        if name not in sheets:
            continue
        alerts, context = sheets[name]

        # --- ALERT sheet ---
        title_a = f"ALERT_{name}"
        ws = wb.create_sheet(title_a)
        if alerts.empty:
            ws["A1"] = f"{title_a} (no flags)"; ws["A1"].font = Font(bold=True)
        else:
            ws.append(list(alerts.columns))
            header_row = 1
            for j, h in enumerate(alerts.columns, start=1):
                c = ws.cell(header_row, j)
                c.font = Font(bold=True)
                c.alignment = Alignment(horizontal="center", vertical="center")
                c.fill = FILL_HEADER
                c.border = BTHIN

            for _, r in alerts.iterrows():
                ws.append([r.get(c, "") for c in alerts.columns])

            last_row = ws.max_row
            last_col = ws.max_column
            ref = f"A1:{ws.cell(last_row, last_col).coordinate}"
            tbl = Table(displayName=title_a.replace(" ","_"), ref=ref)
            tbl.tableStyleInfo = TableStyleInfo(name="TableStyleLight9", showRowStripes=True)
            ws.add_table(tbl)

            # Formats
            fmt_num = {"Current":"#,##0", "Previous":"#,##0", "Diff":"#,##0"}
            fmt_pct = {"Percent":"0.0%", "PctThreshold":"0.0%"}
            for j, h in enumerate(alerts.columns, start=1):
                nf = None
                if h in fmt_num: nf = fmt_num[h]
                if h in fmt_pct: nf = fmt_pct[h]
                if nf:
                    for r in range(2, last_row+1):
                        ws.cell(r, j).number_format = nf

            # Widths
            for j in range(1, last_col+1):
                maxw = max(len(str(ws.cell(1, j).value or "")), 12)
                for r in range(2, min(200, last_row+1)):
                    v = ws.cell(r, j).value
                    if v is not None:
                        maxw = max(maxw, len(str(v)))
                ws.column_dimensions[ws.cell(1, j).column_letter].width = min(maxw+2, 44)

        # --- CONTEXT sheet ---
        title_c = f"CONTEXT_{name}"
        ws2 = wb.create_sheet(title_c)
        if context.empty:
            ws2["A1"] = f"{title_c} (no flagged rows to show)"; ws2["A1"].font = Font(bold=True)
        else:
            ws2.append(list(context.columns))
            header_row = 1
            for j, h in enumerate(context.columns, start=1):
                c = ws2.cell(header_row, j)
                c.font = Font(bold=True)
                c.alignment = Alignment(horizontal="center", vertical="center")
                c.fill = FILL_HEADER
                c.border = BTHIN

            for _, r in context.iterrows():
                ws2.append([r.get(c, "") for c in context.columns])

            last_row = ws2.max_row
            last_col = ws2.max_column
            ref = f"A1:{ws2.cell(last_row, last_col).coordinate}"
            tbl = Table(displayName=title_c.replace(" ","_"), ref=ref)
            tbl.tableStyleInfo = TableStyleInfo(name="TableStyleLight9", showRowStripes=True)
            ws2.add_table(tbl)

            # Simple formats
            for j, h in enumerate(context.columns, start=1):
                if h in MONTHS or h in ("Q1","Q2","Q3","Q4") or h.startswith("Diff "):
                    for r in range(2, last_row+1):
                        ws2.cell(r, j).number_format = "#,##0"
                elif h.startswith("MoM ") or h.startswith("%Diff ") or h.startswith("YoY "):
                    for r in range(2, last_row+1):
                        ws2.cell(r, j).number_format = "0.0%"

            for j in range(1, last_col+1):
                maxw = max(len(str(ws2.cell(1, j).value or "")), 12)
                for r in range(2, min(200, last_row+1)):
                    v = ws2.cell(r, j).value
                    if v is not None:
                        maxw = max(maxw, len(str(v)))
                ws2.column_dimensions[ws2.cell(1, j).column_letter].width = min(maxw+2, 44)

    wb.save(out_path)

# --------- CLI ----------
def main() -> int:
    if len(sys.argv) < 2:
        print("Usage: python qc_extract_flags.py <QC_WORKBOOK.xlsx> [OUTPUT.xlsx]")
        return 2
    qc_path = Path(sys.argv[1])
    out_path = Path(sys.argv[2]) if len(sys.argv) >= 3 else qc_path.with_name(f"ALERTS_{qc_path.name}")

    all_out: Dict[str, Tuple[pd.DataFrame,pd.DataFrame]] = {}
    for sheet in QC_SHEETS_ORDER:
        df, thr = read_qc_table(qc_path, sheet)
        if df.empty:
            continue
        alerts = build_flags(df, thr)
        context = build_context(df, alerts)
        all_out[sheet] = (alerts, context)

    if not all_out:
        print("[INFO] No QC sheets found or no flags detected.")
        # still create a thin workbook so you have a file
        write_alert_workbook(out_path, {})
        return 0

    write_alert_workbook(out_path, all_out)
    print(f"[DONE] {out_path}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
