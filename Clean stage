#!/usr/bin/env python3
from __future__ import annotations
import sys
from pathlib import Path
import argparse
from typing import List, Dict, Tuple, Optional

import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.worksheet.table import Table, TableStyleInfo

# ---------- constants ----------
MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
QMAP = {"Jan":"Q1","Feb":"Q1","Mar":"Q1","Apr":"Q2","May":"Q2","Jun":"Q2",
        "Jul":"Q3","Aug":"Q3","Sep":"Q3","Oct":"Q4","Nov":"Q4","Dec":"Q4"}

# styling
FILL_HEADER = PatternFill(start_color="F2F2F2", end_color="F2F2F2", fill_type="solid")
BTHIN = Border(
    left=Side(style="thin", color="DDDDDD"),
    right=Side(style="thin", color="DDDDDD"),
    top=Side(style="thin", color="DDDDDD"),
    bottom=Side(style="thin", color="DDDDDD"),
)

# ---------- helpers ----------
def read_qc_sheet(qc_path: Path, sheet_name: str) -> pd.DataFrame:
    """
    Load a QC sheet robustly:
    - find the header row where a cell equals 'Entity / Group'
    - set that as header, drop rows above it (band row included)
    """
    try:
        df_raw = pd.read_excel(qc_path, sheet_name=sheet_name, header=None, engine="openpyxl")
    except Exception:
        return pd.DataFrame()

    header_row_idx = None
    for i in range(min(len(df_raw), 30)):
        row_vals = df_raw.iloc[i].astype(str).str.strip().tolist()
        if "Entity / Group" in row_vals:
            header_row_idx = i
            break
    if header_row_idx is None:
        return pd.DataFrame()

    df = pd.read_excel(qc_path, sheet_name=sheet_name, header=header_row_idx, engine="openpyxl")
    df = df.dropna(how="all")
    df.columns = [str(c).strip() for c in df.columns]
    return df

def read_thresholds_from_sheet(qc_path: Path, sheet_name: str,
                               fallback_thr: float, fallback_abs: float) -> tuple[float,float]:
    """
    Read Threshold (Â±%) from E2 and Abs cutoff from E3 in the QC sheet's info band.
    If not present/parsable, fall back to provided defaults.
    """
    try:
        raw = pd.read_excel(qc_path, sheet_name=sheet_name, header=None, engine="openpyxl")
    except Exception:
        return (fallback_thr, fallback_abs)

    # E2 -> row index 1, col index 4 (0-based)
    # E3 -> row index 2, col index 4
    thr = fallback_thr
    abv = fallback_abs
    try:
        v = raw.iat[1, 4]
        if pd.notna(v):
            thr = float(v)
    except Exception:
        pass
    try:
        v = raw.iat[2, 4]
        if pd.notna(v):
            abv = float(v)
    except Exception:
        pass
    return (thr, abv)

def to_num_series(s: pd.Series) -> pd.Series:
    return pd.to_numeric(s.replace({"N/A": None, "": None}), errors="coerce")

def col_exists(df: pd.DataFrame, name: str) -> bool:
    return name in df.columns

def percent_to_fixed(x: float | None, decimals: int) -> Optional[float]:
    if pd.isna(x):
        return None
    try:
        # Keep fraction form (e.g., 0.125) and round; Excel formatting will show as %.
        return round(float(x), max(0, decimals + 3))
    except Exception:
        return None

def month_cols_present(df: pd.DataFrame) -> List[str]:
    return [m for m in MONTHS if m in df.columns]

def quarter_cols_present(df: pd.DataFrame) -> List[str]:
    return [q for q in ["Q1","Q2","Q3","Q4"] if q in df.columns]

def add_alert_row(rows: List[Dict], base: Dict, quarter: str, month: str | None,
                  status: str, mom: Optional[float], qoq: Optional[float], yoy: Optional[float],
                  raw: Optional[float], pct_decimals: int):
    rows.append({
        "Quarter": quarter or "",
        "Month": month or "",
        "Entity / Group": base.get("Entity / Group",""),
        "Subquestion": base.get("Subquestion",""),
        "Worker Category": base.get("Worker Category",""),
        "Status": status,
        "MoM %": percent_to_fixed(mom, pct_decimals) if mom is not None else None,
        "QoQ %": percent_to_fixed(qoq, pct_decimals) if qoq is not None else None,
        "YoY %": percent_to_fixed(yoy, pct_decimals) if yoy is not None else None,
        "Raw Value": raw if raw is not None else None,
        **({"Job Function": base.get("Job Function","")} if "Job Function" in base else {}),
    })

def is_red_yellow(pct: float, diff: Optional[float], pct_thr: float, abs_cut: float) -> Optional[str]:
    if pd.isna(pct):
        return None
    ap = abs(pct)
    if ap < pct_thr:
        return None
    if diff is not None and not pd.isna(diff) and abs(diff) >= abs_cut:
        return "RED"
    return "YELLOW"

# ---------- core extractor ----------
def extract_flags_from_sheet(
    df: pd.DataFrame,
    mom_thr: float, qoq_thr: float, yoy_thr: float, abs_cut: float,
    pct_decimals: int
) -> pd.DataFrame:
    """
    From a QC sheet dataframe, produce only flagged rows with the unified layout.
    """
    if df.empty:
        return pd.DataFrame()

    # Ensure required dim columns exist
    for c in ["Entity / Group","Subquestion","Worker Category"]:
        if c not in df.columns:
            df[c] = ""
    has_jobfunc = "Job Function" in df.columns

    months = month_cols_present(df)
    quarters = quarter_cols_present(df)

    out_rows: List[Dict] = []

    for _, row in df.iterrows():
        base = {
            "Entity / Group": row.get("Entity / Group", ""),
            "Subquestion":    row.get("Subquestion", ""),
            "Worker Category":row.get("Worker Category", ""),
        }
        if has_jobfunc:
            base["Job Function"] = row.get("Job Function","")

        # --------- MoM (monthly) ----------
        for i in range(1, len(months)):
            m = months[i]
            mom_col = f"MoM {m}"
            diff_col = f"Diff {m}"
            if not (col_exists(df, mom_col) and col_exists(df, diff_col)):
                continue
            mom_val = row.get(mom_col, None)
            diff_val = row.get(diff_col, None)
            raw_val  = row.get(m, None)

            mom_val = None if pd.isna(mom_val) else float(mom_val)
            diff_val = None if pd.isna(diff_val) else float(diff_val)
            raw_val = None if pd.isna(raw_val) else float(raw_val)

            status = is_red_yellow(mom_val, diff_val, mom_thr, abs_cut)
            if status:
                add_alert_row(out_rows, base, QMAP[m], m, status, mom=mom_val, qoq=None, yoy=None,
                              raw=raw_val, pct_decimals=pct_decimals)

        # --------- QoQ (quarters) ----------
        for i in range(1, len(quarters)):
            q = quarters[i]
            pct_col = f"%Diff {q}"
            diff_col = f"Diff {q}"
            if not (col_exists(df, pct_col) and col_exists(df, diff_col) and col_exists(df, q)):
                continue
            pq = row.get(pct_col, None)
            dq = row.get(diff_col, None)
            raw_q = row.get(q, None)

            pq = None if pd.isna(pq) else float(pq)
            dq = None if pd.isna(dq) else float(dq)
            raw_q = None if pd.isna(raw_q) else float(raw_q)

            status = is_red_yellow(pq, dq, qoq_thr, abs_cut)
            if status:
                add_alert_row(out_rows, base, q, None, status, mom=None, qoq=pq, yoy=None,
                              raw=raw_q, pct_decimals=pct_decimals)

        # --------- YoY (month and/or quarter) ----------
        # Monthly YoY
        for m in months:
            yoyc = f"YoY {m}"
            pc   = f"Prior {m}"
            if col_exists(df, yoyc) and col_exists(df, m) and col_exists(df, pc):
                yo = row.get(yoyc, None)
                curr = row.get(m, None)
                prior = row.get(pc, None)

                yo = None if pd.isna(yo) else float(yo)
                curr = None if pd.isna(curr) else float(curr)
                prior = None if pd.isna(prior) else float(prior)
                abs_change = (None if (curr is None or prior is None) else (curr - prior))

                status = is_red_yellow(yo, abs_change, yoy_thr, abs_cut)
                if status:
                    add_alert_row(out_rows, base, QMAP[m], m, status, mom=None, qoq=None, yoy=yo,
                                  raw=curr, pct_decimals=pct_decimals)

        # Quarterly YoY (includes Job Function Q4 sheets)
        for q in ["Q1","Q2","Q3","Q4"]:
            yoyq = f"YoY {q}"
            priorq = f"Prior {q}"
            raw_col = q if col_exists(df, q) else ("Q4" if (q == "Q4" and col_exists(df,"Q4")) else None)
            if not raw_col:
                continue
            if col_exists(df, yoyq) and col_exists(df, priorq) and col_exists(df, raw_col):
                yo = row.get(yoyq, None)
                curr = row.get(raw_col, None)
                prior = row.get(priorq, None)

                yo = None if pd.isna(yo) else float(yo)
                curr = None if pd.isna(curr) else float(curr)
                prior = None if pd.isna(prior) else float(prior)
                abs_change = (None if (curr is None or prior is None) else (curr - prior))

                status = is_red_yellow(yo, abs_change, yoy_thr, abs_cut)
                if status:
                    add_alert_row(out_rows, base, q, None, status, mom=None, qoq=None, yoy=yo,
                                  raw=curr, pct_decimals=pct_decimals)

    if not out_rows:
        cols = ["Quarter","Month","Entity / Group","Subquestion","Worker Category","Status","MoM %","QoQ %","YoY %","Raw Value"]
        if has_jobfunc:
            cols += ["Job Function"]
        return pd.DataFrame(columns=cols)

    out_df = pd.DataFrame(out_rows)

    # sort for readability
    q_rank = {"Q1":1,"Q2":2,"Q3":3,"Q4":4,"":0}
    m_rank = {m:i for i,m in enumerate(MONTHS, start=1)}
    out_df["__q"] = out_df["Quarter"].map(q_rank).fillna(0).astype(int)
    out_df["__m"] = out_df["Month"].map(m_rank).fillna(0).astype(int)
    out_df = out_df.sort_values(["Entity / Group","Subquestion","Worker Category","__q","__m"], kind="mergesort").drop(columns=["__q","__m"])
    return out_df

# ---------- Excel writer ----------
def write_flag_sheets(out_xlsx: Path, sheets: Dict[str, pd.DataFrame], pct_decimals: int):
    wb = Workbook()
    ws0 = wb.active
    wb.remove(ws0)

    for name, df in sheets.items():
        ws = wb.create_sheet(name if len(name) <= 31 else name[:31])
        headers = df.columns.tolist()
        ws.append(headers)
        for j, h in enumerate(headers, start=1):
            c = ws.cell(1, j)
            c.font = Font(bold=True)
            c.alignment = Alignment(horizontal="center", vertical="center")
            c.fill = FILL_HEADER
            c.border = BTHIN
        for _, r in df.iterrows():
            ws.append([r.get(h, None) for h in headers])

        # number formats
        pct_fmt = f"0.{''.join(['0']*pct_decimals)}%"
        for title in ["MoM %","QoQ %","YoY %"]:
            if title in headers:
                j = headers.index(title) + 1
                for i in range(2, ws.max_row + 1):
                    ws.cell(i, j).number_format = pct_fmt
        if "Raw Value" in headers:
            j = headers.index("Raw Value") + 1
            for i in range(2, ws.max_row + 1):
                ws.cell(i, j).number_format = "#,##0"

        # table styling
        ref = f"A1:{ws.cell(ws.max_row, ws.max_column).coordinate}"
        tbl = Table(displayName=(name.replace(" ","_")[:30] or "TBL"), ref=ref)
        tbl.tableStyleInfo = TableStyleInfo(name="TableStyleLight9", showRowStripes=True)
        ws.add_table(tbl)

        # auto width
        for col in range(1, ws.max_column + 1):
            maxw = max(len(str(ws.cell(1, col).value or "")), 10)
            for i in range(2, min(ws.max_row, 100) + 1):
                v = ws.cell(i, col).value
                if v is not None:
                    maxw = max(maxw, len(str(v)))
            ws.column_dimensions[ws.cell(1, col).column_letter].width = min(maxw + 2, 28)

    wb.save(out_xlsx)

# ---------- main ----------
def main() -> int:
    ap = argparse.ArgumentParser(description="Extract only flagged (RED/YELLOW) alerts from QC workbook into tidy sheets, using per-sheet thresholds from the QC workbook.")
    ap.add_argument("--qc", required=True, help="Path to QC workbook (xlsx)")
    ap.add_argument("--out", required=True, help="Output XLSX with flagged rows only")
    # CLI values act as fallback if a QC sheet lacks E2/E3
    ap.add_argument("--default-threshold", type=float, default=0.25, help="Fallback Â±% threshold if sheet E2 missing")
    ap.add_argument("--default-abs-cutoff", type=float, default=50.0, help="Fallback abs cutoff if sheet E3 missing")
    ap.add_argument("--pct-decimals", type=int, default=1, help="Fixed decimal places for % columns")
    args = ap.parse_args()

    qc_path = Path(args.qc)
    if not qc_path.exists():
        print(f"[ERROR] QC workbook not found: {qc_path}")
        return 2

    xls = pd.ExcelFile(qc_path, engine="openpyxl")
    qc_sheets = [s for s in xls.sheet_names if s.startswith("QC_")]
    if not qc_sheets:
        print("[WARN] No QC_* sheets found.")
        return 0

    out_map: Dict[str, pd.DataFrame] = {}

    for s in qc_sheets:
        df = read_qc_sheet(qc_path, s)
        if df.empty:
            # still create empty sheet for consistency
            out_map[s.replace("QC_","ALERTS_")] = pd.DataFrame(columns=["Quarter","Month","Entity / Group","Subquestion","Worker Category","Status","MoM %","QoQ %","YoY %","Raw Value"])
            continue

        # Read thresholds from the QC sheet info band (E2/E3)
        sheet_thr, sheet_abs = read_thresholds_from_sheet(qc_path, s, args.default_threshold, args.default_abs_cutoff)
        # Use the SAME threshold for MoM, QoQ, YoY (as the QC info band provides a single Â±%)
        mom_thr = sheet_thr
        qoq_thr = sheet_thr
        yoy_thr = sheet_thr

        flagged = extract_flags_from_sheet(
            df,
            mom_thr=mom_thr,
            qoq_thr=qoq_thr,
            yoy_thr=yoy_thr,
            abs_cut=sheet_abs,
            pct_decimals=args.pct_decimals
        )

        if flagged.empty:
            base_cols = ["Quarter","Month","Entity / Group","Subquestion","Worker Category","Status","MoM %","QoQ %","YoY %","Raw Value"]
            if "Job Function" in df.columns:
                flagged = pd.DataFrame(columns=base_cols + ["Job Function"])
            else:
                flagged = pd.DataFrame(columns=base_cols)

        out_map[s.replace("QC_","ALERTS_")] = flagged

    write_flag_sheets(Path(args.out), out_map, pct_decimals=args.pct_decimals)
    print(f"[DONE] Wrote flagged alerts â {args.out}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
