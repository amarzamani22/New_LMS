#!/usr/bin/env python3
from __future__ import annotations
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import pandas as pd

# ------------------
# Constants / helpers
# ------------------
MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
Q_TO_MONTHS = {
    "Q1": ["Jan","Feb","Mar"],
    "Q2": ["Apr","May","Jun"],
    "Q3": ["Jul","Aug","Sep"],
    "Q4": ["Oct","Nov","Dec"],
}
ALL_Q = ["Q1","Q2","Q3","Q4"]

SHEETS = {
    # question -> list of qc sheet names
    "Q1": ["QC_Q1A_Main", "QC_Q1A_JobFunc_Q4", "QC_Q1B"],
    "Q2": ["QC_Q2A_Main", "QC_Q2A_JobFunc_Q4", "QC_Q2B"],
    "Q3": ["QC_Q3"],
    "Q4": ["QC_Q4"],
    "Q5": ["QC_Q5"],
}

# Columns we expect to anchor on
KEY_COLS_BASE = ["Entity / Group", "Subquestion", "Worker Category"]
KEY_COLS_JOBF = ["Entity / Group", "Subquestion", "Worker Category", "Job Function"]

def _read_qc_table(xlsx: Path, sheet: str) -> pd.DataFrame:
    """
    Read a QC sheet and return the table under the band row.
    We detect the real header row by locating the 'Entity / Group' cell.
    """
    try:
        df_raw = pd.read_excel(xlsx, sheet_name=sheet, header=None, engine="openpyxl")
    except Exception:
        return pd.DataFrame()

    # find header row by scanning for "Entity / Group"
    header_row_idx = None
    for i in range(min(30, len(df_raw))):  # look near the top
        if df_raw.iloc[i].astype(str).str.strip().eq("Entity / Group").any():
            header_row_idx = i
            break
    if header_row_idx is None:
        return pd.DataFrame()

    headers = df_raw.iloc[header_row_idx].astype(str).tolist()
    df = df_raw.iloc[header_row_idx+1:].copy()
    df.columns = headers
    # drop completely empty rows
    df = df.dropna(how="all")
    # keep only non-empty Entity / Group
    if "Entity / Group" in df.columns:
        df = df[df["Entity / Group"].notna() & (df["Entity / Group"].astype(str).str.strip() != "")]
    return df.reset_index(drop=True)

def _coerce_num(s: pd.Series) -> pd.Series:
    """Convert numbers, turning 'N/A' and blanks into NaN."""
    return pd.to_numeric(s.replace({"N/A": None, "": None, "-": None}), errors="coerce")

def _long_month_rows(df: pd.DataFrame, question: str, extra_keys: List[str]) -> pd.DataFrame:
    """Build FactMonthly rows from any sheet that has real monthly columns."""
    have_months = [m for m in MONTHS if m in df.columns]
    if not have_months:
        return pd.DataFrame()
    id_cols = ["Entity / Group","Subquestion","Worker Category"] + extra_keys
    keep_cols = id_cols + have_months
    d = df[keep_cols].copy()
    for m in have_months:
        d[m] = _coerce_num(d[m])
    longm = d.melt(id_vars=id_cols, value_vars=have_months, var_name="Month", value_name="Value").dropna(subset=["Value"], how="all")
    if longm.empty:
        return longm
    # Month → Quarter and MonthNo
    month_no = {m:i+1 for i,m in enumerate(MONTHS)}
    def m_to_q(m): 
        for q, ml in Q_TO_MONTHS.items():
            if m in ml: return q
        return None
    longm["Question"] = question
    longm["MonthNo"] = longm["Month"].map(month_no)
    longm["Quarter"] = longm["Month"].map(m_to_q)
    # Year → infer from sheet title? Not present. Leave blank; Power BI can use About sheet or slicer.
    # If you prefer, you can add a 'Year' later by merge with an external period list.
    return longm

def _mom_rows(df: pd.DataFrame, question: str, extra_keys: List[str]) -> pd.DataFrame:
    """Build FactMoM from 'Diff <Mon>' and 'MoM <Mon>' columns."""
    id_cols = ["Entity / Group","Subquestion","Worker Category"] + extra_keys
    cols = [c for c in df.columns if c.startswith("Diff ") or c.startswith("MoM ")]
    if not cols:
        return pd.DataFrame()
    d = df[id_cols + cols].copy()
    # reshape: for each month after first, pull Diff m and MoM m
    recs = []
    for _, r in d.iterrows():
        base = {k: r[k] for k in id_cols}
        for m in MONTHS[1:]:
            diff_col = f"Diff {m}"
            mom_col  = f"MoM {m}"
            if diff_col in d.columns or mom_col in d.columns:
                rec = base.copy()
                rec["Question"] = question
                rec["Month"] = m
                rec["MonthNo"] = MONTHS.index(m) + 1
                rec["Diff"] = _coerce_num(pd.Series([r.get(diff_col, None)])).iloc[0]
                rec["MoM_Pct"] = _coerce_num(pd.Series([r.get(mom_col, None)])).iloc[0]
                recs.append(rec)
    return pd.DataFrame(recs)

def _quarter_sums(df: pd.DataFrame) -> List[str]:
    return [q for q in ALL_Q if q in df.columns]

def _qoq_rows(df: pd.DataFrame, question: str, extra_keys: List[str]) -> pd.DataFrame:
    """Build FactQoQ from 'Qx', 'Diff Qx', '%Diff Qx'."""
    id_cols = ["Entity / Group","Subquestion","Worker Category"] + extra_keys
    q_present = _quarter_sums(df)
    if not q_present:
        return pd.DataFrame()
    diff_cols = [f"Diff {q}" for q in q_present if f"Diff {q}" in df.columns]
    pct_cols  = [f"%Diff {q}" for q in q_present if f"%Diff {q}" in df.columns]
    keep = id_cols + q_present + diff_cols + pct_cols
    d = df[keep].copy()
    recs = []
    for _, r in d.iterrows():
        base = {k: r[k] for k in id_cols}
        for q in q_present:
            rec = base.copy()
            rec["Question"] = question
            rec["Quarter"] = q
            rec["QoQ_Diff"] = _coerce_num(pd.Series([r.get(f"Diff {q}", None)])).iloc[0]
            rec["QoQ_Pct"] = _coerce_num(pd.Series([r.get(f"%Diff {q}", None)])).iloc[0]
            recs.append(rec)
    return pd.DataFrame(recs)

def _yoy_quarter_rows(df: pd.DataFrame, question: str, extra_keys: List[str]) -> pd.DataFrame:
    """Build FactYoY_Quarter from 'Prior Qx' and 'YoY Qx'."""
    id_cols = ["Entity / Group","Subquestion","Worker Category"] + extra_keys
    q_present = _quarter_sums(df)
    prior_cols = [f"Prior {q}" for q in q_present if f"Prior {q}" in df.columns]
    yoy_cols   = [f"YoY {q}"   for q in q_present if f"YoY {q}"   in df.columns]
    if not prior_cols and not yoy_cols:
        return pd.DataFrame()
    keep = id_cols + prior_cols + yoy_cols
    d = df[keep].copy()
    recs = []
    for _, r in d.iterrows():
        base = {k: r[k] for k in id_cols}
        for q in q_present:
            rec = base.copy()
            rec["Question"] = question
            rec["Quarter"] = q
            rec["Prior"] = _coerce_num(pd.Series([r.get(f"Prior {q}", None)])).iloc[0]
            rec["YoY_Pct"] = _coerce_num(pd.Series([r.get(f"YoY {q}", None)])).iloc[0]
            recs.append(rec)
    return pd.DataFrame(recs)

def _yoy_month_rows(df: pd.DataFrame, question: str, extra_keys: List[str]) -> pd.DataFrame:
    """Build FactYoY_Month from 'Prior <Mon>' and 'YoY <Mon>'."""
    id_cols = ["Entity / Group","Subquestion","Worker Category"] + extra_keys
    months = [m for m in MONTHS if (f"Prior {m}" in df.columns) or (f"YoY {m}" in df.columns)]
    if not months:
        return pd.DataFrame()
    keep = id_cols + [f"Prior {m}" for m in months if f"Prior {m}" in df.columns] + \
           [f"YoY {m}" for m in months if f"YoY {m}" in df.columns]
    d = df[keep].copy()
    recs = []
    for _, r in d.iterrows():
        base = {k: r[k] for k in id_cols}
        for m in months:
            rec = base.copy()
            rec["Question"] = question
            rec["Month"] = m
            rec["MonthNo"] = MONTHS.index(m) + 1
            rec["Prior"] = _coerce_num(pd.Series([r.get(f"Prior {m}", None)])).iloc[0]
            rec["YoY_Pct"] = _coerce_num(pd.Series([r.get(f"YoY {m}", None)])).iloc[0]
            recs.append(rec)
    return pd.DataFrame(recs)

def _jobfunc_rows(df: pd.DataFrame, question: str) -> pd.DataFrame:
    """Build FactJobFunc for Q1/Q2 Job Function sheets (Q4-only)."""
    required = set(KEY_COLS_JOBF + ["Q4"])
    if not required.issubset(df.columns):
        return pd.DataFrame()
    d = df[list(required | set([f"Prior Q4", f"YoY Q4"]))].copy()
    d["Value"] = _coerce_num(d["Q4"])
    if "Prior Q4" in d.columns:
        d["PriorQ4"] = _coerce_num(d["Prior Q4"])
    else:
        d["PriorQ4"] = pd.NA
    if "YoY Q4" in d.columns:
        d["YoYQ4_Pct"] = _coerce_num(d["YoY Q4"])
    else:
        d["YoYQ4_Pct"] = pd.NA
    d["Question"] = question
    d["Quarter"] = "Q4"
    return d.rename(columns={
        "Entity / Group":"EntityGroupKey",
        "Subquestion":"Subquestion",
        "Worker Category":"WorkerCategory",
        "Job Function":"JobFunction"
    })[["Question","EntityGroupKey","Subquestion","WorkerCategory","JobFunction","Quarter","Value","PriorQ4","YoYQ4_Pct"]]

# ------------------
# Extraction per QC sheet
# ------------------
def extract_from_sheet(df: pd.DataFrame, sheet_name: str) -> Dict[str, pd.DataFrame]:
    """
    Return dict of tables from one QC sheet.
    Keys: fact_monthly, fact_mom, fact_qoq, fact_yoy_month, fact_yoy_quarter, fact_jobfunc
    """
    out = {
        "fact_monthly": pd.DataFrame(),
        "fact_mom": pd.DataFrame(),
        "fact_qoq": pd.DataFrame(),
        "fact_yoy_month": pd.DataFrame(),
        "fact_yoy_quarter": pd.DataFrame(),
        "fact_jobfunc": pd.DataFrame(),
    }
    if df.empty:
        return out

    # What question?
    q = "Q?"
    for qid in ["Q1","Q2","Q3","Q4","Q5"]:
        if sheet_name.startswith(f"QC_{qid}"):
            q = qid; break

    # Is this job function?
    is_jobf = "JobFunc" in sheet_name

    if is_jobf:
        out["fact_jobfunc"] = _jobfunc_rows(df, q)
        return out

    # Extra keys (none for main/b & q3/4/5)
    extra_keys: List[str] = []

    # Monthly values (if any)
    fm = _long_month_rows(df, q, extra_keys)
    out["fact_monthly"] = fm

    # MoM (% & diff) (if present)
    out["fact_mom"] = _mom_rows(df, q, extra_keys)

    # QoQ (% & diff) (if quarter sums present)
    out["fact_qoq"] = _qoq_rows(df, q, extra_keys)

    # YoY (quarters)
    out["fact_yoy_quarter"] = _yoy_quarter_rows(df, q, extra_keys)

    # YoY (months) — for Q1B/Q2B etc.
    out["fact_yoy_month"] = _yoy_month_rows(df, q, extra_keys)

    return out

# ------------------
# Dimensions
# ------------------
def build_dim_date(*facts: pd.DataFrame) -> pd.DataFrame:
    frames = [f for f in facts if f is not None and not f.empty]
    if not frames:
        return pd.DataFrame()
    # Collect year, quarter, month, monthno from any fact that has them
    cols = []
    for f in frames:
        cols.extend([c for c in ["Year","Quarter","Month","MonthNo"] if c in f.columns])
    # If no Year present (QC sheets don't include Year in table), we still export Quarter/Month for slicers
    cat_quarters = sorted({v for f in frames if "Quarter" in f.columns for v in f["Quarter"].dropna().unique()},
                          key=lambda x: ["Q1","Q2","Q3","Q4"].index(x) if x in ["Q1","Q2","Q3","Q4"] else 99)
    cat_months = sorted({v for f in frames if "Month" in f.columns for v in f["Month"].dropna().unique()},
                        key=lambda m: MONTHS.index(m) if m in MONTHS else 99)
    out = pd.DataFrame({
        "Quarter": cat_quarters if cat_quarters else [pd.NA],
        "Month": cat_months if cat_months else [pd.NA],
    })
    if "Month" in out.columns:
        out["MonthNo"] = out["Month"].map({m:i+1 for i,m in enumerate(MONTHS)})
    return out

def build_dim_entity(*facts: pd.DataFrame) -> pd.DataFrame:
    vals = set()
    for f in facts:
        if f is None or f.empty: continue
        col = "EntityGroupKey" if "EntityGroupKey" in f.columns else "Entity / Group" if "Entity / Group" in f.columns else None
        if col:
            vals.update(f[col].dropna().astype(str).str.strip().unique())
    return pd.DataFrame({"EntityGroupKey": sorted(vals)})

def build_dim_question(*facts: pd.DataFrame) -> pd.DataFrame:
    recs = set()
    for f in facts:
        if f is None or f.empty: continue
        qcol = "Question" if "Question" in f.columns else None
        if not qcol: continue
        sub = f.get("Subquestion", "")
        wc  = f.get("WorkerCategory", f.get("Worker Category",""))
        for q, s, w in zip(f[qcol].fillna(""), (sub if isinstance(sub, pd.Series) else [sub]*len(f)),
                           (wc if isinstance(wc, pd.Series) else [wc]*len(f))):
            recs.add( (str(q), str(s), str(w)) )
    if not recs:
        return pd.DataFrame()
    out = pd.DataFrame(sorted(recs), columns=["Question","Subquestion","WorkerCategory"])
    return out

def build_dim_jobfunction(f_job: pd.DataFrame) -> pd.DataFrame:
    if f_job is None or f_job.empty: return pd.DataFrame()
    vals = f_job["JobFunction"].dropna().astype(str).str.strip().unique()
    return pd.DataFrame({"JobFunction": sorted(vals)})

# ------------------
# Main
# ------------------
def main():
    ap = argparse.ArgumentParser(description="Export Power BI-friendly CSVs from QC workbook.")
    ap.add_argument("--qc", required=True, help="Path to QC workbook (the styled output)")
    ap.add_argument("--outdir", required=True, help="Folder to write CSVs")
    args = ap.parse_args()

    qc = Path(args.qc)
    outdir = Path(args.outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    # Gather sheets present
    try:
        xl = pd.ExcelFile(qc, engine="openpyxl")
        sheet_names = set(xl.sheet_names)
    except Exception as e:
        print(f"[ERROR] Unable to open workbook: {e}")
        return

    # Collect all fact slices
    all_facts: Dict[str, List[pd.DataFrame]] = {
        "fact_monthly": [], "fact_mom": [], "fact_qoq": [],
        "fact_yoy_month": [], "fact_yoy_quarter": [], "fact_jobfunc": []
    }

    for qid, q_sheets in SHEETS.items():
        for s in q_sheets:
            if s not in sheet_names:
                continue
            df = _read_qc_table(qc, s)
            if df.empty:
                continue
            pieces = extract_from_sheet(df, s)
            for k, v in pieces.items():
                if v is not None and not v.empty:
                    all_facts[k].append(v)

    # Concatenate and standardize column names
    fact_monthly      = pd.concat(all_facts["fact_monthly"], ignore_index=True) if all_facts["fact_monthly"] else pd.DataFrame()
    fact_mom          = pd.concat(all_facts["fact_mom"], ignore_index=True) if all_facts["fact_mom"] else pd.DataFrame()
    fact_qoq          = pd.concat(all_facts["fact_qoq"], ignore_index=True) if all_facts["fact_qoq"] else pd.DataFrame()
    fact_yoy_month    = pd.concat(all_facts["fact_yoy_month"], ignore_index=True) if all_facts["fact_yoy_month"] else pd.DataFrame()
    fact_yoy_quarter  = pd.concat(all_facts["fact_yoy_quarter"], ignore_index=True) if all_facts["fact_yoy_quarter"] else pd.DataFrame()
    fact_jobfunc      = pd.concat(all_facts["fact_jobfunc"], ignore_index=True) if all_facts["fact_jobfunc"] else pd.DataFrame()

    # Normalize key column names for facts that still have legacy names
    def norm_cols(df: pd.DataFrame) -> pd.DataFrame:
        if df is None or df.empty: return df
        ren = {}
        if "Entity / Group" in df.columns: ren["Entity / Group"] = "EntityGroupKey"
        if "Worker Category" in df.columns: ren["Worker Category"] = "WorkerCategory"
        return df.rename(columns=ren)

    fact_monthly     = norm_cols(fact_monthly)
    fact_mom         = norm_cols(fact_mom)
    fact_qoq         = norm_cols(fact_qoq)
    fact_yoy_month   = norm_cols(fact_yoy_month)
    fact_yoy_quarter = norm_cols(fact_yoy_quarter)

    # Build dims
    dim_date = build_dim_date(fact_monthly, fact_mom, fact_qoq, fact_yoy_month, fact_yoy_quarter, fact_jobfunc)
    dim_entity = build_dim_entity(fact_monthly, fact_mom, fact_qoq, fact_yoy_month, fact_yoy_quarter, fact_jobfunc)
    dim_question = build_dim_question(fact_monthly, fact_mom, fact_qoq, fact_yoy_month, fact_yoy_quarter, fact_jobfunc)
    dim_jobfunction = build_dim_jobfunction(fact_jobfunc)

    # Export CSVs
    def wcsv(df: pd.DataFrame, name: str):
        p = outdir / f"{name}.csv"
        if df is None or df.empty:
            # still write an empty file with headers (handy for Power BI schema)
            pd.DataFrame().to_csv(p, index=False)
        else:
            df.to_csv(p, index=False)
        print(f"  wrote {p.name}  ({len(df):,} rows)")

    print("\n[WRITE] Fact tables")
    wcsv(fact_monthly,     "fact_monthly")
    wcsv(fact_mom,         "fact_mom")
    wcsv(fact_qoq,         "fact_qoq")
    wcsv(fact_yoy_month,   "fact_yoy_month")
    wcsv(fact_yoy_quarter, "fact_yoy_quarter")
    wcsv(fact_jobfunc,     "fact_jobfunc")

    print("\n[WRITE] Dimension tables")
    wcsv(dim_date,        "dim_date")
    wcsv(dim_entity,      "dim_entity")
    wcsv(dim_question,    "dim_question")
    if not dim_jobfunction.empty:
        wcsv(dim_jobfunction, "dim_jobfunction")

    print(f"\n[DONE] CSVs ready at: {outdir.resolve()}")

if __name__ == "__main__":
    main()
