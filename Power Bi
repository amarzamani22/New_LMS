# build_analysis_csv.py
from __future__ import annotations
import argparse, sys
from pathlib import Path
from typing import Dict, List, Optional
import pandas as pd

EXPECTED_SHEETS = [
    "Q1A_Main", "Q1A_JobFunc_Q4", "Q1B",
    "Q2A_Main", "Q2A_JobFunc_Q4", "Q2B",
    "Q3", "Q4", "Q5",
]

MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
QMAP = {"Quarter 1":"Q1","Quarter 2":"Q2","Quarter 3":"Q3","Quarter 4":"Q4",
        "Q1":"Q1","Q2":"Q2","Q3":"Q3","Q4":"Q4"}

def _norm_q(q):
    if q is None: return ""
    s = str(q).strip()
    return QMAP.get(s, s)

def read_stage_xlsx(path: Path) -> Dict[str, pd.DataFrame]:
    out: Dict[str, pd.DataFrame] = {}
    try:
        xf = pd.ExcelFile(path, engine="openpyxl")
    except Exception as e:
        print(f"[ERROR] Cannot open staging xlsx: {e}")
        return out
    print(f"[INFO] Found sheets in {path.name}: {xf.sheet_names}")
    for s in EXPECTED_SHEETS:
        if s in xf.sheet_names:
            try:
                df = pd.read_excel(path, sheet_name=s, engine="openpyxl")
                if not df.empty:
                    out[s] = df
                    print(f"[LOAD] {s}: {len(df):,} rows")
            except Exception as e:
                print(f"[WARN] Failed reading {s}: {e}")
    return out

def read_stage_csvdir(folder: Path) -> Dict[str, pd.DataFrame]:
    out: Dict[str, pd.DataFrame] = {}
    for s in EXPECTED_SHEETS:
        p = folder / f"{s}.csv"
        if p.exists():
            try:
                df = pd.read_csv(p)
                if not df.empty:
                    out[s] = df
                    print(f"[LOAD] {s} (csv): {len(df):,} rows")
            except Exception as e:
                print(f"[WARN] Failed reading {p.name}: {e}")
    return out

def ensure_cols(df: pd.DataFrame, cols: List[str]) -> pd.DataFrame:
    d = df.copy()
    for c in cols:
        if c not in d.columns:
            d[c] = "" if c in ("subquestion","worker_category","job_function") else 0
    return d

def melt_months(df: pd.DataFrame, id_cols: List[str]) -> pd.DataFrame:
    months_present = [m for m in MONTHS if m in df.columns]
    if not months_present:
        # job-function (value only) — synthesize Q4 as “Dec period” for PB charts
        if "value" in df.columns:
            d = df.copy()
            d["month"] = "Dec"
            d["value"] = pd.to_numeric(d["value"], errors="coerce").fillna(0.0)
            return d[id_cols + ["month","value"]]
        return pd.DataFrame(columns=id_cols + ["month","value"])
    d = df.copy()
    for m in months_present:
        d[m] = pd.to_numeric(d[m], errors="coerce").fillna(0.0)
    m = d.melt(id_vars=id_cols, value_vars=months_present,
               var_name="month", value_name="value")
    return m

def add_entity_group(df: pd.DataFrame) -> pd.DataFrame:
    # Keep the literal entity_name as the “group” column for PB drill/filter
    d = df.copy()
    if "entity_name" in d.columns:
        d["entity_group"] = d["entity_name"]
    else:
        d["entity_group"] = "Unknown"
    return d

def build_analysis_rows(sheet: str, df: pd.DataFrame) -> pd.DataFrame:
    base = df.copy()
    # Normalize structure
    for c in ["entity_name","year","quarter"]:
        if c not in base.columns: base[c] = None
    base["quarter"] = base["quarter"].map(_norm_q)
    # Figure question label
    if sheet.startswith("Q1A"):
        question = "Q1A"
    elif sheet == "Q1B":
        question = "Q1B"
    elif sheet.startswith("Q2A"):
        question = "Q2A"
    elif sheet == "Q2B":
        question = "Q2B"
    else:
        question = sheet  # Q3 / Q4 / Q5

    # Ensure optional columns
    if "subquestion" not in base.columns: base["subquestion"] = ""
    if "worker_category" not in base.columns: base["worker_category"] = ""
    if "job_function" not in base.columns: base["job_function"] = ""
    # Identify ID columns per sheet
    id_cols = ["entity_name","entity_group","year","quarter","question",
               "subquestion","worker_category","job_function"]

    # Add question label & entity_group
    base["question"] = question
    base = add_entity_group(base)

    # Q1B/Q2B are single-month (Jun/Dec). Keep as months too so visuals work.
    if sheet in ("Q1B","Q2B"):
        # Could be Jun or Dec depending on quarter; already columns named “Jun/Dec” in staging
        # Let melt_months handle whichever month exists.
        pass

    # Make long (month,value)
    long = melt_months(base, id_cols=id_cols)

    # Build period (YYYY-MM) for DateTable join in PBI
    month_to_num = {m:i for i,m in enumerate(MONTHS, start=1)}
    long["month_num"] = long["month"].map(month_to_num).fillna(1).astype(int)
    long["period"] = long.apply(lambda r: f"{int(r['year'])}-{r['month_num']:02d}" if pd.notnull(r["year"]) else "", axis=1)
    # Clean types
    long["year"] = pd.to_numeric(long["year"], errors="coerce").astype("Int64")
    long["value"] = pd.to_numeric(long["value"], errors="coerce").fillna(0.0)
    # Order columns
    cols = ["entity_group","entity_name","year","quarter","period","month","question",
            "subquestion","worker_category","job_function","value"]
    long = long[cols]
    return long

def main():
    ap = argparse.ArgumentParser(description="Build analysis_base.csv from staging (xlsx or csv folder).")
    ap.add_argument("--stage-xlsx", type=str, default=None, help="Path to staging workbook (.xlsx)")
    ap.add_argument("--csv-dir", type=str, default=None, help="Folder containing per-sheet CSVs (Q1A_Main.csv, ...)")
    ap.add_argument("--out", type=str, required=True, help="Output CSV path (analysis_base.csv)")
    args = ap.parse_args()

    loaded: Dict[str, pd.DataFrame] = {}
    if args.stage_xlsx:
        p = Path(args.stage_xlsx)
        if not p.exists():
            print(f"[ERROR] Staging .xlsx not found: {p}")
            sys.exit(2)
        loaded = read_stage_xlsx(p)
    elif args.csv_dir:
        d = Path(args.csv_dir)
        if not d.exists():
            print(f"[ERROR] CSV dir not found: {d}")
            sys.exit(2)
        loaded = read_stage_csvdir(d)
    else:
        print("[ERROR] Provide either --stage-xlsx or --csv-dir")
        sys.exit(2)

    if not loaded:
        print("[ERROR] No sheets found. I looked for:", ", ".join(EXPECTED_SHEETS))
        sys.exit(3)

    rows: List[pd.DataFrame] = []
    for name, df in loaded.items():
        try:
            part = build_analysis_rows(name, df)
            if not part.empty:
                rows.append(part)
                print(f"[OK] {name} → {len(part):,} rows")
            else:
                print(f"[SKIP] {name} produced 0 rows")
        except Exception as e:
            print(f"[WARN] Failed to process {name}: {e}")

    if not rows:
        print("[ERROR] Everything was empty after processing.")
        sys.exit(4)

    final = pd.concat(rows, ignore_index=True)
    final.sort_values(["question","entity_group","entity_name","year","period",
                       "subquestion","worker_category","job_function"],
                      kind="mergesort", inplace=True)
    outp = Path(args.out)
    outp.parent.mkdir(parents=True, exist_ok=True)
    final.to_csv(outp, index=False)
    print(f"[DONE] Wrote {len(final):,} rows → {outp}")

if __name__ == "__main__":
    main()
