import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import re
import os

# --- Page Configuration (Set first for a professional look) ---
st.set_page_config(
    page_title="Advanced YoY QC Dashboard",
    page_icon="üè¶",
    layout="wide"
)

# --- Modern CSS Styling ---
st.markdown("""
<style>
    /* Main app background */
    .stApp {
        background-color: #F0F2F6;
    }
    /* Metric cards styling */
    .stMetric {
        border-radius: 10px;
        padding: 20px;
        background-color: #FFFFFF;
        border: 1px solid #E0E0E0;
        box-shadow: 0 4px 6px rgba(0,0,0,0.04);
    }
    /* Make metric labels bold and slightly larger */
    .st-emotion-cache-176r98r {
        font-weight: 600;
        font-size: 1.1em;
    }
    /* Style for buttons */
    .stButton>button {
        border-radius: 8px;
        font-weight: 600;
    }
</style>
""", unsafe_allow_html=True)

# --- 1. Helper Functions ---
@st.cache_data
def load_data(year, sheet_name):
    """Loads data for a specific year and sheet."""
    file_path = f"submission/qc_workbook_{year}.xlsx"
    if not os.path.exists(file_path):
        return f"Error: File not found. Please ensure '{file_path}' exists in a 'submission' subfolder."
    try:
        df = pd.read_excel(file_path, sheet_name=sheet_name, header=5)
        df.dropna(axis=1, how='all', inplace=True)
        rename_map = {'Q1.1': 'Q1_Total', 'Q2.1': 'Q2_Total', 'Q3.1': 'Q3_Total', 'Q4.1': 'Q4_Total'}
        df.rename(columns=rename_map, inplace=True)
        return df
    except Exception as e:
        return f"Error reading sheet '{sheet_name}' from {file_path}: {e}"

@st.cache_data
def get_reporting_quarter(year):
    """Reads the _About sheet from the specified year's workbook to get the quarter."""
    file_path = f"submission/qc_workbook_{year}.xlsx"
    try:
        about_df = pd.read_excel(file_path, sheet_name="_About", header=None)
        quarter_row = about_df[about_df[0] == 'Quarter']
        if not quarter_row.empty:
            return int(re.search(r'\d+', quarter_row.iloc[0, 1]).group())
    except Exception:
        return 4 # Default to Q4 if sheet is missing or malformed

def find_outliers(data_series, prior_year_series, pct_thresh, abs_thresh, iqr_multiplier, yoy_thresh):
    outliers = []
    if data_series.isnull().all() or len(data_series) < 2: return pd.DataFrame()

    q1, q3 = data_series.quantile(0.25), data_series.quantile(0.75)
    iqr = q3 - q1 if len(data_series) >= 4 else 0
    iqr_lower_bound, iqr_upper_bound = q1 - (iqr_multiplier * iqr), q3 + (iqr_multiplier * iqr)

    for i, (period_name, current_value) in enumerate(data_series.items()):
        reasons = []
        if pd.isna(current_value): continue

        if i > 0:
            prev_val = data_series.iloc[i-1]
            if not pd.isna(prev_val) and prev_val != 0:
                abs_change = current_value - prev_val; pct_change = abs_change / prev_val
                if abs(pct_change) > pct_thresh and abs(abs_change) > abs_thresh: reasons.append(f"High Volatility ({pct_change:+.1%})")
        if iqr > 0 and (current_value < iqr_lower_bound or current_value > iqr_upper_bound): reasons.append("Annual Anomaly")
        if prior_year_series is not None and period_name in prior_year_series.index:
            prior_value = prior_year_series[period_name]
            if not pd.isna(prior_value) and prior_value != 0:
                yoy_change = (current_value - prior_value) / prior_value
                if abs(yoy_change) > yoy_thresh: reasons.append(f"YoY Anomaly ({yoy_change:+.1%})")
        
        if reasons:
            outliers.append({"Period": period_name, "Value": f"{current_value:,.2f}", "Reason(s)": ", ".join(reasons)})
            
    return pd.DataFrame(outliers)

def generate_full_report(sheet_map, years, questions_to_scan, thresholds, all_months):
    master_outlier_list = []
    progress_bar = st.progress(0, text="Initializing Scan...")
    
    total_scans = len(questions_to_scan)
    for i, q_name in enumerate(questions_to_scan):
        sheet_name = sheet_map[q_name]
        progress_bar.progress(i / total_scans, text=f"Scanning: {q_name}")
        df_current = load_data(years['current'], sheet_name)
        df_prior = load_data(years['prior'], sheet_name) if years['prior'] else None

        if isinstance(df_current, str): continue
        
        actual_months = [m for m in all_months if m in df_current.columns]

        for _, row in df_current.iterrows():
            entity, wc, subq = row['Entity / Group'], row['Worker Category'], row.get('Subquestion', 'N/A')
            monthly_series = row[actual_months].astype(float)
            
            prior_series = None
            if not isinstance(df_prior, str) and df_prior is not None:
                prior_row = df_prior[(df_prior['Entity / Group'] == entity) & (df_prior.get('Subquestion', 'N/A') == subq) & (df_prior['Worker Category'] == wc)]
                if not prior_row.empty: prior_series = prior_row[all_months].iloc[0].astype(float)
            
            outliers_monthly = find_outliers(monthly_series, prior_series, **thresholds)
            for _, o_row in outliers_monthly.iterrows():
                master_outlier_list.append([q_name, entity, subq, wc, 'Monthly', o_row['Period'], o_row['Value'], o_row['Reason(s)']])

    progress_bar.progress(1.0, text="Scan Complete!")
    return pd.DataFrame(master_outlier_list, columns=['Question', 'Entity / Group', 'Subquestion', 'Worker Category', 'View', 'Period', 'Value', 'Reason(s)'])


# --- Main Dashboard Interface ---
st.title("üè¶ Advanced QC & YoY Analysis Dashboard")

# --- Global Time Context & Sidebar Controls ---
all_months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
SHEET_MAP = {'Q1A: Employees': 'QC_Q1A_Main', 'Q2A: Salary': 'QC_Q2A_Main', 'Q3: Hours Worked': 'QC_Q3', 'Q4: Vacancies': 'QC_Q4', 'Q5: Separations': 'QC_Q5'}

st.sidebar.title("Analysis Controls")
current_year = st.sidebar.selectbox("Current Year:", [2026, 2025, 2024, 2023])
comparison_year = st.sidebar.selectbox("Comparison Year:", [2025, 2024, 2023, None], index=0)
st.sidebar.markdown("---")
analysis_view = st.sidebar.radio("Select View:", ('Interactive Analysis', 'Full Outlier Report'), label_visibility="collapsed")
st.sidebar.markdown("---")

reporting_quarter = get_reporting_quarter(current_year)
months_to_analyze = all_months[:reporting_quarter * 3]
quarters_to_analyze = [f'Q{i+1}' for i in range(reporting_quarter)]
st.sidebar.info(f"Analyzing **{current_year}** data up to **Q{reporting_quarter}**.")

# --- View 1: Interactive Analysis ---
if analysis_view == 'Interactive Analysis':
    st.sidebar.subheader("Thresholds")
    abs_thresh = st.sidebar.slider("Absolute Change", 10, 1000, 50, 10)
    iqr_mult = st.sidebar.slider("IQR Sensitivity", 1.0, 3.0, 1.5, 0.1)
    yoy_thresh = st.sidebar.slider("YoY % Threshold", 0.1, 1.0, 0.3, 0.05, format="%.0f%%")
    
    time_view = st.sidebar.radio("Timeframe:", ('Monthly', 'Quarterly'), horizontal=True)
    selected_question = st.sidebar.selectbox("Dataset:", options=list(SHEET_MAP.keys()))
    
    df_current = load_data(current_year, SHEET_MAP[selected_question])
    df_prior = load_data(comparison_year, SHEET_MAP[selected_question]) if comparison_year else None

    if isinstance(df_current, str): st.error(df_current)
    else:
        entity = st.selectbox("Select an Entity / Group:", options=df_current['Entity / Group'].unique())
        
        if 'Subquestion' in df_current.columns and df_current[df_current['Entity / Group'] == entity]['Subquestion'].nunique() > 1:
            subquestion = st.selectbox("Select a Subquestion:", options=df_current[df_current['Entity / Group'] == entity]['Subquestion'].unique())
            worker_cat = st.selectbox("Select a Worker Category:", options=df_current[(df_current['Entity / Group'] == entity) & (df_current['Subquestion'] == subquestion)]['Worker Category'].unique())
            data_row = df_current[(df_current['Entity / Group'] == entity) & (df_current['Subquestion'] == subquestion) & (df_current['Worker Category'] == worker_cat)]
        else:
            subquestion = "N/A"
            worker_cat = st.selectbox("Select a Worker Category:", options=df_current[df_current['Entity / Group'] == entity]['Worker Category'].unique())
            data_row = df_current[(df_current['Entity / Group'] == entity) & (df_current['Worker Category'] == worker_cat)]

        st.header(f"Analysis for: {entity}"); st.caption(f"Category: {worker_cat}")
        
        current_series, prior_series = pd.Series(), None
        if time_view == 'Monthly':
            actual_months = [m for m in months_to_analyze if m in data_row.columns]
            if actual_months: current_series = data_row[actual_months].iloc[0].astype(float)
            title = "Monthly Trend"
            if not isinstance(df_prior, str) and df_prior is not None:
                prior_row = df_prior[(df_prior['Entity / Group'] == entity) & (df_prior.get('Subquestion', 'N/A') == subquestion) & (df_prior['Worker Category'] == worker_cat)]
                if not prior_row.empty and all(m in prior_row.columns for m in actual_months):
                    prior_series = prior_row[actual_months].iloc[0].astype(float)
        else: # Quarterly
            q_cols = [f'Q{i+1}_Total' for i in range(len(quarters_to_analyze))]
            if all(p in data_row.columns for p in q_cols):
                current_series = data_row[q_cols].iloc[0].astype(float); current_series.index = quarters_to_analyze
            title = "Quarterly Trend"
            if not isinstance(df_prior, str) and df_prior is not None:
                prior_row = df_prior[(df_prior['Entity / Group'] == entity) & (df_prior.get('Subquestion', 'N/A') == subquestion) & (df_prior['Worker Category'] == worker_cat)]
                if not prior_row.empty:
                    q_cols_prior = [f'Q{i+1}_Total' for i in range(len(quarters_to_analyze))]
                    if all(p in prior_row.columns for p in q_cols_prior):
                        prior_series = prior_row[q_cols_prior].iloc[0].astype(float); prior_series.index = quarters_to_analyze
        
        if current_series.empty or current_series.isnull().all(): st.warning("No data found for the selected filters or period.")
        else:
            outlier_df = find_outliers(current_series, prior_series, 0.25, abs_thresh, iqr_mult, yoy_thresh)
            col1, col2, col3, col4 = st.columns(4)
            col1.metric("Latest Value", f"{current_series.iloc[-1]:,.0f}"); col2.metric("Period Average", f"{current_series.mean():,.0f}"); col3.metric("Period High", f"{current_series.max():,.0f}"); col4.metric("True Outliers", len(outlier_df))
            
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(current_series.index, current_series, marker='o', linestyle='-', label=f'{current_year} Trend', zorder=10)
            if prior_series is not None: ax.plot(prior_series.index, prior_series, marker='.', linestyle='--', label=f'{comparison_year} Trend', color='gray', alpha=0.8)
            upper_band = [np.nan] + [current_series.iloc[i-1] * 1.25 for i in range(1, len(current_series))]; lower_band = [np.nan] + [current_series.iloc[i-1] * 0.75 for i in range(1, len(current_series))]
            ax.fill_between(current_series.index, lower_band, upper_band, color='gray', alpha=0.1, label='MoM ¬±25% Range')
            if not outlier_df.empty: ax.scatter(outlier_df['Period'], current_series[outlier_df['Period']], s=250, c='red', marker='X', zorder=20, label='True Outlier')
            ax.legend(); ax.grid(True, alpha=0.3); st.pyplot(fig)
            
            if not outlier_df.empty: st.error("üö® True Outlier(s) Detected!"); st.dataframe(outlier_df, use_container_width=True)
            else: st.success("‚úÖ No significant outliers detected.")
            
            # --- NEW: Upgraded Raw Data Section ---
            with st.expander("Show Raw Data for Comparison"):
                st.subheader(f"Data for {current_year}")
                st.dataframe(data_row)
                
                if comparison_year:
                    st.subheader(f"Data for {comparison_year}")
                    if not isinstance(df_prior, str) and df_prior is not None:
                        prior_row_display = df_prior[(df_prior['Entity / Group'] == entity) & (df_prior.get('Subquestion', 'N/A') == subquestion) & (df_prior['Worker Category'] == worker_cat)]
                        if not prior_row_display.empty:
                            st.dataframe(prior_row_display)
                        else:
                            st.warning(f"No matching data found for this selection in the {comparison_year} workbook.")
                    else:
                        st.error(f"Could not load data for {comparison_year}. Please check the file.")

# --- View 2: Full Outlier Report ---
elif analysis_view == 'Full Outlier Report':
    st.header("Master Outlier Report Generator")
    st.write("This tool scans the workbook(s) to find all significant outliers based on the thresholds you set.")
    
    st.sidebar.subheader("Report Thresholds")
    abs_thresh_report = st.sidebar.slider("Absolute Change", 10, 1000, 50, 10)
    iqr_mult_report = st.sidebar.slider("IQR Sensitivity", 1.0, 3.0, 1.5, 0.1)
    yoy_thresh_report = st.sidebar.slider("YoY % Threshold", 0.1, 1.0, 0.3, 0.05, format="%.0f%%")
    
    questions_to_scan = st.multiselect("Select datasets to include in the report:", options=list(SHEET_MAP.keys()), default=list(SHEET_MAP.keys()))

    if st.button("üöÄ Generate Full Report", use_container_width=True):
        if not questions_to_scan: st.warning("Please select at least one dataset to scan.")
        else:
            with st.spinner("Analyzing workbook(s)... This may take a moment."):
                report_thresholds = {'pct_thresh': 0.25, 'abs_thresh': abs_thresh_report, 'iqr_multiplier': iqr_mult_report, 'yoy_thresh': yoy_thresh_report}
                years = {'current': current_year, 'prior': comparison_year}
                final_report = generate_full_report(SHEET_MAP, years, questions_to_scan, report_thresholds, all_months)
            
            st.success(f"Scan complete! Found **{len(final_report)}** potential outliers.")
            if not final_report.empty:
                st.dataframe(final_report, use_container_width=True)
                csv = final_report.to_csv(index=False).encode('utf-8')
                st.download_button(label="üì• Download Report as CSV", data=csv, file_name="master_outlier_report.csv", mime="text/csv", use_container_width=True)
